#include "LevelManager.h"
#include "UnitManager.h"
#include "Game.h"

LevelManager::LevelManager()
{
	srand(time(NULL));
	mPoints = 0;
	mPointSpawnChance = 0;
	mSpeedUpSpawnChance = 0; 
	mSpeedDownSpawnChance = 0;
}

LevelManager::~LevelManager()
{
	clear();
}

void LevelManager::clear()
{
	//Walls
	for (unsigned int i = 0; i < mWallVector.size(); i++)
	{
		delete mWallVector[i];
	}
	mWallVector.clear();

	//Foods
	for (unsigned int i = 0; i < mFoodVector.size(); i++)
	{
		delete mFoodVector[i];
	}
	mFoodVector.clear();

	for (unsigned int i = 0; i < mPointsVector.size(); i++)
	{
		delete mPointsVector[i];
	}
	mPointsVector.clear();

	for (unsigned int i = 0; i < mSpeedUpVector.size(); i++)
	{
		delete mSpeedUpVector[i];
	}
	mSpeedUpVector.clear();

	for (unsigned int i = 0; i < mSpeedDownVector.size(); i++)
	{
		delete mSpeedDownVector[i];
	}
	mSpeedDownVector.clear();
}

void LevelManager::removeWall(Unit* destroy)
{
	for (unsigned int i = 0; i < mWallVector.size(); i++)
	{
		Unit* tmp = mWallVector[i];
		if (tmp == destroy)
		{
			delete tmp;
			mWallVector.erase(mWallVector.begin() + i);
		}
	}
}

void LevelManager::removeFood(Unit* destroy)
{
	for (unsigned int i = 0; i < mFoodVector.size(); i++)
	{
		Unit* tmp = mFoodVector[i];
		if (tmp == destroy)
		{
			delete tmp;
			mFoodVector.erase(mFoodVector.begin() + i);
		}
	}
}

void LevelManager::removePoint(Unit* destroy)
{
	for (unsigned int i = 0; i < mPointsVector.size(); i++)
	{
		Unit* tmp = mPointsVector[i];
		if (tmp == destroy)
		{
			delete tmp;
			mPointsVector.erase(mPointsVector.begin() + i);
		}
	}
}

void LevelManager::removeSUp(Unit* destroy)
{
	for (unsigned int i = 0; i < mSpeedUpVector.size(); i++)
	{
		Unit* tmp = mSpeedUpVector[i];
		if (tmp == destroy)
		{
			delete tmp;
			mSpeedUpVector.erase(mSpeedUpVector.begin() + i);
		}
	}
}

void LevelManager::removeSDown(Unit* destroy)
{
	for (unsigned int i = 0; i < mSpeedDownVector.size(); i++)
	{
		Unit* tmp = mSpeedDownVector[i];
		if (tmp == destroy)
		{
			delete tmp;
			mSpeedDownVector.erase(mSpeedDownVector.begin() + i);
		}
	}
}

void LevelManager::checkIntersection(vector<Unit*>& vector, Vector2D pos, bool &returnBool)
{
	for (unsigned int i = 0; i < vector.size(); i++)
	{
		if (vector[i]->getPos() == pos)
		{
			returnBool = true;
		}
	}
}

void LevelManager::checkSpawns(UnitManager& snake)
{
	//rand 1-1000
	if ((rand() % 1000) + 1 < mPointSpawnChance)
	{
		spawnItem(POINTS_KEY, snake);
	}
	if ((rand() % 1000) + 1 < mSpeedUpSpawnChance)
	{
		spawnItem(SPEEDUP_KEY, snake);
	}
	if ((rand() % 1000) + 1 < mSpeedDownSpawnChance)
	{
		spawnItem(SPEEDDOWN_KEY, snake);
	}
}

void LevelManager::spawnItem(string key, UnitManager& snake)
{
	bool intersect = false;
	
	do
	{
		intersect = false;
		//New position to spawn
		Vector2D newPos = Vector2D(((rand() % 16) * 50) + 25, ((rand() % 12) * 50) + 25);

		//Check for snake
		for (int i = 0; i < snake.getSize(); i++)
		{
			if (snake.getUnit(i)->getPos() == newPos)
				intersect = true;
		}

		checkIntersection(mWallVector, newPos, intersect);
		checkIntersection(mFoodVector, newPos, intersect);
		checkIntersection(mPointsVector, newPos, intersect);
		checkIntersection(mSpeedUpVector, newPos, intersect);
		checkIntersection(mSpeedDownVector, newPos, intersect);

		//Only spawn if all walls negative
		if (!intersect)
		{
			Unit* newUnit = new Unit(key, newPos, 2, 2);
			if(key == FOOD_KEY)
				addFood(newUnit);
			if (key == POINTS_KEY)
				addPointPickup(newUnit);
			if (key == SPEEDUP_KEY)
				addSUp(newUnit);
			if (key == SPEEDDOWN_KEY)
				addSDown(newUnit);
		}

	} while (intersect);
}

void LevelManager::updateAll(double dt, UnitManager& snake)
{
	mCurrentTime += dt;
	if (mCurrentTime > mUpdateSpeed)
	{
		for (unsigned int i = 0; i < mFoodVector.size(); i++)
		{
			mFoodVector[i]->update(dt);
		}
		for (unsigned int i = 0; i < mPointsVector.size(); i++)
		{
			mPointsVector[i]->update(dt);
		}
		for (unsigned int i = 0; i < mSpeedUpVector.size(); i++)
		{
			mSpeedUpVector[i]->update(dt);
		}
		for (unsigned int i = 0; i < mSpeedDownVector.size(); i++)
		{
			mSpeedDownVector[i]->update(dt);
		}

		//check spawns here
		checkSpawns(snake);

		mCurrentTime = 0;
	}
}

void LevelManager::drawAll(GraphicsSystem* display)
{
	for (unsigned int i = 0; i < mWallVector.size(); i++)
	{
		mWallVector[i]->draw(display);
	}
	for (unsigned int i = 0; i < mFoodVector.size(); i++)
	{
		mFoodVector[i]->draw(display);
	}
	for (unsigned int i = 0; i < mPointsVector.size(); i++)
	{
		mPointsVector[i]->draw(display);
	}
	for (unsigned int i = 0; i < mSpeedUpVector.size(); i++)
	{
		mSpeedUpVector[i]->draw(display);
	}
	for (unsigned int i = 0; i < mSpeedDownVector.size(); i++)
	{
		mSpeedDownVector[i]->draw(display);
	}
}
