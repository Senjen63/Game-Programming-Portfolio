#include "Snake.h"
#include "Game.h"
#include "SnakeEvents.h"

const int SPEED_CHANGE = 32, MIN_SPEED = 500, MAX_SPEED = 112;

Snake::Snake()
{
	mpHead = nullptr;
	mElapTime = 0;
	mTargetTime = 0;
	mCurDir = Direction::UP;
}

Snake::~Snake()
{
	Game::getGame()->getUnitMan()->deleteUnit(mpHead);
}

void Snake::init(Unit* head, int tT)
{
	mpHead = head;
	mElapTime = 0;
	mTargetTime = tT;
	mCurDir = Direction::UP;
	mpSnake.push_back(head);
}

void Snake::addUnit( Unit* unit )
{
	int newX = mpSnake[mpSnake.size() - 1]->getX();
	int newY = mpSnake[mpSnake.size() - 1]->getY();
	switch (getCurDir())
	{
	case Direction::UP:
		unit->setX(newX);
		unit->setY(newY + 32);
		break;
	case Direction::DOWN:
		unit->setX(newX);
		unit->setY(newY - 32);
		break;
	case Direction::RIGHT:
		unit->setX(newX - 32);
		unit->setY(newY);
		break;
	case Direction::LEFT:
		unit->setX(newX + 32);
		unit->setY(newY);
		break;
	}

	mpSnake.push_back( unit );
}

void Snake::removeUnit( Unit* unit )
{
	for ( int i = 0; i < mpSnake.size(); i++ )
	{
		Unit* pUnit = mpSnake[ i ];
		if ( pUnit == unit )
		{
			Game::getGame()->getUnitMan()->deleteUnit( pUnit );
			break;
		}
	}
}

void Snake::removeUnit( int index )
{
	Game::getGame()->getUnitMan()->deleteUnit( mpSnake[ index ] );
}

void Snake::setCurDir( Direction dir )
{
	mCurDir = dir;
}

void Snake::setCurTT( int tT )
{
	mTargetTime = tT;
}

void Snake::updateAll( float deltaTime )
{
	Game::getGame()->getUnitMan()->checkCollision(getHead());
	mElapTime += deltaTime;
	if ( mElapTime >= mTargetTime )
	{
		for ( int i = mpSnake.size() - 1; i > -1; i-- )
		{
			if ( mpSnake[ i ] == mpHead )
			{
				switch ( getCurDir() )
				{
				case Direction::UP:
					mpSnake[ i ]->setY( mpHead->getY() - 32 );
					break;
				case Direction::DOWN:
					mpSnake[ i ]->setY( mpHead->getY() + 32 );
					break;
				case Direction::RIGHT:
					mpSnake[ i ]->setX( mpHead->getX() + 32 );
					break;
				case Direction::LEFT:
					mpSnake[ i ]->setX( mpHead->getX() - 32 );
					break;
				}
			}
			else
			{
				int preX = mpSnake[ i - 1 ]->getX();
				int preY = mpSnake[ i - 1 ]->getY();
				mpSnake[ i ]->setY( preY );
				mpSnake[ i ]->setX( preX );
			}
		}

		mElapTime -= mTargetTime;
	}
}

void Snake::handleEvent( const Event& theEvent )
{
	switch ( theEvent.getType() )
	{
	case CHANGE_DIR_EVENT:
		{
		const ChangeDirectionEvent& dirEvent = static_cast<const ChangeDirectionEvent&>(theEvent);
		setCurDir(dirEvent.getDir());
		}
		break;
	case CHANGE_SPEED_EVENT:
		{
		const ChangeSpeedEvent& csEvent = static_cast<const ChangeSpeedEvent&>(theEvent);
		switch (csEvent.getChange())
		{
		case 0:
			if (getCurTT() > MAX_SPEED)
				setCurTT(getCurTT() - SPEED_CHANGE);
			else
				setCurTT(MAX_SPEED);
			break;
		case 1:
			if (getCurTT() < MIN_SPEED)
				setCurTT(getCurTT() + SPEED_CHANGE);
			else
				setCurTT(MIN_SPEED);
			break;
		}
		}
		break;
	}
	//unsure why needs to be const
	
}