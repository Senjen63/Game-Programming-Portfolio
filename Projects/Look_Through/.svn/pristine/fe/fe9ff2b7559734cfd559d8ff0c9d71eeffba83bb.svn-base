#include "LevelManager.h"
#include "Game.h"
#include "Unit.h"

LevelManager::LevelManager()
{
    mCurrentLevel = 0;
    mDifficulty = EASY;
    mSavedPosition = Vector2D(0, 0);
}


LevelManager::~LevelManager()
{
    cleanup();
}


void LevelManager::init()
{
    mpEventSystem = EventSystem::getInstance();

    mpEventSystem->addListener((EventType)ACTION_GAME_EVENT, this);
}


void LevelManager::cleanup()
{
    deleteAllLevels();
    mpEventSystem = nullptr;
}


Level* LevelManager::getCurrentLevel()
{
    if (mLevels.size() > 0)
    {
        return mLevels[mCurrentLevel];
    }
    
    return nullptr;
}


Level* LevelManager::getLevelByIndex(unsigned int index)
{
    if (mLevels.size() > 0 && mLevels.size() < index)
    {
        return mLevels[index];
    }

    return nullptr;
}


unsigned int LevelManager::getCurrentLevelIndex()
{
    if (mLevels.size() > 0)
    {
        return mCurrentLevel;
    }
    
    return -1; //no levels
}


unsigned int LevelManager::getLastLevelIndex()
{
    if (mLevels.size() > 0)
    {
        return mLevels.size() - 1;
    }

    return -1; //no levels
}


Difficulty LevelManager::getDifficulty()
{
    return mDifficulty;
}


Vector2D LevelManager::getSavedPosition()
{
    return mSavedPosition;
}


vector<Vector2D> LevelManager::getSavedCollectiblePositions()
{
    return mSavedCollectibles;
}


void LevelManager::setLevelIndex(int levelIndex)
{
    mCurrentLevel = levelIndex;

    if (mCurrentLevel > mLevels.size())
    {
        mCurrentLevel = 0;
    }
}


void LevelManager::setDifficulty(Difficulty newDifficulty)
{
    mDifficulty = newDifficulty;
}


void LevelManager::handleEvent(const Event& currentEvent)
{
    if (currentEvent.getType() == ACTION_GAME_EVENT)
    {
        const ActionEvent& actionEvent = static_cast<const ActionEvent&>(currentEvent);

        if (actionEvent.getAction() == CHANGE_EASY)
        {
            mDifficulty = Difficulty::EASY;
        }
        else if (actionEvent.getAction() == CHANGE_MEDIUM)
        {
            mDifficulty = Difficulty::MEDIUM;
        }
        else if (actionEvent.getAction() == CHANGE_HARD)
        {
            mDifficulty = Difficulty::HARD;
        }
    }
}


Level* LevelManager::loadLevel(string path, GraphicsBuffer* wallBuffer, Vector2D wallSections)
{
    ifstream fin;

    Level* newLevel = new Level();

    fin.open(path);

    if (!fin.fail() && fin)
    {
        string tagFin, tempFin;
        
        while (fin)
        {
            fin >> tagFin;

           /* if (tagFin == SNAKE_SPEED_TAG)
            {
                fin >> tempFin;
                newLevel->setSnakeSpeed(stof(tempFin));
            }


            if (tagFin == START_SEGMENTS_TAG)
            {
                fin >> tempFin;
                newLevel->setStartSegmentNum(stoi(tempFin));
            }

            if (tagFin == END_SEGMENTS_TAG)
            {
                fin >> tempFin;
                newLevel->setEndSegmentNum(stoi(tempFin));
            }

            if (tagFin == FOOD_POINTS_TAG)
            {
                fin >> tempFin;
                newLevel->setFoodPoints(stoi(tempFin));
            }

            if (tagFin == POWER_UP_BASE_FREQUENCY_TAG)
            {
                fin >> tempFin;
                newLevel->setPowerUpBaseFrequency(stof(tempFin));
            }

            if (tagFin == POWER_UP_RANDOM_RANGE_TAG)
            {
                fin >> tempFin;
                newLevel->setPowerUpRandomRange(stof(tempFin));
            }

            if (tagFin == BONUS_CHANCE_TAG)
            {
                fin >> tempFin;
                newLevel->setBonusChance(stof(tempFin));
            }

            if (tagFin == FAST_CHANCE_TAG)
            {
                fin >> tempFin;
                newLevel->setFastChance(stof(tempFin));
            }

            if (tagFin == SLOW_CHANCE_TAG)
            {
                fin >> tempFin;
                newLevel->setSlowChance(stof(tempFin));
            }*/

            if (tagFin == PLAYER_SPEED_TAG)
            {
                fin >> tempFin;
                newLevel->setPlayerSpeed(stof(tempFin));
            }
            
            if (tagFin == POINT_VALUE_TAG)
            {
                fin >> tempFin;
                newLevel->setCollectibleWorth(stoi(tempFin));
            }

            //READ IN EASY LEVEL
            /*if (tagFin == EASY_DIFF_TAG)
            {
                fin >> tempFin;
                newLevel->setDiffs(tempFin);
            }*/
            if (tagFin == EASY_TIME_TAG)
            {
                fin >> tempFin;
                newLevel->setTimeLimitEasy(stof(tempFin));
            }
            if (tagFin == EASY_FREQ_TAG)
            {
                fin >> tempFin;
                newLevel->setArrowFreqEasy(stof(tempFin));
            }
            
            //READ IN NORMAL LEVEL
            /*if (tagFin == NORMAL_DIFF_TAG)
            {
                fin >> tempFin;
                newLevel->setDiffs(tempFin);
            }*/
            if (tagFin == NORMAL_TIME_TAG)
            {
                fin >> tempFin;
                newLevel->setTimeLimitNormal(stof(tempFin));
            }
            if (tagFin == NORMAL_FREQ_TAG)
            {
                fin >> tempFin;
                newLevel->setArrowFreqNormal(stof(tempFin));
            }
            
            //READ IN HARD LEVEL
            /*if (tagFin == HARD_DIFF_TAG)
            {
                fin >> tempFin;
                newLevel->setDiffs(tempFin);
            }*/
            if (tagFin == HARD_TIME_TAG)
            {
                fin >> tempFin;
                newLevel->setTimeLimitHard(stof(tempFin));
            }
            if (tagFin == HARD_FREQ_TAG)
            {
                fin >> tempFin;
                newLevel->setArrowFreqHard(stof(tempFin));
            }


            if (tagFin == LEVEL_LOCATIONS_TAG)
            {
                getline(fin, tempFin); //move to next line
                getline(fin, tempFin); //get first line of level info

                int yIndex = 0;

                //while empty line after level is not found
                while (tempFin != "")
                {
                    //skip spaces and read every other character
                    for (unsigned int stringIndex = 0; stringIndex < tempFin.length(); stringIndex += 2)
                    {
                        //add new wall if character is 1, ignore if 0
                        if (tempFin[stringIndex] == '1')
                        {
                            int xIndex = stringIndex / 2; //actual index in wall grid
                            Vector2D newPos = Vector2D((float)(xIndex + .5) * wallBuffer->getWidth(), (float)(yIndex + .5) * wallBuffer->getHeight());
                            newLevel->addWallPosition(newPos);
                        }
                        else if (tempFin[stringIndex ] == '2')
                        {
                            int xIndex = stringIndex / 2; 
                            Vector2D newPos = Vector2D((float)(xIndex + .5) * wallBuffer->getWidth(), (float)(yIndex + .5) * wallBuffer->getHeight());
                            newLevel->setDoorPos(newPos);
                        }
                        else if (tempFin[stringIndex ] == '3')
                        {
                            int xIndex = stringIndex / 2;
                            Vector2D newPos = Vector2D((float)(xIndex + .5) * wallBuffer->getWidth(), (float)(yIndex + .5) * wallBuffer->getHeight());
                            newLevel->addSpikePosition(newPos);
                        }
                        else if (tempFin[stringIndex ] == '4')
                        {
                            int xIndex = stringIndex / 2; 
                            Vector2D newPos = Vector2D((float)(xIndex + .5) * wallBuffer->getWidth(), (float)(yIndex + .5) * wallBuffer->getHeight());
                            newLevel->addArrowPosition(newPos);
                        } 
                        else if (tempFin[stringIndex ] == '5')
                        {
                            int xIndex = stringIndex / 2; 
                            Vector2D newPos = Vector2D((float)(xIndex + .5) * wallBuffer->getWidth(), (float)(yIndex + .5) * wallBuffer->getHeight());
                            newLevel->addCollectiblePosition(newPos);
                        }
                        else if (tempFin[stringIndex] == '6')
                        {
                            int xIndex = stringIndex / 2; 
                            Vector2D newPos = Vector2D((float)(xIndex + .5) * wallBuffer->getWidth(), (float)(yIndex + .5) * wallBuffer->getHeight());
                            newLevel->setSpawnPos(newPos);
                        }
                    }

                    getline(fin, tempFin);
                    yIndex++;
                }
            }
        }
        

        fin.close();

        mLevels.push_back(newLevel);

        return newLevel;
    }
    else
    {
        return nullptr;
    }
}


bool LevelManager::loadSave(string filePath, float& timeRemaining, int& points)
{
    bool success = true;
    ifstream fin;

    fin.open(filePath);

    if (!fin.fail())
    {
        string tempFin = "";

        fin >> tempFin;

        while (fin)
        {
            if (tempFin == SAVE_POSITION_TAG)
            {
                fin >> tempFin;

                tempFin = tempFin.substr(1, tempFin.size() - 2); //remove parenthesis at beginning and end

                int index = tempFin.find_first_of(','); //index of comma

                float xPos = stof(tempFin.substr(0, index));
                float yPos = stof(tempFin.substr(index + 1, tempFin.size() - index));

                mSavedPosition = Vector2D(xPos, yPos);
            }

            if (tempFin == SAVE_LEVEL_TAG)
            {
                fin >> tempFin;

                mCurrentLevel = stoi(tempFin);
            }

            if (tempFin == SAVE_TIME_TAG)
            {
                fin >> tempFin;

                timeRemaining = stof(tempFin);
            }

            if (tempFin == SAVE_POINTS_TAG)
            {
                fin >> tempFin;

                points = stoi(tempFin);
            }

            if (tempFin == SAVE_DIFFICULTY_TAG)
            {
                fin >> tempFin;

                mDifficulty = (Difficulty)stoi(tempFin);
            }

            if (tempFin == SAVE_COLLECTIBLE_TAG)
            {
                fin >> tempFin;

                while (tempFin != "" && fin)
                {
                    //cut ordered pair into x and y components
                    int commaIndex = tempFin.find_first_of(",");
                    float xPos = stof(tempFin.substr(1, commaIndex));
                    float yPos = stof(tempFin.substr(commaIndex + 1, tempFin.find_first_of(")") - commaIndex));

                    mSavedCollectibles.push_back(Vector2D(xPos, yPos)); //add collectible positions from file to level manager

                    fin >> tempFin;
                }
            }

            fin >> tempFin;
        }
    }
    else
    {
        cout << endl << "ERROR LOADING SAVE" << endl << endl;
        success = false;
    }

    fin.close();

    return success;
}


void LevelManager::saveLevel(string filePath, UnitManager* pUnitManager, Vector2D playerPos, int timeRemaining, int points)
{
    ofstream fout;

    fout.open(filePath);

    if (!fout.fail())
    {
        fout << SAVE_POSITION_TAG << " " << playerPos << endl;
        fout << SAVE_LEVEL_TAG << " " << mCurrentLevel << endl;
        fout << SAVE_TIME_TAG << " " << timeRemaining << endl;
        fout << SAVE_POINTS_TAG << " " << points << endl;
        fout << SAVE_DIFFICULTY_TAG << " " << mDifficulty << endl;
        fout << SAVE_COLLECTIBLE_TAG << endl;

        //save collectibles in scene
        vector<Unit*> typeUnits = pUnitManager->getUnitsOfType(UnitTypes::COLLECTIBLE_UNIT_TYPE);

        for (unsigned int i = 0; i < typeUnits.size(); i++)
        {
            fout << typeUnits[i]->getPosition() << endl;
        }
    }
    else
    {
        cout << endl << "SAVING ERROR" << endl << endl;
    }

    fout.close();
}


/*void LevelManager::nextLevel()
{
    mCurrentLevel++;
}


void LevelManager::restartLevels()
{
    mCurrentLevel = 0;
}*/


void LevelManager::deleteAllLevels()
{
    for (unsigned int i = 0; i < mLevels.size(); i++)
    {
        delete mLevels[i];
    }

    mLevels.clear();
}


void LevelManager::printLevelInfo(unsigned int index)
{
    cout << endl << "Level " << index << " Info" << endl << endl;

    mLevels[index]->printLevelInfo();

    cout << endl;
}