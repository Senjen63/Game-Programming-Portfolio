#include "GraphicsBufferManager.h"

using namespace std;

GraphicsBufferManager::GraphicsBufferManager()
{

}

void GraphicsBufferManager::cleanup()
{
	vector<BufferKey> keys;
	keys.reserve(mMap.size());

	for (auto i : mMap) //IS THIS OK? STACK OVERFLOW
	{
		keys.push_back(i.first);
	}

	for (size_t i = 0; i < keys.size(); i++)
	{
		delete mMap.at(keys[i]);
	}

	mMap.clear();
}

void GraphicsBufferManager::createBuffer(ALLEGRO_BITMAP* bitmap, const BufferKey& key)
{
	if (mMap.find(key) != mMap.end()) { return; }

	GraphicsBuffer* buffer = new GraphicsBuffer(bitmap);

	mMap.emplace(make_pair(key, buffer));
}

void GraphicsBufferManager::createBuffer(int width, int height, const BufferKey& key)
{
	if (mMap.find(key) != mMap.end()) { return; }

	GraphicsBuffer* buffer = new GraphicsBuffer(width, height);

	mMap.emplace(make_pair(key, buffer));
}

void GraphicsBufferManager::createBuffer(string filename, const BufferKey& key)
{
	if (mMap.find(key) != mMap.end()) { return; }

	GraphicsBuffer* buffer = new GraphicsBuffer(filename);

	mMap.emplace(make_pair(key, buffer));
}

void GraphicsBufferManager::createBuffer(GraphicsBuffer* buffer, const BufferKey& key)
{
	if (mMap.find(key) != mMap.end()) { return; }

	mMap.emplace(make_pair(key, buffer));
}

void GraphicsBufferManager::deleteBuffer(const BufferKey& key)
{
	if (mMap.find(key) != mMap.end()) 
	{
		delete mMap.at(key);
		mMap.erase(key);
	}
}

GraphicsBuffer* GraphicsBufferManager::getBuffer(const BufferKey& key) const 
{
	if (mMap.find(key) != mMap.end()) { return mMap.at(key); }

	return nullptr;
}