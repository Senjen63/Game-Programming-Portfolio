#include "Orbs.h"
#include <EventSystem.h>
#include "GameEvent.h"
#include "CollideEvent.h"
#include "ClickEvent.h"

void Orbs::handleEvent(const Event& theEvent)
{
	if (theEvent.getType() == CLICK_EVENT)
	{
		const ClickEvent& clickEvent = static_cast<const ClickEvent&>(theEvent);

		mpOrbManager->doesCollide(clickEvent.getLocation());
	}
	else if (theEvent.getType() == COLLIDE_EVENT)
	{
		const CollideEvent& collideEvent = static_cast<const CollideEvent&>(theEvent);

		mpOrbManager->deleteUnit(collideEvent.getCollision());
	}
}

void Orbs::increaseDif()
{
	if (orbCount % neededOrbsForSpawnIncrease == 0)
	{
		spawnChance -= spawnIncreaseAmount;

		if (spawnChance <= 0)
		{
			spawnChance = 5;
		}
	}

	if (orbCount % neededOrbsForSpeedIncrease == 0)
	{
		speedMod += speedIncreaseAmount;
	}
}

void Orbs::loadOrbFile(string fileName)
{
	string keyCode;

	//loads buffers
	ifstream fin;
	fin.open(fileName);

	if (!fin.is_open())
	{
		cout << "Failed to Load Orb Data File" << endl;
	}

	while (!fin.eof())
	{
		fin >> keyCode;

		if (keyCode == "spwnRngSz")
		{
			fin >> spawnRangeSize;
		}
		else if (keyCode == "minSpwnX")
		{
			fin >> minSpawnX;
		}
		else if (keyCode == "minSpwnY")
		{
			fin >> minSpawnY;
		}
		else if (keyCode == "numSpwnOrb")
		{
			fin >> neededOrbsForSpawnIncrease;
		}
		else if (keyCode == "numSpdOrb")
		{
			fin >> neededOrbsForSpeedIncrease;
		}
		else if (keyCode == "numSpwnUp")
		{
			fin >> spawnIncreaseAmount;
		}
		else if (keyCode == "numSpdUp")
		{
			fin >> speedIncreaseAmount;
		}
		else if (keyCode == "easyMod")
		{
			fin >> easySpeedMod;
		}
		else if (keyCode == "easyChance")
		{
			fin >> easySpawnChance;
		}
		else if (keyCode == "medMod")
		{
			fin >> medSpeedMod;
		}
		else if (keyCode == "medChance")
		{
			fin >> medSpawnChance;
		}
		else if (keyCode == "hardMod")
		{
			fin >> hardSpeedMod;
		}
		else if (keyCode == "hardChance")
		{
			fin >> hardSpawnChance;
		}
	}

	fin.close();
}

void Orbs::loadOrbsFromSave()
{
	mpOrbManager->cleanUp();
	mpOrbManager->loadUnitData(mpRedAnimation, mpBlueAnimation);
}

void Orbs::loadOrbStateFromSave()
{
	string keyCode;

	ifstream fin;
	fin.open("orbStateData.txt");

	if (!fin.is_open())
	{
		cout << "Failed to Load Orb Data File" << endl;
	}

	while (!fin.eof())
	{
		fin >> keyCode;

		if (keyCode == "orbCnt")
		{
			fin >> orbCount;
		}
		else if (keyCode == "rndCnt")
		{
			fin >> randCount;
		}
		else if (keyCode == "spdMod")
		{
			fin >> speedMod;
		}
		else if (keyCode == "spwnChnc")
		{
			fin >> spawnChance;
		}
	}
	fin.close();

	loadOrbsFromSave();
}

void Orbs::moveOrbs()
{
	mpOrbManager->moveUnits();
}

Orbs::Orbs(UnitManager* manager, Animation* anim1, Animation* anim2)
{
	EventSystem* pEventSystem = EventSystem::getInstance();
	pEventSystem->addListener((EventType)CLICK_EVENT, this);
	pEventSystem->addListener((EventType)COLLIDE_EVENT, this);

	mpOrbManager = manager;
	mpRedAnimation = anim1;
	mpBlueAnimation = anim2;

	currentDifficulty = easy;

	orbCount = 0;
	randCount = 1;
	speedMod = 1.0;

	neededOrbsForSpawnIncrease = 10;
	neededOrbsForSpeedIncrease = 25;
	spawnIncreaseAmount = 5.0;
	speedIncreaseAmount = 0.5;

	spawnChance = 100;
	spawnLoc = Vector2D(400, 300);
	spawnRangeSize = 100;
	minSpawnX = 350;
	minSpawnY = 250;

	loadOrbFile("orbData.txt");
	setDifficulty(currentDifficulty);
}

Orbs::~Orbs()
{
}

void Orbs::resetOrbs()
{
	mpOrbManager->cleanUp();
	loadOrbFile("orbData.txt");
	setDifficulty(currentDifficulty);

	orbCount = 0;
	randCount = 0;
}

void Orbs::saveOrbs()
{
	mpOrbManager->saveUnitData();
}

void Orbs::saveOrbState()
{
	ofstream fout;
	fout.open("orbStateData.txt");

	fout << "orbCnt " << orbCount << endl;
	fout << "rndCnt " << randCount << endl;
	fout << "spdMod " << speedMod << endl;
	fout << "spwnChnc " << spawnChance;

	fout.close();

	saveOrbs();
}

void Orbs::setDifficulty(diffSetting difToSet)
{
	if (difToSet == easy)
	{
		speedMod = easySpeedMod;
		spawnChance = easySpawnChance;
	}
	else if (difToSet == medium)
	{
		speedMod = medSpeedMod;
		spawnChance = medSpawnChance;
	}
	else if (difToSet == hard)
	{
		speedMod = hardSpeedMod;
		spawnChance = hardSpawnChance;
	}
}

void Orbs::spawnOrb()
{
	int choice;

	srand(randCount);

	//Randomly determine if an orb spawns based on the chance of 1 in spawnChance
	choice = rand() % spawnChance + 1;

	if (choice == spawnChance)
	{
		//Randomizes velocity of the orb
		Vector2D velocity;

		float randX = rand() % 3 - 1;
		float randY = rand() % 3 - 1;

		while (randX == 0 && randY == 0)
		{
			randX = rand() % 3 - 1;
			randY = rand() % 3 - 1;
		}

		//Randomizes the spawning location in the 100x100 center of the screen
		spawnLoc.setX(rand() % spawnRangeSize + minSpawnX);
		spawnLoc.setY(rand() % spawnRangeSize + minSpawnY);

		velocity.setX(randX * speedMod);
		velocity.setY(randY * speedMod);

		//Spawns that orb with the randomized velocity at the randomized location
		mpOrbManager->addUnit(mpRedAnimation, mpBlueAnimation, spawnLoc, "Orb", velocity);
		orbCount++;

		//Checks to see if it needs to increase the spawn chance or speed modifier
		increaseDif();
	}

	randCount++;
}