#include "Game.h"
#include <PerformanceTracker.h>
#include <Timer.h>
#include <fstream>
#include <assert.h>

#include "InputEvent.h"
#include "ReleaseEvent.h"
#include "Animation.h"

using namespace std;

Game* Game::mpsInstance = nullptr;

Game::Game()
{
	this->mpGraphics = nullptr;
	this->mpLevels = nullptr;
	this->mpInputs = nullptr;
	this->mpAssets = nullptr;
	this->mpTranslator = nullptr;
	this->mpFont = nullptr;
	this->mpPlayer = nullptr;
	this->mpMainMenu = nullptr;
	this->mpOptionsMenu = nullptr;
	this->mpGameUI = nullptr;

	mGameState = "menu";
	toQuit = false;
	mSpacePressed = false;
	mShiftPressed = false;

	mpEvents = EventSystem::getInstance();
	mpEvents->addListener((EventType)INPUT_EVENT, this);
	mpEvents->addListener((EventType)DIE_EVENT, this);
	mpEvents->addListener((EventType)VICTORY_EVENT, this);

	//default settings
	mSound = true;
	mMusic = true;
	mLanguage = ENGLISH;
	mDifficulty = NORMAL;

	mpMusic = new Music(ASSET_PATH + "Music.wav", mMusic);
}

Game::~Game()
{
	cleanup();

	delete mpLevels;
	delete mpGraphics;
	delete mpInputs;
	delete mpTranslator;
	delete mpFont;
	delete mpPlayer;
	delete mpGameUI;
	delete mpMainMenu;
	delete mpOptionsMenu;

	delete mpMusic;
	delete mpAssets;
}

void Game::init()
{
	mpGraphics = new GraphicsSystem(DISP_WIDTH, DISP_HEIGHT, "Dean in a Dungeon");
	mpInputs = new InputSystem();
	mpLevels = new LevelManager(3);
	mpAssets = new AssetManager();
	mpTranslator = new InputTranslator();
	mpPlayer = new Player(ASSET_PATH + "player_stats.txt");

	loadAssets();

	mpGameUI = new UI(mpAssets->getTexture("heart"));

	//load settings from file

	ifstream input(ASSET_PATH + SETTINGS_PATH);

	if (input.good())
	{
		string key;

		while (!input.eof())
		{
			input >> key;

			if (key == "sound:")
			{
				input >> mSound;
			}
			else if (key == "music:")
			{
				input >> mMusic;
			}
			else if (key == "difficulty:")
			{
				int i;
				input >> i;
				mDifficulty = Difficulty(i);
			}
			else if (key == "language:")
			{
				int i;
				input >> i;
				mLanguage = Language(i);
			}
		}
	}

	mpMainMenu = new Menu(MAIN);
	mpOptionsMenu = new Menu(OPTIONS);
}

void Game::createGame()
{
	if (mpsInstance == nullptr)
	{
		mpsInstance = new Game();
	}
}

void Game::deleteGame()
{
	delete mpsInstance;
	mpsInstance = nullptr;
}

Game* Game::getInstance()
{
	assert(mpsInstance != nullptr);

	return mpsInstance;
}

void Game::cleanup()
{
	mpEvents->cleanup();
}

void Game::doLoop() 
{
	const Color RED = Color(255, 0, 0);
	const Color BLACK = Color(0, 0, 0);
	
	// GAME LOOP SETUP STARTS HERE
	bool looping = true;

	PerformanceTracker* pPerformanceTracker = new PerformanceTracker;

	bool keepRunning = true;
	Timer timer;

	// begin the game
	mpLevels->init();

	while (looping)
	{
		if (toQuit) 
		{
			mpMusic->stop();
			saveSettings();
			looping = false;
		}

		pPerformanceTracker->clearTracker("loop");
		pPerformanceTracker->startTracking("loop");

		Timer loopTimer;
		loopTimer.start();

		//USER INPUT IS TAKEN IN THE EVENT SYSTEM

		//#1 - adjust game state
		mpPlayer->update();
		mpInputs->update();

		if (mGameState == "playing") { mpLevels->update(mFPS); }

		//#2 - draw current game state
		mpGraphics->clear();

		mpGraphics->draw(mpAssets->getSprite("background"));

		if (mGameState == "playing")
		{
			mpLevels->draw();
			mpPlayer->drawPlayer();
			mpGameUI->draw();
		}
		else if (mGameState == "options")
		{
			for (int i = 0; i < 4; i++) { mpOptionsMenu->draw(); }
		}
		else
		{
			for (int i = 0; i < 4; i++) { mpMainMenu->draw(); }
		}

		mpGraphics->display();

		//#3 - wait until target time has elapsed
		loopTimer.sleepUntilElapsed(GAME_FPS);
		pPerformanceTracker->stopTracking("loop");
		cout << "Frame Took:" << pPerformanceTracker->getElapsedTime("loop") << " ms" << endl;
	}

	delete pPerformanceTracker;
}

void Game::saveSettings()
{
	//save settings

	ofstream settingsFile;

	settingsFile.open(ASSET_PATH + SETTINGS_PATH);
	assert(settingsFile.is_open());

	settingsFile.clear();

	//save settings data
	settingsFile << "sound: " << mSound << endl;
	settingsFile << "music: " << mSound << endl;
	settingsFile << "difficulty: " << mDifficulty << endl;
	settingsFile << "language: " << mLanguage << endl;

	settingsFile.close();
}

void Game::saveGame()
{
	ofstream saveFile;

	saveFile.open(ASSET_PATH + SAVEFILE_PATH);
	assert(saveFile.is_open());

	saveFile.clear();

	//save level data
	saveFile << "[SAVE]\n";
	saveFile << mpLevels->getLevelNum() << endl;
	saveFile << mpPlayer->getX() << " " << mpPlayer->getY() << endl;
	saveFile << mpPlayer->getHP() << endl;

	//get current enemies
	saveFile << "[ENEMIES]\n";
	saveFile << mpLevels->getNumEnemies() << endl;

	for (int i = 0; i < mpLevels->getNumEnemies(); i++)
	{
		saveFile << mpLevels->getEnemy(i)->getType() << endl;
		saveFile << mpLevels->getEnemy(i)->getX() << " " << mpLevels->getEnemy(i)->getY() << endl;
		saveFile << mpLevels->getEnemy(i)->getDirection() << endl;
		saveFile << mpLevels->getEnemy(i)->getHP() << endl;
	}

	saveFile << "[EOF]";
	saveFile.close();
}

bool Game::loadGame()
{
	ifstream saveFile;
	string currentVar;

	saveFile.open(ASSET_PATH + SAVEFILE_PATH);
	assert(saveFile.is_open());

	saveFile >> currentVar;
	if (currentVar != "[SAVE]") { return false; }

	int currentLine = 0;

	while (!saveFile.eof() && currentVar != "[ENEMIES]") // set current level, player stats
	{
		saveFile >> currentVar;

		switch (currentLine)
		{
		case 0:
			mpLevels->setLevelNum(stoi(currentVar));
			mGameState = "playing";
			mpLevels->loadLevel(false);
			break;

		case 1:
			mpPlayer->setX(stof(currentVar));
			break;

		case 2:
			mpPlayer->setY(stof(currentVar));
			break;

		case 3:
			mpPlayer->setHP(stoi(currentVar));
			break;
		}

		currentLine++;
	}
	
	int numOfEnemies;
	saveFile >> numOfEnemies;

	string enemyType;
	int enemyHP;
	int enemyX;
	int enemyY;
	int enemyDirection;

	while (!saveFile.eof() && numOfEnemies > 0) // building level enemies based on game state
	{
		saveFile >> enemyType;
		saveFile >> enemyX;
		saveFile >> enemyY;
		saveFile >> enemyDirection;
		saveFile >> enemyHP;

		EnemyBase* newEnemy;

		if (enemyType == "Penguin") { newEnemy = new Penguin(Direction(enemyDirection), Vector2D(enemyX, enemyY), new Animation(mpLevels->ANIMATION_SPEED, mpLevels->mPenguinAnimation)); }
		else if (enemyType == "Chaser") { newEnemy = new Solicitor(Direction(enemyDirection), Vector2D(enemyX, enemyY), new Animation(mpLevels->ANIMATION_SPEED, mpLevels->mSolicitorAnimation), mpPlayer); }
		else if (enemyType == "Puffle") { newEnemy = new Puffle(Direction(enemyDirection), Vector2D(enemyX, enemyY), new Animation(mpLevels->ANIMATION_SPEED, mpLevels->mPuffleAnimation), mpLevels->mBulletAnimation); }
		else { newEnemy = new Bullet(Direction(enemyDirection), Vector2D(enemyX, enemyY), new Animation(mpLevels->ANIMATION_SPEED, mpLevels->mBulletAnimation), 4); } //MAGIC NUMBER HERE

		newEnemy->setHP(enemyHP);
		mpLevels->addEnemy(newEnemy);

		numOfEnemies--;
	}

	return true;
}

void Game::loadAssets()
{
	// create background asset
	mpAssets->createTexture(ASSET_PATH + "spr_bg.png", "background");
	mpAssets->createSprite(mpAssets->getTexture("background"), "background");
	mpAssets->getSprite("background")->setScale(10, 10);


	// create sound assets
	mpAssets->createSound(ASSET_PATH + "Hit.wav", "hit");
	mpAssets->createSound(ASSET_PATH + "Punch.wav", "punch");
	mpAssets->createSound(ASSET_PATH + "Roll.wav", "roll");
	mpAssets->createSound(ASSET_PATH + "DamageEnemy.wav", "damage");
	mpAssets->createSound(ASSET_PATH + "DeathEnemy.wav", "kill");
	mpAssets->createSound(ASSET_PATH + "Win.wav", "win");

	// create level assets
	vector<string> sprites = { "penguin", "chaser", "puffle", "bullet", "wall" };

	for (size_t i = 0; i < sprites.size(); i++)
	{
		mpAssets->createTexture(ASSET_PATH + "spr_" + sprites[i] + ".png", sprites[i]);

		mpAssets->createSprite(mpAssets->getTexture(sprites[i]), sprites[i]);

		mpAssets->createAnimation(sprites[i]);
		mpAssets->getAnimation(sprites[i])->addSprite(mpAssets->getSprite(sprites[i]));

		mpLevels->setAnimation(mpAssets->getAnimation(sprites[i]), sprites[i]);
	}

	mpAssets->createTexture(ASSET_PATH + "spr_heart.png","heart");

	// create player assets
	mpPlayer->loadAssets();
}

void Game::handleEvent(const Event& theEvent)
{
	//inputs
	if (theEvent.getType() == INPUT_EVENT)
	{
		const InputEvent& inputEvent = static_cast<const InputEvent&>(theEvent);

		if (inputEvent.getInput() == QUIT_EVENT)
		{
			if (mGameState == "playing") { saveGame(); }
			toQuit = true;
		}

		else if (inputEvent.isReleasing()) // check if letting go of the key
		{
			switch (inputEvent.getInput())
			{
			case UP_EVENT: { mUpPressed = false; } break;
			case DOWN_EVENT: { mDownPressed = false; } break;
			case SPACEBAR_EVENT: { mSpacePressed = false; } break;
			case SHIFT_EVENT: { mShiftPressed = false; } break;
			}
		}

		else if (mGameState == "playing")
		{
			switch (inputEvent.getInput())
			{
				case LEFT_EVENT:
				{
					mpPlayer->movePlayer(LEFT);

					break;
				}

				case RIGHT_EVENT:
				{
					mpPlayer->movePlayer(RIGHT);

					break;
				}

				case UP_EVENT:
				{
					mpPlayer->movePlayer(UP);

					break;
				}

				case DOWN_EVENT:
				{
					mpPlayer->movePlayer(DOWN);

					break;
				}

				case SPACEBAR_EVENT:
				{
					if (mSpacePressed) { break; }
					mSpacePressed = true;

					if (mpPlayer->canPunch() && mpPlayer->canRoll())
					{
						mpPlayer->punchPlayer();
					}

					break;
				}

				case SHIFT_EVENT:
				{
					if (mpPlayer->canPunch() && mpPlayer->canRoll())
					{
						mpPlayer->rollPlayer();
					}

					break;
				}
			}
		}

		else if (mGameState == "menu" || mGameState == "dead" || mGameState == "victory")
		{
			switch (inputEvent.getInput())
			{
				case UP_EVENT:
				{
					if (mUpPressed) { break; }
					mUpPressed = true;

					mpMainMenu->goUp();
					break;
				}

				case DOWN_EVENT:
				{
					if (mDownPressed) { break; }
					mDownPressed = true;

					mpMainMenu->goDown();
					break;
				}

				case SPACEBAR_EVENT:
				{
					if (mSpacePressed) { break; }
					mSpacePressed = true;

					//main menu effects
					switch (mpMainMenu->getCurrentHighlight())
					{
					case 3: // Start game
						mGameState = "playing";
						if (mMusic) { mpMusic->play(); }
						mpPlayer->resetHP();
						mpLevels->setLevelNum(0);
						mpLevels->loadLevel();

						break;
					case 4: // Load From Save
						mGameState = "playing";
						if (mMusic) { mpMusic->play(); }
						if (!loadGame()) // start a new game if there's no save file
						{
							mpPlayer->resetHP();
							mpLevels->setLevelNum(0);
							mpLevels->loadLevel();
						}
						break;

					case 5: // Options
						mGameState = "options";
						mpOptionsMenu->resetHighlight();

						break;

					case 6: // Quit
						toQuit = true;

						break;
					}

					break;
				}
			}
		}
		
		else if (mGameState == "options")
		{
			switch (inputEvent.getInput())
			{
			case UP_EVENT:
			{
				if (mUpPressed) { break; }
				mUpPressed = true;

				mpOptionsMenu->goUp();
				break;
			}

			case DOWN_EVENT:
			{
				if (mDownPressed) { break; }
				mDownPressed = true;

				mpOptionsMenu->goDown();
				break;
			}

			case SPACEBAR_EVENT:
			{
				if (mSpacePressed) { break; }
				mSpacePressed = true;

				//options menu effects
				switch (mpOptionsMenu->getCurrentHighlight())
				{
					case 3: // Sound
						if (mSound)
						{
							mSound = false;
						}
						else 
						{
							mSound = true;
						}
						break;

					case 4: // Music
						if (mMusic)
						{
							mMusic = false;
						}
						else
						{
							mMusic = true;
						}
						break;

					case 5: // Difficulty
						if (mDifficulty == EASY)
						{
							mDifficulty = NORMAL;
						}
						else if (mDifficulty == NORMAL)
						{
							mDifficulty = HARD;
						}
						else
						{
							mDifficulty = EASY;
						}
						break;

					case 6: // Language
						if (mLanguage == ENGLISH)
						{
							mLanguage = SPANISH;
						}
						else if (mLanguage == SPANISH)
						{
							mLanguage = PIG_LATIN;
						}
						else
						{
							mLanguage = ENGLISH;
						}
						break;
   
					case 7: // Return to menu
						mpMainMenu->resetTexts();
						mpMainMenu->resetHighlight();
						mGameState = "menu";

						break;
					}

				mpOptionsMenu->resetTexts();
				break;
			}
			}
		}
	}

	if (theEvent.getType() == DIE_EVENT)
	{
		mpMusic->stop();
		mGameState = "dead";
		mpPlayer->setHP(-1);

		mpMainMenu->resetTexts(mGameState);
		mpMainMenu->resetHighlight();
	}

	if (theEvent.getType() == VICTORY_EVENT)
	{
		mpMusic->stop();
		mGameState = "victory";
		mpPlayer->setHP(-1);

		mpMainMenu->resetTexts(mGameState);
		mpMainMenu->resetHighlight();
	}
}

void Game::playSound(Sounds toPlay)
{
	if (!mSound || mGameState != "playing") { return; }

	switch (toPlay)
	{
	case (HIT):
		mpAssets->getSound("hit")->play();
		break;

	case (PUNCH):
		mpAssets->getSound("punch")->play();
		break;

	case (ROLL):
		mpAssets->getSound("roll")->play();
		break;

	case (DAMAGE_ENEMY):
		mpAssets->getSound("damage")->play();
		break;

	case (KILL_ENEMY):
		mpAssets->getSound("kill")->play();
		break;

	case (WIN):
		mpAssets->getSound("win")->play();
		break;
	}
}