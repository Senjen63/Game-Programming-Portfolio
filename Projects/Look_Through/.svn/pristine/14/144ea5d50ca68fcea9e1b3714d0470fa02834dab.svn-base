#include "include/AssetManager.hpp"

#include <iostream>

#include "GraphicsBuffer.hpp"

AssetManager::AssetManager()
{
    mpBufferManager = new BufferManager;
    mpSoundSystem = new SoundSystem;
}

AssetManager::~AssetManager()
{
    for ( const auto & [ key, sprite ] : mSprites )
    {
        delete sprite;
    }
    mSprites.clear();

    for ( const auto & [ key, font ] : mFonts )
    {
        delete font;
    }
    mFonts.clear();

    delete mpBufferManager;
    mpBufferManager = nullptr;

    delete mpSoundSystem;
    mpSoundSystem = nullptr;
}

void AssetManager::generateAssets( const GraphicsSystem * pGraphicsSystem )
{
    for ( const auto & asset : mAssets )
    {
        switch ( asset->type )
        {
        case Asset::AssetType::Sprite:
            {
                const auto pBuffer = new GraphicsBuffer( asset->path.c_str(), pGraphicsSystem );
                mpBufferManager->addBuffer( asset->name, pBuffer );

                mSprites[ asset->name ] = new Sprite( pBuffer );
                delete asset;
                break;
            }
        case Asset::AssetType::Atlas:
            {
                const auto pBuffer = new GraphicsBuffer( asset->path.c_str(), pGraphicsSystem );
                const auto asNew = reinterpret_cast< AtlasAsset * >(asset);
                int curRow = 0;
                int curCol = 0;
                for ( int i = 0; i < asNew->atlasData.totalSprites; ++i )
                {
                    mSprites[ asNew->atlasData.spriteNames[ i ] ] = new Sprite( pBuffer, new Rect2D( curCol * asNew->atlasData.pixelStride, curRow * asNew->atlasData.pixelStride, asNew->atlasData.pixelStride, asNew->atlasData.pixelStride ) );
                    ++curCol;
                    if ( curCol >= asNew->atlasData.spritesPerRow )
                    {
                        curCol = 0;
                        ++curRow;
                    }
                }

                mpBufferManager->addBuffer( asNew->name, pBuffer );

                delete asNew;
                break;
            }
        case Asset::AssetType::Font:
            {
                const auto asNew = reinterpret_cast< FontAsset * >(asset);
                mFonts[ asset->name ] = pGraphicsSystem->createFont( asset->path.c_str(), asNew->fontData.size, asNew->fontData.color, asNew->fontData.style );
                delete asNew;
                break;
            }
        case Asset::AssetType::Sound:
            {
                const auto asNew = asset;
                mpSoundSystem->addSound( asNew->path, asNew->name );
                delete asNew;
                break;
            }
        }
    }
    mAssets.clear();
}

Font * AssetManager::getFont( const std::string & name )
{
    return mFonts[ name ];
}

Sprite * AssetManager::getSprite( const std::string & name )
{
    // im not gonna worry ab error checking this rn
    // too much to do and i am the only one using this atm
    return mSprites[ name ];
}

void AssetManager::importAsset( Asset * asset )
{
    mAssets.push_back( asset );
}

void AssetManager::playSound( const std::string & name ) const
{
    mpSoundSystem->playSound( name );
}
