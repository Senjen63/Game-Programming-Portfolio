#include "Game.h"

Game* Game::mspGame = nullptr;

Game::Game()
{
    mWidthHeight = Vector2D(DEFAULT_WIDTH, DEFAULT_HEIGHT);

    mBodyFilename = "nullBody";
    mHeadFilename = "nullHead";
    mFoodFilename = "nullFood";
    mSpeedUpFilename = "nullSpeedUp";
    mSlowDownFilename = "nullSlowDown";
    mBonusPointsFilename = "nullBonusPoints";
    mWallFilename = "nullWall";
    mBackgroundFilename = "nullBackground";

    mFontFilename = "nullFont";
}


Game::Game(Vector2D widthHeight)
{
    mWidthHeight = widthHeight;

    mBodyFilename = "nullBody";
    mHeadFilename = "nullHead";
    mFoodFilename = "nullFood";
    mSpeedUpFilename = "nullSpeedUp";
    mSlowDownFilename = "nullSlowDown";
    mBonusPointsFilename = "nullBonusPoints";
    mWallFilename = "nullWall";
    mBackgroundFilename = "nullBackground";

    mFontFilename = "nullFont";
}


Game::~Game()
{
    cleanup();
}


void Game::createGame()
{
    if (!mspGame)
    {
        mspGame = new Game();
    }
}


void Game::createGame(Vector2D widthHeight)
{
    if (!mspGame)
    {
        mspGame = new Game(widthHeight);
    }
}


void Game::destroyGame()
{
    delete mspGame;
    mspGame = nullptr;
}


Game* Game::getGame()
{
    return mspGame;
}


void Game::init()
{
    if (!mInitialized && mspGame != nullptr)
    {
        mpEventSystem = EventSystem::getInstance();
        mpEventSystem->init();

        mpGraphics = new GraphicsSystem(mWidthHeight.getX(), mWidthHeight.getY());
        mpUnitManager = new UnitManager();
        mpGBManager = new GraphicsBufferManager();
        mpLevelManager = new LevelManager();
        mTranslator = InputTranslator();

        mpGraphics->init();
        mpUnitManager->init();
        mpGBManager->init();
        mpLevelManager->init();
        mInput.init();
        mTranslator.init();

        mpEventSystem->addListener((EventType)MESSAGE_EVENT, this);
        mpEventSystem->addListener((EventType)ACTION_GAME_EVENT, this);
        mpEventSystem->addListener((EventType)SPAWN_WALL_EVENT, this);
        mpEventSystem->addListener((EventType)SPAWN_SNAKE_EVENT, this);
        mpEventSystem->addListener((EventType)SPAWN_FOOD_EVENT, this);
        mpEventSystem->addListener((EventType)SPAWN_ITEM_EVENT, this);
        mpEventSystem->addListener((EventType)COLLISION_EVENT, this);
        mpEventSystem->addListener((EventType)END_LEVEL_EVENT, this);

        loadFilenames();

        mpGBManager->addBuffer(HEAD_TAG, new GraphicsBuffer(ASSET_PATH + mHeadFilename, HEAD_SECTIONS));
        mpGBManager->addBuffer(BODY_TAG, new GraphicsBuffer(ASSET_PATH + mBodyFilename, BODY_SECTIONS));
        mpGBManager->addBuffer(FOOD_TAG, new GraphicsBuffer(ASSET_PATH + mFoodFilename, FOOD_SECTIONS));
        mpGBManager->addBuffer(SPEED_UP_TAG, new GraphicsBuffer(ASSET_PATH + mSpeedUpFilename, SPEED_SECTIONS));
        mpGBManager->addBuffer(SLOW_DOWN_TAG, new GraphicsBuffer(ASSET_PATH + mSlowDownFilename, SLOW_SECTIONS));
        mpGBManager->addBuffer(BONUS_POINTS_TAG, new GraphicsBuffer(ASSET_PATH + mBonusPointsFilename, BONUS_SECTIONS));
        mpGBManager->addBuffer(WALL_TAG, new GraphicsBuffer(ASSET_PATH + mWallFilename, WALL_SECTIONS));

        GraphicsBuffer* background = new GraphicsBuffer(ASSET_PATH + mBackgroundFilename, BACKGROUND_SECTIONS);
        //make background black if no file loaded
        if (background->isBitmapNull())
        {
            delete background;
            background = new GraphicsBuffer(BLACK, mWidthHeight.getX(), mWidthHeight.getY());
        }
        mpGBManager->addBuffer(BACKGROUND_TAG, background);
        

        mpFont = new Font((COMMON_ASSET_PATH + mFontFilename), FONT_SIZE, 1);

        mpLevelManager->loadLevel(ASSET_PATH + LEVEL_ZERO_FILENAME, mpGBManager->getBuffer(WALL_TAG), Vector2D(1, 1));
        mpLevelManager->loadLevel(ASSET_PATH + LEVEL_ONE_FILENAME, mpGBManager->getBuffer(WALL_TAG), Vector2D(1, 1));
        mpLevelManager->loadLevel(ASSET_PATH + LEVEL_TWO_FILENAME, mpGBManager->getBuffer(WALL_TAG), Vector2D(1, 1));
        mpLevelManager->printLevelInfo(0);
        mpLevelManager->printLevelInfo(1);
        mpLevelManager->printLevelInfo(2);

        mpLevelManager->setLevelIndex(0);

        mpSnake = new Snake(Vector2D(mpGraphics->getWidth() / 2, mpGraphics->getHeight() / 2), SNAKE_START_DIRECTION, 
            mpGBManager->getBuffer(HEAD_TAG), mpGBManager->getBuffer(BODY_TAG));
        mpSnake->init();

        mpFood = new Food();
        mpFood->init();

        mPowerUpSpawner.init();

        mpHud = new HUD(mpGraphics->getWidth() / 5, mpGraphics->getHeight() / 20, mpGraphics, mpFont);
        mpHud->init();

        mInitialized = true;
    }
}


void Game::cleanup()
{
    if (mInitialized && !mCleaned)
    {
        delete mpHud;

        delete mpFood;
        delete mpSnake;

        delete mpFont;

        mInput.cleanup();
        delete mpLevelManager;
        delete mpGBManager;
        delete mpUnitManager;
        delete mpGraphics;

        mCleaned = true;
    }
}


GraphicsSystem* Game::getGraphicsSystem()
{
    return mpGraphics;
}


UnitManager* Game::getUnitManager()
{
    return mpUnitManager;
}


float Game::getTimeScale()
{
    return mTimeScale;
}


void Game::loadFilenames()
{
    ifstream fin;

    fin.open(ASSET_PATH + ASSET_NAMES_FILENAME);

    if (!fin.fail() && !fin.eof())
    {
        string tempFin;
        while (!fin.eof())
        {
            fin >> tempFin;

            if (tempFin == HEAD_TAG + ":")
            {
                fin >> mHeadFilename;
            }

            if (tempFin == BODY_TAG + ":")
            {
                fin >> mBodyFilename;
            }

            if (tempFin == FOOD_TAG + ":")
            {
                fin >> mFoodFilename;
            }

            if (tempFin == BONUS_POINTS_TAG + ":")
            {
                fin >> mBonusPointsFilename;
            }

            if (tempFin == SPEED_UP_TAG + ":")
            {
                fin >> mSpeedUpFilename;
            }

            if (tempFin == SLOW_DOWN_TAG + ":")
            {
                fin >> mSlowDownFilename;
            }

            if (tempFin == WALL_TAG + ":")
            {
                fin >> mWallFilename;
            }

            if (tempFin == FONT_TAG + ":")
            {
                fin >> mFontFilename;
            }

            if (tempFin == BACKGROUND_TAG + ":")
            {
                fin >> mBackgroundFilename;
            }
        }
    }

    fin.close();
}


void Game::input()
{
    mInput.fireInputEvents();
}


void Game::handleEvent(const Event& currentEvent)
{
    if (currentEvent.getType() == MESSAGE_EVENT)
    {
        const MessageEvent& messageEvent = static_cast<const MessageEvent&>(currentEvent);
        cout << messageEvent.getMessage() << endl;
    }

    if (currentEvent.getType() == ACTION_GAME_EVENT)
    {
        const ActionEvent& actionEvent = static_cast<const ActionEvent&>(currentEvent);
        cout << "Action: " << actionEvent.getAction() << endl;

        if (actionEvent.getAction() == EXIT_GAME)
        {
            mEndGame = true;
        }

        if (actionEvent.getAction() == START_GAME)
        {
            if (!mPlayLevel)
            {
                if (mNextLevel) //player flagged to move to next level, reached the target segment number
                {
                    mNextLevel = false;
                    loadSelectedLevel(mpLevelManager->getCurrentLevelIndex() + 1, mpGBManager->getBuffer(WALL_TAG)->getSections());
                }
                else //player died
                {
                    loadSelectedLevel(0, mpGBManager->getBuffer(WALL_TAG)->getSections());
                }
                mTotalElapsedTime = 0;
                mPlayLevel = true;
            }
        }

        if (actionEvent.getAction() == MOVE_LEFT)
        {
            mpEventSystem->fireEvent(TurnEvent(LEFT_DIRECTION));
        }

        if (actionEvent.getAction() == MOVE_RIGHT)
        {
            mpEventSystem->fireEvent(TurnEvent(RIGHT_DIRECTION));
        }

        if (actionEvent.getAction() == MOVE_UP)
        {
            mpEventSystem->fireEvent(TurnEvent(UP_DIRECTION));
        }

        if (actionEvent.getAction() == MOVE_DOWN)
        {
            mpEventSystem->fireEvent(TurnEvent(DOWN_DIRECTION));
        }
    }

    if (currentEvent.getType() == SPAWN_WALL_EVENT)
    {
        const SpawnWallEvent& spawnWallEvent = static_cast<const SpawnWallEvent&>(currentEvent);
        mpUnitManager->addUnit(spawnWallEvent.getPos(), spawnWallEvent.getBuffer(), DEFAULT_FPS, DEFAULT_LOOP, WALL_UNIT_TYPE);
    }

    if (currentEvent.getType() == SPAWN_SNAKE_EVENT)
    {
        const SpawnSnakeEvent& spawnSnakeEvent = static_cast<const SpawnSnakeEvent&>(currentEvent);
        mpUnitManager->addUnit(spawnSnakeEvent.getUnit());
    }

    if (currentEvent.getType() == SPAWN_FOOD_EVENT)
    {
        GraphicsBuffer* foodBuffer = mpGBManager->getBuffer(FOOD_TAG);
        Vector2D newPos = findEmptyPosition(foodBuffer->getWidth(), foodBuffer->getHeight());

        Unit* newFood = new Unit(newPos, foodBuffer, FOOD_FRAME_RATE, true, FOOD_UNIT_TYPE);
        mpFood->setCurrentFood(newFood);
        mpUnitManager->addUnit(newFood);
    }

    if (currentEvent.getType() == SPAWN_ITEM_EVENT)
    {
        const SpawnItemEvent& itemEvent = static_cast<const SpawnItemEvent&>(currentEvent);

        if (itemEvent.getItemType() == SPEED_UP_UNIT_TYPE)
        {
            GraphicsBuffer* speedBuffer = mpGBManager->getBuffer(SPEED_UP_TAG);
            Vector2D newPos = findEmptyPosition(speedBuffer->getWidth(), speedBuffer->getHeight());

            mpUnitManager->addUnit(newPos, speedBuffer, POWER_UP_FRAME_RATE, true, SPEED_UP_UNIT_TYPE);
        }
        else if (itemEvent.getItemType() == SLOW_DOWN_UNIT_TYPE)
        {
            GraphicsBuffer* slowBuffer = mpGBManager->getBuffer(SLOW_DOWN_TAG);
            Vector2D newPos = findEmptyPosition(slowBuffer->getWidth(), slowBuffer->getHeight());

            mpUnitManager->addUnit(newPos, slowBuffer, POWER_UP_FRAME_RATE, true, SLOW_DOWN_UNIT_TYPE);
        }
        else if (itemEvent.getItemType() == BONUS_POINTS_UNIT_TYPE)
        {
            GraphicsBuffer* bonusBuffer = mpGBManager->getBuffer(BONUS_POINTS_TAG);
            Vector2D newPos = findEmptyPosition(bonusBuffer->getWidth(), bonusBuffer->getHeight());

            mpUnitManager->addUnit(newPos, bonusBuffer, POWER_UP_FRAME_RATE, true, BONUS_POINTS_UNIT_TYPE);
        }
    }

    if (currentEvent.getType() == COLLISION_EVENT)
    {
        const CollisionEvent& collisionEvent = static_cast<const CollisionEvent&>(currentEvent);

        if (collisionEvent.getCollider()->getType() == FOOD_UNIT_TYPE)
        {
            mpFood->setEaten(true);
            collisionEvent.getCollider()->setDelete(true);
        }

        if (collisionEvent.getCollider()->getType() == SPEED_UP_UNIT_TYPE)
        {
            mpSnake->setSnakeSpeed(mpSnake->getSnakeSpeed() + 1);
            collisionEvent.getCollider()->setDelete(true);
        }

        if (collisionEvent.getCollider()->getType() == SLOW_DOWN_UNIT_TYPE)
        {
            mpSnake->setSnakeSpeed(mpSnake->getSnakeSpeed() - 1);
            collisionEvent.getCollider()->setDelete(true);
        }

        if (collisionEvent.getCollider()->getType() == BONUS_POINTS_UNIT_TYPE)
        {
            collisionEvent.getCollider()->setDelete(true);
        }
    }

    if (currentEvent.getType() == END_LEVEL_EVENT)
    {
        const EndLevelEvent& endEvent = static_cast<const EndLevelEvent&>(currentEvent);

        mPlayLevel = false;
        mNextLevel = endEvent.getNextLevel();
    }
}


void Game::update(float elapsedTime)
{
    mpSnake->updateSnake(elapsedTime * mTimeScale);
    mpUnitManager->updateAll(elapsedTime * mTimeScale);
    mpUnitManager->checkAnyCollisions(mpSnake->getSnakeHead());
    mpFood->updateFood();
    mPowerUpSpawner.updateSpawner(elapsedTime);
}


void Game::render()
{
    mpGraphics->draw(mpGBManager->getBuffer("Background"), 0, 0, 1, 1); //draw background
    mpUnitManager->drawAll();
    mpHud->displayHud();
    mpGraphics->flip();
}


void Game::fireHudEvents(float elapsedTime)
{
    mTotalElapsedTime += elapsedTime / mTimeScale; //convert to seconds
    mpEventSystem->fireEvent(TimeEvent(mTotalElapsedTime));

    mActualFps = mTimeScale / elapsedTime;
    mpEventSystem->fireEvent(FpsEvent(mActualFps));
}


void Game::loadSelectedLevel(int level, Vector2D wallSections)
{
    if (level > mpLevelManager->getLastLevelIndex())
    {
        level = 0;
    }

    mpLevelManager->setLevelIndex(level);
    Level* newLevel = mpLevelManager->getCurrentLevel();

    endLevel();

    for (auto wall : newLevel->getWallPositions())
    {
        mpEventSystem->fireEvent(SpawnWallEvent(wall, mpGBManager->getBuffer("Wall")));
    }

    mpSnake->startNewLevel(newLevel->getSnakeSpeed(), newLevel->getStartSegmentNum(), newLevel->getEndSegmentNum(), newLevel->getFoodPoints());
    mPowerUpSpawner.newLevel(newLevel->getPowerUpBaseFrequency(), newLevel->getPowerUpRandomRange(), 
        newLevel->getFastChance(), newLevel->getSlowChance(), newLevel->getBonusChance());

    mpLevelManager->printLevelInfo(mpLevelManager->getCurrentLevelIndex());

    mPlayLevel = false;
}


void Game::endLevel()
{
    if (mpUnitManager->getUnitCount() != 0)
    {
        mpUnitManager->clearAll();
        mpSnake->clearSnake();
        mpFood->endLevel();
    }
}


void Game::gameLoop()
{
    mEndGame = false;

    PerformanceTracker* pPerformance = new PerformanceTracker;

    while (!mEndGame)
    {
        bool dead = mpSnake->isDead();

        //when first starting the game
        while (!mNextLevel && !dead && !mEndGame && !mPlayLevel)
        {
            input();

            mpGraphics->draw(mpGBManager->getBuffer("Background"), 0, 0, 1, 1); //draw background

            mpGraphics->writeText(mpGraphics->getWidth() / 2, mpGraphics->getHeight() / 2, mpFont, Color(255, 255, 255), "Press Space to Start or Press Escape to Quit");
            mpGraphics->flip();
        }

        //when player wins and must move to next level or quit
        while (mNextLevel && !mEndGame)
        {
            mPlayLevel = false;
            endLevel();

            string message = "";
            input();

            mpGraphics->draw(mpGBManager->getBuffer("Background"), 0, 0, 1, 1); //draw background

            if (mpLevelManager->getCurrentLevelIndex() >= mpLevelManager->getLastLevelIndex())
            {
                mpGraphics->writeText(mpGraphics->getWidth() / 2, mpGraphics->getHeight() / 2 - 30, mpFont, Color(255, 255, 255), "You Win!");
                message = "Press Space to Restart or Press Escape to Quit";
            }
            else
            {
                message = "Press Space to Start Next Level or Press Escape to Quit";
            }

            mpGraphics->writeText(mpGraphics->getWidth() / 2, mpGraphics->getHeight() / 2, mpFont, Color(255, 255, 255), message);
            mpGraphics->flip();
        }

        //when player loses and must restart at first level or quit
        while (dead && !mEndGame)
        {
            mPlayLevel = false;
            endLevel();

            input();

            mpGraphics->draw(mpGBManager->getBuffer("Background"), 0, 0, 1, 1); //draw background

            mpGraphics->writeText(mpGraphics->getWidth() / 2, mpGraphics->getHeight() / 2 - 20, mpFont, Color(255, 255, 255), "Game Over");


            mpGraphics->writeText(mpGraphics->getWidth() / 2, mpGraphics->getHeight() / 2, mpFont, Color(255, 255, 255), "Press Space to Restart or Press Escape to Quit");
            mpGraphics->flip();

            dead = mpSnake->isDead();
        }

        //game loop
        if (!mEndGame && !mNextLevel && !dead && mPlayLevel)
        {
            pPerformance->clearTracker(LOOP_TRACKER_NAME);
            pPerformance->startTracking(LOOP_TRACKER_NAME);

            Timer timer;
            timer.start();

            input();
            update(timer.getElapsedTime());
            render();

            timer.sleepUntilElapsed(mTimePerFrame);

            fireHudEvents(timer.getElapsedTime());

            pPerformance->stopTracking(LOOP_TRACKER_NAME);
            cout << pPerformance->getElapsedTime(LOOP_TRACKER_NAME) << endl;
        }
    }
    
    delete pPerformance;
}


Vector2D Game::findEmptyPosition(float xDiameter, float yDiameter)
{
    bool spaceEmpty = false;

    while (!spaceEmpty)
    {
        float xPos = rand() % mpGraphics->getWidth();
        float yPos = rand() % mpGraphics->getHeight();

        if (mpUnitManager->checkCollisionInArea(Vector2D(xPos, yPos), xDiameter, yDiameter).size() == 0)
        {
            return Vector2D(xPos, yPos);
        }
    }

    return Vector2D(0, 0); //how did you get here?
}