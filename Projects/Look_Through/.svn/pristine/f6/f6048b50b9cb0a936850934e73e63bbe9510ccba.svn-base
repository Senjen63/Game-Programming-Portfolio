#include "SceneManager.h"

#include "Player.h"
#include "RandomlyMovingEnemy.h"
#include "ChasingEnemy.h"

SceneManager::SceneManager()
{

}

SceneManager::~SceneManager()
{
	delete mpWaveManager;
}

void SceneManager::updateAll(float deltaTime)
{
	if (mIsEnabled)
	{
		if (mpWaveManager != nullptr)
		{
			mpWaveManager->update(deltaTime);
		}

		UnitManager::updateAll(deltaTime);
	}
}

void SceneManager::loadScene(std::string sceneDataFilePath)
{
	mIsEnabled = true;

	Game::getGame()->updateGameState(true);

	if (mpWaveManager != nullptr)
	{
		delete mpWaveManager;
	}
	
	std::vector<std::pair<float, float>> emptySpawnLocations;
	mpWaveManager = new WaveManager(emptySpawnLocations);

	std::ifstream sceneData;
	sceneData.open(sceneDataFilePath);

	// This feels a bit unsafe
	if (!sceneData.is_open())
	{
		return;
	}

	mCurrentScene = sceneDataFilePath;

	std::string currentLine;
	std::string trash;

	std::vector<std::pair<float, float>> spawnPositions;

	int currentColumnIndex = 0;
	int currentRowIndex = 0;

	while (!sceneData.eof())
	{
		int currentColumnIndex = 0;
		std::getline(sceneData, currentLine);

		for (int i = 0; i < currentLine.size(); i += 2)
		{
			Unit* newUnit = nullptr;

			if (currentLine[i] == 'X')
			{
				// Swap out 48s for flexible or defined values later. Aim for no magic numbers.
				newUnit = new Unit(std::make_pair((currentColumnIndex * 48) + 24, (currentRowIndex * 48) + 24), std::make_pair(3, 3), "Assets/TempCollisionAnimationData.txt");
			}

			else if (currentLine[i] == 'P')
			{
				newUnit = new Player(std::make_pair((currentColumnIndex * 48) + 24, (currentRowIndex * 48) + 24), std::make_pair(3, 3), 12, "Assets/TestCharAnimationData.txt");
			}

			else if (currentLine[i] == 'S')
			{
				std::pair<float, float> newSpawnPos = std::make_pair((currentColumnIndex * 48) + 24, (currentRowIndex * 48) + 24);
				spawnPositions.push_back(newSpawnPos);
			}

			if (newUnit != nullptr)
			{
				addUnit(newUnit);
			}

			currentColumnIndex++;
		}
		currentRowIndex++;
	}

	mpWaveManager->updateSpawnLocations(spawnPositions);
}

void SceneManager::unloadScene()
{
	removeAllUnits();

	if (mpWaveManager != nullptr)
	{
		delete mpWaveManager;
		mpWaveManager = nullptr;
	}

	Game::getGame()->updateGameState(false);

	mIsEnabled = false;
}

void SceneManager::addEnemy(Enemy* newEnemy)
{
	addUnit(newEnemy);
}

Player* SceneManager::getPlayer()
{
	std::vector<Unit*> unitVector = getUnitVector();
	for (int i = 0; i < unitVector.size(); i++)
	{
		if (dynamic_cast<Player*>(unitVector[i]) != nullptr)
		{
			return dynamic_cast<Player*>(unitVector[i]);
		}
	}
}