#include "SnakeComponent.h"

#include <iostream>


void SnakeComponent::tryChangeDirection(Keycode pressedKey)
{
	assert(mpUnit != nullptr);

	Vector2D ogMoveDir = mCurrentDirection;

	// Change direction code
	if (pressedKey == Keycode::D || pressedKey == Keycode::RIGHT_ARROW)
	{
		mCurrentDirection = Vector2D(1, 0);
	}
	else if (pressedKey == Keycode::A || pressedKey == Keycode::LEFT_ARROW)
	{
		mCurrentDirection = Vector2D(-1, 0);
	}
	else if (pressedKey == Keycode::S || pressedKey == Keycode::DOWN_ARROW)
	{
		mCurrentDirection = Vector2D(0, 1);
	}
	else if (pressedKey == Keycode::W || pressedKey == Keycode::UP_ARROW)
	{
		mCurrentDirection = Vector2D(0, -1);
	}


	if (mCurrentDirection == mPrevDirection * -1.0f)
	{
		mCurrentDirection = ogMoveDir;
	}
}


void SnakeComponent::moveSnake()
{
	mLoaded = true;

	if (mBodyComponents.size() != 0) // Move each body segment where it should be
	{
		auto currentData = mBodyComponents.end();
		currentData--;

		for (int i = mBodyComponents.size() - 1; i > 0; i--)
		{
			auto prevData = currentData;
			currentData--;

			(*prevData)->UpdateData((*currentData)->mpUnit->getPos(), (*currentData)->dir);
		}

		currentData = mBodyComponents.begin();
		(*currentData)->UpdateData(mpUnit->getPos(), mPrevDirection);
	}

	mPrevPosition = mpUnit->getPos();
	mPrevDirection = mCurrentDirection;
	mpUnit->setPos(mpUnit->getPos() + (mCurrentDirection * MOVE_AMOUNT)); // Move head to new position

	Vector2D newPos = mpUnit->getPos();
	Vector2D windowSize = Game::getInstance()->getWindowSize();
	if (newPos.getX() < 0 || newPos.getX() >= windowSize.getX() || newPos.getY() < 0 || newPos.getY() >= windowSize.getY())
	{
		EventSystem::getInstance()->fireEvent(SnakeDiedEvent());
	}
}


SnakeComponent::SnakeComponent(Vector2D startDirection, float moveDelay)
{
	mCurrentDirection = startDirection; 
	mMoveDelay = moveDelay;
}


void SnakeComponent::init()
{
	EventSystem::getInstance()->addListener((EventType)GameEventType::KEYBOARD_JUST_PRESS_EVENT, this);

	CollisionDriver* colDriver = static_cast<CollisionDriver*>(&mpUnit->getComponent(CollisionDriver::COLLISION_DRIVER_COMPONENT_NAME));
	colDriver->addCollisionObserver(this);
}


void SnakeComponent::update(float dt)
{
	mTimePassedSinceLastMove += dt;

	if (mTimePassedSinceLastMove >= mMoveDelay)
	{
		mTimePassedSinceLastMove = 0.0f;
		moveSnake();
	}
}


void SnakeComponent::draw(GraphicsSystem* gSys)
{
	assert(mpUnit != nullptr);
}


void SnakeComponent::handleEvent(const Event& theEvent)
{
	if (theEvent.getType() != (EventType)GameEventType::KEYBOARD_JUST_PRESS_EVENT)
	{
		return;
	}

	const KeyPressEvent& kEvent = static_cast<const KeyPressEvent&>(theEvent);

	tryChangeDirection(kEvent.getKey());
}


void SnakeComponent::spawnNewSegment()
{
	mLoaded = false;

	UnitManager* um = Game::getInstance()->getUnitManager();

	UnitParameters snakeBodyParams;

	Vector2D newPos;
	Vector2D newDir;

	if (mBodyComponents.size() > 0)
	{
		newPos = (*mBodyComponents.back()).getAttachedUnit()->getPos() - ((*mBodyComponents.back()).dir * MOVE_AMOUNT);
 		newDir = (*mBodyComponents.back()).prevDirection;
	}
	else
	{
		newPos = mpUnit->getPos() - (mCurrentDirection * MOVE_AMOUNT);
		newDir = mPrevDirection;
	}

	std::unordered_map<std::string, Animation> newAnim;
	newAnim[mpUnit->getCurrentAnimationName()] = *mpUnit->getCurrentAnimation();

	snakeBodyParams = UnitParameters(newPos, newAnim, mpUnit->getCurrentAnimationName(), CollisionLayer::SNAKE_BODY);

	std::vector<Component*> snakeBodyComponents;
	snakeBodyComponents.push_back(new SnakeBodyComponent(newDir));

	Unit& newBody = um->createUnit(snakeBodyParams, snakeBodyComponents);

	Component* bodyComp = &newBody.getComponent(SnakeBodyComponent::SNAKE_BODY_COMPONENT_NAME);

	mBodyComponents.push_back(static_cast<SnakeBodyComponent*>(bodyComp));
}


std::string SnakeComponent::getIdentifier()
{
	return "SnakeComponent";
}


void SnakeComponent::onCollision(Unit* unit, CollisionLayer layer)
{
	std::cout << "Collision Received" << std::endl;

	switch (layer)
	{
	case(CollisionLayer::SPEED_POWER_UP):
		speedPowerUpCollected(unit);
		break;

	case(CollisionLayer::SCORE_POWER_UP):
		scorePowerUpCollected(unit);
		break;

	case(CollisionLayer::FRUIT):
		fruitCollected(unit);
		break;

	case(CollisionLayer::SNAKE_BODY):
		if (mBodyComponents.front()->dir != Vector2D(0, 0)) // Make sure they don't collide when game just starts
		{
			EventSystem::getInstance()->fireEvent(SnakeDiedEvent());
		}
		break;

	case(CollisionLayer::WALL):
		EventSystem::getInstance()->fireEvent(SnakeDiedEvent());
		break;

	}
}


void SnakeComponent::speedPowerUpCollected(Unit* unit)
{
	SpeedPowerUpComponent* speedPowerUp = static_cast<SpeedPowerUpComponent*>(&unit->getComponent(SpeedPowerUpComponent::SPEED_POWER_UP_COMPONENT_NAME));
	
	float newDelay = mMoveDelay + speedPowerUp->getDelayAdjustment();

	if (newDelay < 0.0f)
	{
		newDelay = 0.0f;
	}

	setMoveDelay(newDelay);

	Game::getInstance()->getUnitManager()->deleteUnit(*unit);
}


void SnakeComponent::scorePowerUpCollected(Unit* unit)
{
	ScoreModPowerUpComponent* powerUp = static_cast<ScoreModPowerUpComponent*>(&unit->getComponent(ScoreModPowerUpComponent::SCORE_MOD_POWER_UP_COMPONENT_NAME));

	Game::getInstance()->getUnitManager()->deleteUnit(*unit);
	EventSystem::getInstance()->fireEvent(ScoreChangeEvent(powerUp->getScoreMod()));
}


void SnakeComponent::fruitCollected(Unit* unit)
{
	spawnNewSegment();
	Game::getInstance()->getUnitManager()->deleteUnit(*unit);
	EventSystem::getInstance()->fireEvent(ScoreChangeEvent());
	EventSystem::getInstance()->fireEvent(FruitCollectedEvent());
}
