#include "SnakeManager.h"

#include "Game.h"
#include "Unit.h"
#include "UnitManager.h"

#include "EventSystem.h"
#include "GameEvent.h"
#include "ObjectCollisionEvent.h"
#include "PlayerActionEvent.h"

SnakeManager::SnakeManager(int length, float speed, Vector2D startPos, int cellSize, int lvlWidth, int lvlHeight)
{
	mpEventSystem = EventSystem::getInstance();
	mpEventSystem->addListener((EventType)GameEventType::PLAYER_ACTION_EVENT, this);

	mpUnitManager = Game::getInstance()->getUnitManager();
	
	mLength = length;
	mSpeed = speed;
	mTimeRemaing = ONE_SECOND_IN_MS / mSpeed;
	mHeadPos = startPos;
	mTailPos = startPos;
	mCellSize = cellSize;
	mLevelHeight = lvlHeight;
	mLevelWidth = lvlWidth;

	mCenterOffset = Vector2D(mCellSize / 2, mCellSize / 2);

	mTopCell = Vector2D(0, -mCellSize);
	mBottomCell = Vector2D(0, mCellSize);
	mLeftCell = Vector2D(-mCellSize, 0);
	mRightCell = Vector2D(mCellSize, 0);
}

SnakeManager::~SnakeManager()
{
	mpEventSystem = nullptr;
	mpUnitManager = nullptr;
}

void SnakeManager::update(double dt)
{
	mTimeRemaing -= dt;

	if (mTimeRemaing <= 0)
	{
		mTimeRemaing = ONE_SECOND_IN_MS / mSpeed;

		checkHeadCollision();
		moveHead();

		mCanTurn = true;

		if (mCurrentLength >= mLength)
		{
			moveTail();
		}
		else
		{
			mCurrentLength++;
		}
	}
}

void SnakeManager::handleEvent(const Event& theEvent)
{
	if (theEvent.getType() == (EventType)GameEventType::PLAYER_ACTION_EVENT)
	{
		const PlayerActionEvent& actionEvent = static_cast<const PlayerActionEvent&>(theEvent);

		if (mCanTurn)
		{
			switch (actionEvent.getAction())
			{
			case PlayerAction::MOVE_UP:
				if (mDirection != Direction::DOWN)
				{
					mDirection = Direction::UP;
					mCanTurn = false;
				}
				break;
			case PlayerAction::MOVE_DOWN:
				if (mDirection != Direction::UP)
				{
					mDirection = Direction::DOWN;
					mCanTurn = false;
				}
				break;
			case PlayerAction::MOVE_LEFT:
				if (mDirection != Direction::RIGHT)
				{
					mDirection = Direction::LEFT;
					mCanTurn = false;
				}
				break;
			case PlayerAction::MOVE_RIGHT:
				if (mDirection != Direction::LEFT)
				{
					mDirection = Direction::RIGHT;
					mCanTurn = false;
				}
				break;
			default:
				break;
			}
		}		
	}	
}

int SnakeManager::getLength()
{
	return mCurrentLength;
}

void SnakeManager::changeSpeed(float change)
{
	mSpeed += change;

	if (mSpeed < MIN_SPEED)
	{
		mSpeed = MIN_SPEED;
	}
}

void SnakeManager::growSnake(int amount)
{
	mLength += amount;
}

void SnakeManager::checkHeadCollision()
{
	Unit* theUnit = nullptr;

	Vector2D posToCheck = mHeadPos + mCenterOffset;

	switch (mDirection)
	{
	case Direction::UP:

		posToCheck += mTopCell;
		
		break;
	case Direction::DOWN:

		posToCheck += mBottomCell;
		
		break;
	case Direction::LEFT:

		posToCheck += mLeftCell;		

		break;
	case Direction::RIGHT:

		posToCheck += mRightCell;		

		break;
	default:
		break;
	}	

	theUnit = mpUnitManager->getUnitAt(posToCheck);

	if (theUnit != nullptr)
	{
		mpEventSystem->fireEvent(ObjectCollisionEvent(theUnit->getType(), posToCheck));
	}
}

void SnakeManager::moveHead()
{
	Vector2D newPos = mHeadPos;

	switch (mDirection)
	{
	case Direction::UP:

		newPos += mTopCell;

		break;
	case Direction::DOWN:

		newPos += mBottomCell;

		break;
	case Direction::LEFT:

		newPos += mLeftCell;

		break;
	case Direction::RIGHT:

		newPos += mRightCell;

		break;
	default:
		break;
	}

	if (newPos.getX() < 0)
	{
		newPos.setX(float(mLevelWidth * mCellSize));
	}
	else if (newPos.getY() < 0)
	{
		newPos.setY(float(mLevelHeight * mCellSize));
	}
	else if (newPos.getX() > mLevelWidth * mCellSize)
	{
		newPos.setX(0);
	}
	else if (newPos.getY() > mLevelHeight * mCellSize)
	{
		newPos.setY(0);
	}

	mSnakeBody.push(newPos);

	mpUnitManager->addUnitAt(newPos, UnitType::SNAKE);
	mHeadPos = newPos;
}

void SnakeManager::moveTail()
{
	Vector2D newPos = mSnakeBody.front();
	mSnakeBody.pop();

	if (newPos != mTailPos)
	{
		mpUnitManager->deleteAllUnitsAt(mTailPos + mCenterOffset);

		mTailPos = newPos;
	}	
}
