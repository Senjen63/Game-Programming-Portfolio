#include "Game.h"
#include <assert.h>

Game* Game::mpGameInstance = nullptr;

void Game::addScore(int value)
{
	mScore += value;
}

void Game::checkIfLost()
{
	if (mScore <= 0)
	{
		shouldLoop = true;
	}
}

void Game::cleanUp()
{
	if (isInit)
	{
		delete pCollideListener;
		delete pSoundSystem;

		mpDisplay->cleanUp();

		mpBufferManager->clear();
		mpOrbUnitManager->cleanUp();
		delete mpOrbUnitManager;
		delete mpBufferManager;

		mpRedOrbAnimation->cleanUp();
		mpBlueOrbAnimation->cleanUp();
		delete mpRedOrbAnimation;
		delete mpBlueOrbAnimation;

		delete mpOrbTemplate;

		delete mpOrbs;
		delete mpHud;
		delete mpDisplay;

		EventSystem::cleanupInstance();
	}
}

void Game::createInstance()
{
	if (mpGameInstance == nullptr)
	{
		mpGameInstance = new Game;
	}
}

void Game::destroyInstance()
{
	delete mpGameInstance;
	mpGameInstance = nullptr;
}

void Game::displaySettings()
{
	while (true)
	{
		mInput.runQueue();

		mpDisplay->drawCurrent(Vector2D(), Sprite(mpBufferManager->getBuffer("back")), 1.0);
		mpHud->drawOptions(mpDisplay, currentDifficulty, currentLanguage, currentOption, currentSound);

		mpDisplay->flipDisplay();

		if (mInput.getKeyState(BACKSPACE_KEY))
		{
			break;
		}
	}
}

void Game::displayStart()
{
	while (!shouldStart)
	{
		mpDisplay->drawCurrent(Vector2D(), Sprite(mpBufferManager->getBuffer("back")), 1.0);
		mpHud->drawStart(mpDisplay, currentLanguage);

		mpDisplay->flipDisplay();

		mInput.runQueue();

		if (mInput.getKeyState(ESCAPE_KEY))
		{
			shouldStart = true;
			shouldLoop = true;
		}
		else if (mInput.getKeyState(O_KEY))
		{
			displaySettings();
		}
		else if (mInput.getKeyState(ENTER_KEY))
		{
			loadGameState();
			shouldStart = true;
		}
	}
}

void Game::doLoop()
{
	displayStart();

	double targetTime = 16.7;
	float timeMod = 1.0;

	PerformanceTracker* pPerformanceTracker = new PerformanceTracker;

	Vector2D mousePos = Vector2D(450, 270);

	levelTimer.start();

	while (!shouldLoop)
	{
		mFrameCount++;

		//Set up timers and trackers
		pPerformanceTracker->clearTracker("loop");
		pPerformanceTracker->startTracking("loop");
		Timer loopTimer;
		loopTimer.start();

		render();

		inputs(mousePos);

		update(targetTime);

		//Use and diplay timers and trackers
		loopTimer.sleepUntilElapsed(targetTime);
		pPerformanceTracker->stopTracking("loop");

		elapsedTime = loopTimer.getElapsedTime();

		//cout << "Frame Took:" << pPerformanceTracker->getElapsedTime("loop") << " ms" << endl;

		checkIfLost();
	}

	//Saves game state
	saveGameState();

	levelTimer.stop();
	endGame();

	delete pPerformanceTracker;
}

void Game::endGame()
{
	mpDisplay->drawCurrent(Vector2D(), Sprite(mpBufferManager->getBuffer("back")), 1.0);
	mpHud->drawTimer(mpDisplay, levelTimer.getElapsedTime(), savedTime, currentLanguage);
	mpHud->drawEnd(mpDisplay, currentLanguage);
	mpDisplay->flipDisplay();

	while (true)
	{
		shouldEndGame = mInput.getKeyState(ESCAPE_KEY);
		shouldPlayAgain = mInput.getKeyState(SPACE_KEY);

		if (shouldEndGame)
		{
			break;
		}
		else if (shouldPlayAgain)
		{
			resetGame();
			doLoop();
			break;
		}
	}
}

void Game::Init()
{
	readFiles();

	mpDisplay->init();

	mpBufferManager = new GraphicsBufferManager;
	mpOrbUnitManager = new UnitManager;

	mpBufferManager->addBuffer("back", ASSET_PATH + backgroundFileName);
	mpBufferManager->addBuffer("red", ASSET_PATH + redOrbFileName);
	mpBufferManager->addBuffer("blue", ASSET_PATH + blueOrbFileName);

	mpOrbTemplate = new AnimationManager();
	mpRedOrbAnimation = new Animation(mpOrbTemplate, mpBufferManager->getBuffer("red"));
	mpBlueOrbAnimation = new Animation(mpOrbTemplate, mpBufferManager->getBuffer("blue"));

	mpOrbs = new Orbs(mpOrbUnitManager, mpRedOrbAnimation, mpBlueOrbAnimation);
	mpHud = new HudManager();

	pEventSystem = EventSystem::getInstance();

	pCollideListener = new CollideListener;
	pSoundSystem = new SoundSystem(mpOrbUnitManager);

	isInit = true;
}

Game::Game()
{
	mpDisplay = new GraphicsSystem(DISP_HEIGHT, DISP_WIDTH);

	mpOrbUnitManager = nullptr;

	mpBufferManager = nullptr;

	mpOrbs = nullptr;
	mpHud = nullptr;

	mpOrbTemplate = nullptr;
	mpRedOrbAnimation = nullptr;
	mpBlueOrbAnimation = nullptr;

	isInit = false;
	shouldLoop = false;
	shouldStart = false;
	shouldEndGame = false;
	shouldPlayAgain = false;

	mFrameCount = 0;
	mScore = 10;

	pEventSystem = nullptr;
	pCollideListener = nullptr;
	pSoundSystem = nullptr;

	currentDifficulty = easy;
	currentLanguage = English;
	currentSound = 1;
	currentOption = 1;

	elapsedTime = 0.0;
	savedTime = 0.0;

	mInput.Init();
}

Game::~Game()
{
	cleanUp();
}

int Game::getCurrentOption()
{
	return currentOption;
}

int Game::getDifficulty()
{
	return currentDifficulty;
}

Game* Game::getInstance()
{
	assert(mpGameInstance != nullptr);
	return mpGameInstance;
}

int Game::getLanguage()
{
	return currentLanguage;
}

void Game::inputs(Vector2D pos)
{
	//Updates the event queue
	mInput.runQueue();

	shouldLoop = mInput.getKeyState(ESCAPE_KEY);

	Unit* checkCollide = mpOrbUnitManager->doesLeaveScreen();
	if (checkCollide != nullptr)
	{
		pEventSystem->fireEvent(CollideEvent(checkCollide, checkCollide->getCurrentAnimation()));
	}

	if (!shouldStart)
	{
		levelTimer.stop();
		saveGameState();
		resetGame();
		displayStart();
		levelTimer.start();
	}
}

void Game::loadGameState()
{
	string keyCode;

	//loads buffers
	ifstream fin;
	fin.open("gameStateData.txt");

	if (!fin.is_open())
	{
		cout << "Failed to Load Texture File" << endl;
	}

	while (!fin.eof())
	{
		fin >> keyCode;

		if (keyCode == "scr")
		{
			fin >> mScore;
		}
		else if (keyCode == "diff")
		{
			fin >> currentDifficulty;
			if (currentDifficulty == 0)
			{
				setDifficulty("easy");
			}
			else if (currentDifficulty == 1)
			{
				setDifficulty("medium");
			}
			else if (currentDifficulty == 2)
			{
				setDifficulty("hard");
			}
		}
		else if (keyCode == "time")
		{
			fin >> savedTime;
		}
	}
	mpOrbs->loadOrbStateFromSave();
}

void Game::readFiles()
{
	string keyCode;

	//loads buffers
	ifstream fin;
	fin.open("bufferFiles.txt");

	if (!fin.is_open())
	{
		cout << "Failed to Load Texture File" << endl;
	}

	while (!fin.eof())
	{
		fin >> keyCode;

		if (keyCode == "bckgrnd")
		{
			fin >> backgroundFileName;
		}
		else if (keyCode == "rdOrb")
		{
			fin >> redOrbFileName;
		}
		else if (keyCode == "blOrb")
		{
			fin >> blueOrbFileName;
		}
	}

	fin.close();
}

void Game::render()
{
	//Render
	mpDisplay->drawCurrent(Vector2D(), Sprite(mpBufferManager->getBuffer("back")), 1.0);
	mpOrbUnitManager->drawAll(mpDisplay);

	mpHud->drawScore(mpDisplay, mScore, currentLanguage);
	mpHud->drawTimer(mpDisplay, levelTimer.getElapsedTime(), savedTime, currentLanguage);
	mpHud->drawFPS(mpDisplay, (1000.0 / elapsedTime));

	mpDisplay->flipDisplay();
}

void Game::resetGame()
{
	shouldLoop = false;
	shouldStart = false;
	shouldEndGame = false;
	shouldPlayAgain = false;

	mFrameCount = 0;
	mScore = 10;
	savedTime = 0.0;

	mpOrbs->resetOrbs();
}

void Game::saveGameState()
{
	ofstream fout;
	fout.open("gameStateData.txt");

	fout << "scr " << mScore << endl;
	fout << "diff " << currentDifficulty << endl;
	fout << "time " << levelTimer.getElapsedTime();

	fout.close();

	mpOrbs->saveOrbState();
}

void Game::setCurrentOption(string dir)
{
	if (dir == "Up")
	{
		if (currentOption == 1)
		{
			currentOption = 3;
		}
		else if (currentOption == 2)
		{
			currentOption = 1;
		}
		else if (currentOption == 3)
		{
			currentOption = 2;
		}
	}
	else if (dir == "Down")
	{
		if (currentOption == 1)
		{
			currentOption = 2;
		}
		else if (currentOption == 2)
		{
			currentOption = 3;
		}
		else if (currentOption == 3)
		{
			currentOption = 1;
		}
	}
}

void Game::setDifficulty(string diff)
{
	if (diff == "easy")
	{
		currentDifficulty = easy;
		mpOrbs->setDifficulty(easy);
	}
	else if (diff == "medium")
	{
		currentDifficulty = medium;
		mpOrbs->setDifficulty(medium);
	}
	else if (diff == "hard")
	{
		currentDifficulty = hard;
		mpOrbs->setDifficulty(hard);
	}
}

void Game::setLanguage(string lang)
{
	if (lang == "english")
	{
		currentLanguage = English;
	}
	else if (lang == "spanish")
	{
		currentLanguage = Spanish;
	}
	else if (lang == "french")
	{
		currentLanguage = French;
	}
}

void Game::setShouldLoop(bool loop)
{
	shouldLoop = loop;
}

void Game::setShouldStart()
{
	if (shouldStart)
	{
		shouldStart = false;
	}
	else
	{
		shouldStart = true;
	}
}

void Game::setSound()
{
	pSoundSystem->setShouldPlay();
	if (currentSound == 1)
	{
		currentSound = 2;
	}
	else
	{
		currentSound = 1;
	}
}

void Game::update(double dt)
{
	//Updates the units' animations
	mpOrbUnitManager->updateAll(dt);

	//Continually checks to spawn orbs
	mpOrbs->spawnOrb();
	mpOrbs->moveOrbs();
}
