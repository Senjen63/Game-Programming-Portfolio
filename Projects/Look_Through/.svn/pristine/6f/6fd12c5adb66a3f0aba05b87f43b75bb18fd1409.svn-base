#include "LevelManagerNew.h"

const float LevelManagerNew::ANIM_SPEED = 1.0f;
const int LevelManagerNew::CELL_SIZE = 32;
const int LevelManagerNew::LEVEL_WIDTH = 25;


LevelManagerNew::LevelManagerNew()
{
	mCurLevel = 0;
	mCurDiff = DifficultyLevel::NORMAL_DIFFICULTY;
}


LevelManagerNew::~LevelManagerNew()
{
	if (Game::getInstance()->getInLevel())
	{
		saveData();
	}

	cleanup();
}


void LevelManagerNew::init()
{
	unitSetUp();

	GraphicsBufferManager* gbManager = Game::getInstance()->getGraphicsBufferManager();

	Level* level1 = new Level();
	mLevels.push_back(level1);
	level1->init(mLevelLoadPaths[mCurrentLevelLoadPathIndex], this, Vector2D(gbManager->getBackBuffer().getWidth() / 2 - CELL_SIZE / 2, gbManager->getBackBuffer().getHeight() - CELL_SIZE));

	mCurLevel = mLevels.size() - 1;
}


void LevelManagerNew::initLoad()
{
	std::ifstream input;
	input.open(SAVE_PATH);

	if (!input.good())
	{
		init();
		return;
	}

	unitSetUp();

	std::string levelIndex;
	int frogX;
	int frogY;

	input >> levelIndex;
	input >> frogX;
	input >> frogY;

	Level* level = new Level();
	mLevels.push_back(level);
	level->init(mLevelLoadPaths[mCurrentLevelLoadPathIndex], this, Vector2D(frogX, frogY));

	mCurLevel = mLevels.size() - 1;
}


void LevelManagerNew::saveData()
{
	ofstream saveFile(SAVE_PATH);
	saveFile << mCurrentLevelLoadPathIndex << std::endl;;

	Vector2D frogPos = mLevels[mCurLevel]->getLastFrogPos();
	saveFile << frogPos.getX() << std::endl << frogPos.getY() << std::endl;

	saveFile.close();
}


void LevelManagerNew::cleanup()
{
	deleteLevels();
}


void LevelManagerNew::update(float dt)
{
	getCurLevel()->update(dt);
}


void LevelManagerNew::createLevel(std::string fileName)
{
	Level* level = new Level();
	mLevels.push_back(level);
	level->init(fileName, this);
}


void LevelManagerNew::deleteLevels()
{
	for (int i = 0; i < mLevels.size(); i++)
	{
		delete mLevels[i];
	}

	mLevels.clear();
}


void LevelManagerNew::unitSetUp()
{
	mInitialized = true;

	GraphicsBufferManager* gbManager = Game::getInstance()->getGraphicsBufferManager();
	AnimationManager* aManager = Game::getInstance()->getAnimationManager();

	// Frog setup
	std::vector<Sprite> frogSprites;
	Sprite frogSprite = Sprite(&gbManager->getGraphicsBuffer("FrogBuffer"));
	frogSprites.push_back(frogSprite);
	aManager->addAnimationFrames("FrogFrames", frogSprites);
	Animation frogAnimation = *(aManager->addAnimation("FrogAnim", "FrogFrames", 1, true));

	std::unordered_map<std::string, Animation> frogAnims;
	frogAnims["FrogAnim"] = frogAnimation;

	mFrogParams = UnitParameters(Vector2D(gbManager->getBackBuffer().getWidth() / 2 - CELL_SIZE / 2, gbManager->getBackBuffer().getHeight() - CELL_SIZE), frogAnims, "FrogAnim", CollisionLayer::SNAKE_HEAD);

	// Truck setup
	std::vector<Sprite> truckLeftSprites;
	Sprite truckLeftSprite = Sprite(&gbManager->getGraphicsBuffer("TruckBuffer"), Vector2D(0, 0), Vector2D(64, 32));
	truckLeftSprites.push_back(truckLeftSprite);
	aManager->addAnimationFrames("TruckLeftFrames", truckLeftSprites);
	Animation truckLeftAnimation = *aManager->addAnimation("TruckLeftAnim", "TruckLeftFrames", ANIM_SPEED, true);

	std::vector<Sprite> truckRightSprites;
	Sprite truckRightSprite = Sprite(&gbManager->getGraphicsBuffer("TruckBuffer"), Vector2D(0, 32), Vector2D(64, 32));
	truckRightSprites.push_back(truckRightSprite);
	aManager->addAnimationFrames("TruckRightFrames", truckRightSprites);
	Animation truckRightAnimation = *aManager->addAnimation("TruckRightAnim", "TruckRightFrames", ANIM_SPEED, true);

	std::unordered_map<std::string, Animation> truckAnims;
	truckAnims["TruckLeftAnim"] = truckLeftAnimation;
	truckAnims["TruckRightAnim"] = truckRightAnimation;

	mTruckParams = UnitParameters(Vector2D(0, 0), truckAnims, "TruckLeftAnim", CollisionLayer::TRUCK);

	// Log setup
	std::vector<Sprite> logSprites;
	Sprite logSprite = Sprite(&gbManager->getGraphicsBuffer("LogBuffer"));
	logSprites.push_back(logSprite);
	aManager->addAnimationFrames("LogFrames", logSprites);
	Animation logAnimation = *aManager->addAnimation("LogAnim", "LogFrames", ANIM_SPEED, true);
	std::unordered_map<std::string, Animation> logAnims;
	logAnims["LogAnim"] = logAnimation;

	mLogParams = UnitParameters(Vector2D(0, 0), logAnims, "LogAnim", CollisionLayer::LOG);

	// Water Setup
	std::vector<Sprite> waterSprites;
	Sprite waterSprite = Sprite(&gbManager->getGraphicsBuffer("WaterBuffer"));
	waterSprites.push_back(waterSprite);
	aManager->addAnimationFrames("WaterFrames", waterSprites);
	Animation waterAnimation = *aManager->addAnimation("WaterAnim", "WaterFrames", ANIM_SPEED, true);
	std::unordered_map<std::string, Animation> waterAnims;
	waterAnims["WaterAnim"] = waterAnimation;

	mWaterParams = UnitParameters(Vector2D(0, 0), waterAnims, "WaterAnim", CollisionLayer::WATER);

	// Grass Setup
	std::vector<Sprite> grassSprites;
	Sprite grassSprite = Sprite(&gbManager->getGraphicsBuffer("GrassBuffer"));
	grassSprites.push_back(grassSprite);
	aManager->addAnimationFrames("GrassFrames", grassSprites);
	Animation grassAnimation = *aManager->addAnimation("GrassAnim", "GrassFrames", ANIM_SPEED, true);
	std::unordered_map<std::string, Animation> grassAnims;
	grassAnims["GrassAnim"] = grassAnimation;

	mGrassParams = UnitParameters(Vector2D(0, 0), grassAnims, "GrassAnim", CollisionLayer::NONE);

	// Street Setup
	std::vector<Sprite> streetSprites;
	Sprite streetSprite = Sprite(&gbManager->getGraphicsBuffer("StreetBuffer"));
	streetSprites.push_back(streetSprite);
	aManager->addAnimationFrames("StreetFrames", streetSprites);
	Animation streetAnimation = *aManager->addAnimation("StreetAnim", "StreetFrames", ANIM_SPEED, true);
	std::unordered_map<std::string, Animation> streetAnims;
	streetAnims["StreetAnim"] = streetAnimation;

	mStreetParams = UnitParameters(Vector2D(0, 0), streetAnims, "StreetAnim", CollisionLayer::NONE);
}
