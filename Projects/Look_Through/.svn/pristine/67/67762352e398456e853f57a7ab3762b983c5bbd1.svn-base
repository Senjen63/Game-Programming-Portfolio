#include "PlayerUnit.h"
#include "InputTranslator.h"
#include "UnitManager.h"

PlayerUnit::PlayerUnit()
{

}


PlayerUnit::PlayerUnit(Vector2D pos, int fps, bool physicsActive, bool gravityActive, bool physicsColliderActive, Sound* Idle, Sound* Jump, Sound* Walk)
    : Unit(pos, fps, physicsActive, gravityActive, physicsColliderActive)
{
    mpIdle = Idle;
    mpWalk = Walk;
    mpJump = Jump;
}


PlayerUnit::PlayerUnit(Vector2D pos, AnimationFrames* anim, int fps, bool loopAnimation, int type, bool physicsActive, bool gravityActive, bool physicsColliderActive, 
    Sound* Idle, Sound* Jump, Sound* Walk) 
    : Unit(pos, anim, fps, loopAnimation, type, physicsActive, gravityActive, physicsColliderActive)
{
    mpIdle = Idle;
    mpWalk = Walk;
    mpJump = Jump;
}


PlayerUnit::~PlayerUnit()
{
    //Unit::~Unit();

    cleanup();
}


void PlayerUnit::init()
{
    Unit::init();
}


void PlayerUnit::cleanup()
{

}


/*
======================

Changes velocity based
on inputs

======================
*/
void PlayerUnit::handleEvent(const Event& currentEvent)
{
    if (currentEvent.getType() == ACTION_GAME_EVENT)
    {
        const ActionEvent& actionEvent = static_cast<const ActionEvent&>(currentEvent);

        if (actionEvent.getAction() == MOVE_RIGHT)
        {
            //set velocity right
            mPhysics.setVelocity(Vector2D( mPhysics.getSpeed(), mPhysics.getVelocity().getY()));
        }
        else if (actionEvent.getAction() == MOVE_LEFT)
        {
            //set velocity left
            mPhysics.setVelocity(Vector2D( -mPhysics.getSpeed(), mPhysics.getVelocity().getY())); //negative speed is opposite direction of right
        }
        else if (actionEvent.getAction() == STOP_MOVE_LEFT && mPhysics.getVelocity().getX() < 0) //if stop left move event and moving left
        {
            //stop x velocity
            mPhysics.setVelocity(Vector2D(0.0f, mPhysics.getVelocity().getY()));
        }
        else if (actionEvent.getAction() == STOP_MOVE_RIGHT && mPhysics.getVelocity().getX() > 0) //if stop move right event and moving right
        {
            //stop x velocity
            mPhysics.setVelocity(Vector2D(0.0f, mPhysics.getVelocity().getY()));
        }

        if (actionEvent.getAction() == JUMP)
        {
            if (mPhysics.getGravityActive())
            {
                int jumpCount = mPhysics.getJumpCount();
                if (jumpCount > 0)
                {
                    //stop acceleration (which is probably downwards) and set velocity upwards
                    mPhysics.setAcceleration(Vector2D(mPhysics.getAcceleration().getX(), 0.0f));
                    mPhysics.setVelocity(Vector2D(mPhysics.getVelocity().getX(), mPhysics.getJumpPower()));

                    mPhysics.setJumpCount(jumpCount - 1); //decrease jump count
                }
                
            }
        }
    }
}


void PlayerUnit::update(float timeElapsed)
{
    if (mPhysics.getVelocity().getX() != 0) //player moving side to side (regardless of Y velocity)
    {
        //if there are more than 2 animations
        if (mAnims.size() > 2)
        {
            mCurrentIndex = 2; //switch to walk animation
        }
        PlayerUnit::playSound(1);
    }
    else if (mPhysics.getVelocity().getY() != 0) //player moving up and down
    {
        //if there is at least 1 animation
        if (mAnims.size() > 0)
        {
            mCurrentIndex = 0; //switch to still animation
        }
    }
    else //player is not moving
    {
        //if there is more than 1 animation
        if (mAnims.size() > 1)
        {
            mCurrentIndex = 1; //switch to idle animation
        }
        PlayerUnit::playSound(0);
    }

    //only play once when jumping
    if (mPhysics.jumped())
    {
        PlayerUnit::playSound(2);
    }

    Unit::update(timeElapsed);
}


void PlayerUnit::checkCollisions(UnitManager* pUnitManager, Level* pLevel, Sound* ArrowCollide, Sound* SpikeCollide, Sound* DoorCollide)
{
    vector<Unit*> colliders = pUnitManager->checkAnyCollisions(this, false);

    for (auto collider : colliders)
    {
        //if collided with door
        if (collider->getType() == UnitTypes::DOOR_UNIT_TYPE)
        {
            mpEventSystem->fireEvent(EndLevelEvent(true));
            DoorCollide->play();
        }

        //if collided with deadly unit
        if(collider->getType() == UnitTypes::SPIKE_UNIT_TYPE || collider->getType() == UnitTypes::ARROWS_UNIT_TYPE) 
        {
            mpEventSystem->fireEvent(EndLevelEvent(false)); //false for dead
            if (collider->getType() == UnitTypes::SPIKE_UNIT_TYPE)
            {
                SpikeCollide->play();
            }
            else
            {
                ArrowCollide->play();
            }
        }

        if (collider->getType() == UnitTypes::COLLECTIBLE_UNIT_TYPE)
        {
            int addScore = pLevel->getCollectibleWorth();
            mpEventSystem->fireEvent(AddScoreEvent(addScore));
            collider->setDelete(true);
            //pUnitManager->deleteUnit(colliders[colliders.size() - 1]);
        }
    }
}

void PlayerUnit::playSound(int index)
{
    if (index == 0)
    {
        if (!mpIdle->getStatusPlaying())
        {
            mpIdle->play();
        }
    }
    if (index == 1)
    {
        if (!mpWalk->getStatusPlaying())
        {
            mpWalk->play();
        }
    }
    if (index == 2)
    {
        //if (mpJump->getStatus() != sf::Sound::Playing)
        //{
            mpJump->play();
        //}
    }
}


/*void PlayerUnit::checkDoorCollision(UnitManager* pUnitManager)
{
    vector<Unit*> collidedDoors = pUnitManager->checkCollisionOfType(this, UnitTypes::DOOR_UNIT_TYPE, false);

    if (collidedDoors.size() > 0) //if collided with door
    {
        mpEventSystem->fireEvent(EndLevelEvent(true));
    }
}

void PlayerUnit::checkSpikeCollision(UnitManager* pUnitManager)
{
    vector<Unit*> collidedSpikes = pUnitManager->checkCollisionOfType(this, UnitTypes::SPIKE_UNIT_TYPE, false);

    if (collidedSpikes.size() > 0)
    {
        mpEventSystem->fireEvent(EndLevelEvent(false));
    }

}

void PlayerUnit::checkCollectibleCollision(UnitManager* pUnitManager, Level* pLevel)
{
    vector<Unit*> collidedCollectibles = pUnitManager->checkCollisionOfType(this, UnitTypes::COLLECTIBLE_UNIT_TYPE, false);

    if (collidedCollectibles.size() > 0)
    {
        int addScore = pLevel->getCollectibleWorth();
        mpEventSystem->fireEvent(AddScoreEvent(addScore));
        pUnitManager->deleteUnit(collidedCollectibles[collidedCollectibles.size()-1]);
    }

}*/