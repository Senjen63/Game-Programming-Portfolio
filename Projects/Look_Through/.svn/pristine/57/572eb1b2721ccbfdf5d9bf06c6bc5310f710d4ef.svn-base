#include "Game.h"

Game* Game::mpsGame = nullptr;

Game::Game()
{
	mWidth = DISP_WIDTH;
	mHeight = DISP_HEIGHT;
    mpSystem = new GraphicsSystem(mWidth, mHeight);
	mpEventSystem = nullptr;

	mSnake = Snake();

	mSnakeHeadX = DISP_WIDTH / 2;
	mSnakeHeadY = DISP_HEIGHT / 2;

	mScreenCenterX = DISP_WIDTH / 2;
	mScreenCenterY = DISP_HEIGHT / 2;

	mCurrentLevel = 0;
}

Game::~Game()
{
	cleanup();
}


Game* Game::getInstance()
{
	return mpsGame;
}

void Game::destroyInstance()
{
	delete mpsGame;
	mpsGame = NULL;
}

void Game::createInstance()
{
	if (mpsGame == NULL)
	{
		mpsGame = new Game;
	}
}

void Game::init()
{
	mpSystem->init();
	mInput.init();
	mpEventSystem = EventSystem::getInstance();
	mpEventSystem->init();
	mpEventSystem->getInstance()->addListener((EventType)INPUT_EVENT, this);
	mpEventSystem->getInstance()->addListener((EventType)GAMEPLAY_EVENT, this);

	fstream	fin(mASSET_PATH + mMAIN_FILENAME);

	fin >> mBackgroundFilename;
	fin >> mBuffFilename;
	fin >> mDebuffFilename;
	fin >> mFoodFilename;
	fin >> mScoreFilename;
	fin >> mSnakeSpriteFilename;
	fin >> mWallSpriteFilename;
	fin >> mSTART_FILENAME;
	fin >> mWIN_FILENAME;
	fin >> mEND_FILENAME;

	while (!fin.eof())
	{
		string levelFile;
		fin >> levelFile;
		Level level(levelFile);
		mLevels.push_back(level);
	}

	mSnake.setFps(mLevels[mCurrentLevel].mUnitFps);

	mpBackground = new GraphicsBuffer(mASSET_PATH, mBackgroundFilename);
	mpWall = new GraphicsBuffer(mASSET_PATH, mWallSpriteFilename);
	mpSnake = new GraphicsBuffer(mASSET_PATH, mSnakeSpriteFilename);
	mpGameStart = new GraphicsBuffer(mASSET_PATH, mSTART_FILENAME);
	mpGameWin = new GraphicsBuffer(mASSET_PATH, mWIN_FILENAME);
	mpGameOver = new GraphicsBuffer(mASSET_PATH, mEND_FILENAME);
	mpFood = new GraphicsBuffer(mASSET_PATH, mFoodFilename);
	mpScore = new GraphicsBuffer(mASSET_PATH, mScoreFilename);
	mpBuff = new GraphicsBuffer(mASSET_PATH, mBuffFilename);
	mpDebuff = new GraphicsBuffer(mASSET_PATH, mDebuffFilename);
	mpFont = new Font(mASSET_PATH, mFontFile, 30, 1);
	//Magic Number, fix
	mFoodObj = mpSystem->createUnit(mpFood, 2, 2, 0, 0, mLevels[mCurrentLevel].mUnitFps);
}

void Game::cleanup()
{
	mpSystem->cleanup();
	mInput.cleanup();
	delete mpBackground;
	delete mpWall;
	delete mpSnake;
	delete mpGameOver;
	delete mpGameStart;
	delete mpGameWin;
	delete mpFood;
	delete mpBuff;
	delete mpScore;
	delete mpDebuff;
	delete mpSystem;
	delete mpFont;
}

void Game::doLoop()
{
	PerformanceTracker* pPerformanceTracker = new PerformanceTracker;

	const string INIT_TRACKER_NAME = "init";
	const string DRAW_TRACKER_NAME = "draw";
	const string WAIT_TRACKER_NAME = "wait";

	pPerformanceTracker->clearTracker("loop");

	pPerformanceTracker->startTracking("loop");
	const Vector2D vecSize(mWidth, mHeight);
	double targetMS = 1000.0/mFps;
	Timer timer;

	Sprite background(mpBackground, mVecZero, mWidth, mHeight);

	Unit snakeSegment = mpSystem->createUnit(mpSnake, 1, 1, mWidth / 2, mHeight / 2, mLevels[mCurrentLevel].mUnitFps);
	mSnake.addUnit(snakeSegment);

	loadLevel();

	startGame();

	while (mShouldContinue)
	{
		timer.start();

		mSnakeHeadX = mSnake.getUnit(0).getLocationX();
		mSnakeHeadY = mSnake.getUnit(0).getLocationY();

		//background draw is weird
		mpSystem->draw(mVecZero, mVecZero, background, 1);

		mSnake.updateSnake(mpSnake->getWidth(), mpSnake->getHeight(), mLevels[mCurrentLevel].mUnitFps);

		mTimeOnLevel += timer.getElapsedTime();

		mSnake.drawAll(mScale);

		mWalls.drawAll(mScale);

		eventCheck();

		spawnObjects();

		mInput.keyEvent();

		drawUI();

		mpSystem->flip();
		timer.sleepUntilElapsed(targetMS);

		pPerformanceTracker->stopTracking("loop");
		//cout << pPerformanceTracker->getElapsedTime("loop") << endl;
	}
	Sprite endBackground(mpGameOver, mVecZero, mWidth, mHeight);
	mpSystem->draw(mVecZero, mVecZero, background, 1);
	mpSystem->flip();

	delete pPerformanceTracker;
}

void Game::eventCheck()
{

	if (mSnake.getLength() == mLevels[mCurrentLevel].mReqSnakeLength)
	{
		mpEventSystem->fireEvent(GameplayEvents((int)GameEventTypes::WIN));
	} 

	for (int i = 0; i < mWalls.getLength(); i++)
	{
		if (mSnakeHeadX == mWalls.getUnit(i).getLocationX() && mSnakeHeadY == mWalls.getUnit(i).getLocationY())
		{
			mpEventSystem->fireEvent(GameplayEvents((int)GameEventTypes::LOSE));
		}
	}

	for (int i = 2; i < mSnake.getLength(); i++)
	{
		if (mSnakeHeadX == mSnake.getUnit(i).getLocationX() && mSnakeHeadY == mSnake.getUnit(i).getLocationY())
		{
			mpEventSystem->fireEvent(GameplayEvents((int)GameEventTypes::LOSE));
		}
	}

	if (mSnakeHeadX == mFoodObj.getLocationX() && mSnakeHeadY == mFoodObj.getLocationY())
	{
		mpEventSystem->fireEvent(GameplayEvents((int)GameEventTypes::ADD));
	}

	for (int i = 0; i < mSpeedUp.getLength(); i++)
	{
		if (mSnakeHeadX == mSpeedUp.getUnit(i).getLocationX() && mSnakeHeadY == mSpeedUp.getUnit(i).getLocationY())
		{
			mpEventSystem->fireEvent(GameplayEvents((int)GameEventTypes::SPEED));
		}
	}

	for (int i = 0; i < mSlowDown.getLength(); i++)
	{
		if (mSnakeHeadX == mSlowDown.getUnit(i).getLocationX() && mSnakeHeadY == mSlowDown.getUnit(i).getLocationY())
		{
			mpEventSystem->fireEvent(GameplayEvents((int)GameEventTypes::SLOW));
		}
	}

	for (int i = 0; i < mPointsObj.getLength(); i++)
	{
		if (mSnakeHeadX == mPointsObj.getUnit(i).getLocationX() && mSnakeHeadY == mPointsObj.getUnit(i).getLocationY())
		{
			mpEventSystem->fireEvent(GameplayEvents((int)GameEventTypes::ADDPOINTS));
		}
	}
}

void Game::handleEvent(const Event &event)
{
	if (event.getType() == INPUT_EVENT)
	{

		const InputEvents& inputKey = static_cast<const InputEvents&>(event);

		if (inputKey.getKeyCode() == (int)KeyCode::A && mShouldContinue)
		{
			if (mSnake.getDir() != RIGHT)
			{
				mSnake.setDir(LEFT);
			}
		}

		if (inputKey.getKeyCode() == (int)KeyCode::D && mShouldContinue)
		{
			if (mSnake.getDir() != LEFT)
			{
				mSnake.setDir(RIGHT);
			}
		}

		if (inputKey.getKeyCode() == (int)KeyCode::W && mShouldContinue)
		{
			if (mSnake.getDir() != DOWN)
			{
				mSnake.setDir(UP);
			}
		}

		if (inputKey.getKeyCode() == (int)KeyCode::S && mShouldContinue)
		{
			if (mSnake.getDir() != UP)
			{
				mSnake.setDir(DOWN);
			}
		}
	}

	if (event.getType() == GAMEPLAY_EVENT)
	{

		const GameplayEvents& gameEvent = static_cast<const GameplayEvents&>(event);

		if (gameEvent.getEvent() == GameEventTypes::LOSE)
		{
			if (mCollide == true)
			{
				endGame();
			}
		}

		if (gameEvent.getEvent() == GameEventTypes::WIN)
		{
			if (mCurrentLevel < mLevels.size() - 1)
			{
				nextLevel();
			}
			else
			{
				winGame();
			}
		}


		if (gameEvent.getEvent() == GameEventTypes::SPEED)
		{
			mGridSpacesOpen.push_back(Vector2D(mSnakeHeadX, mSnakeHeadY));
			mSpeedUp.removeUnit(Vector2D(mSnakeHeadX, mSnakeHeadY));
			if (mLevels[mCurrentLevel].mUnitFps < mMAX_FPS)
			{
				mLevels[mCurrentLevel].mUnitFps = mLevels[mCurrentLevel].mUnitFps + mSpeedChange;
			}
		}

		if (gameEvent.getEvent() == GameEventTypes::SLOW)
		{
			mGridSpacesOpen.push_back(Vector2D(mSnakeHeadX, mSnakeHeadY));
			mSlowDown.removeUnit(Vector2D(mSnakeHeadX, mSnakeHeadY));
			if (mLevels[mCurrentLevel].mUnitFps > mMIN_FPS)
			{
				mLevels[mCurrentLevel].mUnitFps = mLevels[mCurrentLevel].mUnitFps - mSpeedChange;
			}
		}

		if (gameEvent.getEvent() == GameEventTypes::ADDPOINTS)
		{
			mGridSpacesOpen.push_back(Vector2D(mSnakeHeadX, mSnakeHeadY));
			mPointsObj.removeUnit(Vector2D(mSnakeHeadX, mSnakeHeadY));
			mPoints++;
		}

		if (gameEvent.getEvent() == GameEventTypes::ADD)
		{
			mPoints++;
			mGridSpacesOpen.push_back(Vector2D(mSnakeHeadX, mSnakeHeadY));
			mGridSpacesOpen.push_back(Vector2D(mSnakeHeadX, mSnakeHeadY));
			Unit snakeSegment = mpSystem->createUnit(mpSnake, 1, 1, 0, 0, mLevels[mCurrentLevel].mUnitFps);
			int segmentX = mSnake.getRecentUnit().getLocationX() + mpSnake->getWidth();
			int segmentY = mSnake.getRecentUnit().getLocationY();
			snakeSegment.setLocationX(segmentX);
			snakeSegment.setLocationY(segmentY);
			mSnake.addUnit(snakeSegment);
			mFoodCreated = false;
		}
	}
}

void Game::loadLevel()
{

	Animation wallAnimation(mLevels[mCurrentLevel].mUnitFps);

	int is1;
	ifstream fin(mLevels[mCurrentLevel].mASSET_PATH + mLevels[mCurrentLevel].mWallDisplayFilename);

	if (!mWalls.isEmpty())
	{
		mWalls.removeAll();
	}

	mLevels[mCurrentLevel].mUnitFps = mLevels[mCurrentLevel].mDefaultUnitFps;
	mTimeOnLevel = 0;
	mFoodCreated = false;
	mGridSpaces.clear();
	mGridSpacesOpen.clear();
	mPointsObj.removeAll();
	mSpeedUp.removeAll();
	mSlowDown.removeAll();

	for (int i = 0; i < mLevels[mCurrentLevel].mStartingLength - 1; i++)
	{
		mpEventSystem->fireEvent(GameplayEvents((int)GameEventTypes::ADD));
	}

	for (int j = 0; j < mHeight / mpWall->getHeight(); j++)
	{
		for (int o = 0; o < mWidth / mpWall->getWidth(); o++)
		{
			Unit wall((o * mpWall->getWidth()), (j * mpWall->getHeight()));

			fin >> is1;
			if (is1 == 1)
			{
				Sprite wallSprite(mpWall, Vector2D(o * mpWall->getWidth(), j * mpWall->getHeight()), mpWall->getWidth(), mpWall->getHeight());
				wallAnimation.addSprite(wallSprite);

				wall.addAnimation(wallAnimation);
				mWalls.addUnit(wall);
			}
			else
			{
				mGridSpaces.push_back(Vector2D((o * mpWall->getWidth()), (j * mpWall->getHeight())));
				mGridSpacesOpen.push_back(Vector2D((o * mpWall->getWidth()), (j * mpWall->getHeight())));
			}
		}
	}
}

void Game::startGame()
{
	bool startScreen = true;
	while (startScreen == true)
	{
		if (mInput.getKeyState(ESCAPE))
		{
			startScreen = false;
			mShouldContinue = false;
		}
		if (mInput.getKeyState(SPACE))
		{
			startScreen = false;
		}

		Sprite background(mpGameStart, mVecZero, mWidth, mHeight);
		mpSystem->draw(mVecZero, mVecZero, background, 1);
		mpSystem->flip();
	}
}

void Game::endGame()
{
	bool loseScreen = true;
	mPoints = 0;
	mSnake.getUnit(0).setLocationX(mScreenCenterX);
	mSnake.getUnit(0).setLocationY(mScreenCenterY);
	while (loseScreen == true)
	{
		if (mInput.getKeyState(ESCAPE))
		{
			loseScreen = false;
			mShouldContinue = false;
		}
		if (mInput.getKeyState(SPACE))
		{
			loseScreen = false;
			mSnake.setDir(LEFT);
		}

		mCurrentLevel = 0;
		mSnake.resetSnake();
		Sprite background(mpGameOver, mVecZero, mWidth, mHeight);
		mpSystem->draw(mVecZero, mVecZero, background, 1);
		mpSystem->flip();
	}
	loadLevel();
}

void Game::winGame()
{
	bool winScreen = true;
	mSnake.resetSnake();
	mSnake.getUnit(0).setLocationX(mScreenCenterX);
	mSnake.getUnit(0).setLocationY(mScreenCenterY);
	while (winScreen == true)
	{
		if (mInput.getKeyState(ESCAPE))
		{
			winScreen = false;
			mShouldContinue = false;
		}
		if (mInput.getKeyState(SPACE))
		{
			winScreen = false;
			mCurrentLevel = 0;
			loadLevel();
		}
		Sprite background(mpGameWin, mVecZero, mWidth, mHeight);
		mpSystem->draw(mVecZero, mVecZero, background, 1);
		mpSystem->flip();
	}
}

void Game::nextLevel()
{
	//MAKE STUFF
	mSnake.setFps(mLevels[mCurrentLevel].mUnitFps);
	mSnake.getUnit(0).setLocationX(mScreenCenterX);
	mSnake.getUnit(0).setLocationY(mScreenCenterY);
	mSnake.resetSnake();
	mCurrentLevel++;
	mSnake.setDir(LEFT);
	mLevels[mCurrentLevel].mUnitFps = mLevels[mCurrentLevel].mDefaultUnitFps;
	mTimeOnLevel = 0; 
	loadLevel();
}

void Game::spawnObjects()
{
	srand(time(NULL));

	int gridLoc;

	if (mFoodCreated == false)
	{

		gridLoc = rand() % mGridSpacesOpen.size();

		int foodX = mGridSpacesOpen[gridLoc].getX();
		int foodY = mGridSpacesOpen[gridLoc].getY();

		mGridSpacesOpen.erase(mGridSpacesOpen.begin() + gridLoc);

		mFoodObj.setLocationX(foodX);
		mFoodObj.setLocationY(foodY);

		mFoodCreated = true;
	}
	
	int shouldCreate = rand() % mLevels[mCurrentLevel].mDebuffFrequency;

	if (mSpeedUp.getLength() < 3)
	{

		if (shouldCreate == 1)
		{
			gridLoc = rand() % mGridSpacesOpen.size();

			int speedX = mGridSpacesOpen[gridLoc].getX();
			int speedY = mGridSpacesOpen[gridLoc].getY();

			mGridSpacesOpen.erase(mGridSpacesOpen.begin() + gridLoc);

			Unit unit = mpSystem->createUnit(mpBuff, 2, 2, speedX, speedY, mLevels[mCurrentLevel].mUnitFps);

			mSpeedUp.addUnit(unit);

			shouldCreate = 0;
		}
	}

	shouldCreate = rand() % mLevels[mCurrentLevel].mBuffFrequency;

	if (mSlowDown.getLength() < 3)
	{

		if (shouldCreate == 1)
		{
			gridLoc = rand() % mGridSpacesOpen.size();

			int slowX = mGridSpacesOpen[gridLoc].getX();
			int slowY = mGridSpacesOpen[gridLoc].getY();

			mGridSpacesOpen.erase(mGridSpacesOpen.begin() + gridLoc);

			Unit unit = mpSystem->createUnit(mpDebuff, 2, 2, slowX, slowY, mLevels[mCurrentLevel].mUnitFps);

			mSlowDown.addUnit(unit);

			shouldCreate = 0;
		}
	}

	shouldCreate = rand() % mLevels[mCurrentLevel].mBuffFrequency;

	if (mPointsObj.getLength() < 3)
	{

		if (shouldCreate == 1)
		{
			gridLoc = rand() % mGridSpacesOpen.size();

			int scoreX = mGridSpacesOpen[gridLoc].getX();
			int scoreY = mGridSpacesOpen[gridLoc].getY();

			mGridSpacesOpen.erase(mGridSpacesOpen.begin() + gridLoc);

			Unit unit = mpSystem->createUnit(mpScore, 2, 2, scoreX, scoreY, mLevels[mCurrentLevel].mUnitFps);

			mPointsObj.addUnit(unit);

			shouldCreate = 0;
		}
	}

	mSpeedUp.updateAll(mLevels[mCurrentLevel].mDefaultUnitFps);
	mSlowDown.updateAll(mLevels[mCurrentLevel].mDefaultUnitFps);
	mPointsObj.updateAll(mLevels[mCurrentLevel].mDefaultUnitFps);
	mFoodObj.currentAnimation().update(mLevels[mCurrentLevel].mDefaultUnitFps);
	mSpeedUp.drawAll(mScale);
	mSlowDown.drawAll(mScale);
	mPointsObj.drawAll(mScale);
	mFoodObj.draw(mScale);
}

void Game::drawUI()
{
	Color* COL_RED = new Color(255, 0, 0);
	string timeOnLevel = to_string(mTimeOnLevel);
	string time = "Time elapsed: " + timeOnLevel.substr(0, timeOnLevel.find(".") + 3);
	string points = "current points: " + to_string(mPoints);
	string fps = "Fps: " + to_string(mFps);
	mpSystem->writeText(mVecZero, *mpFont, *COL_RED, time);
	mpSystem->writeText(Vector2D(mScreenCenterX - (strlen(points.c_str()) * 10), 0), *mpFont, *COL_RED, points);
	mpSystem->writeText(Vector2D(DISP_WIDTH - (strlen(fps.c_str()) * 10), 0), *mpFont, *COL_RED, fps);
	delete COL_RED;
}