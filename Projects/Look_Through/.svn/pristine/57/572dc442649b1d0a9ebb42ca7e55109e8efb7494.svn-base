#include "ChasingEnemy.h"
#include "Projectile.h"
#include "Player.h"
#include "SceneManager.h"

ChasingEnemy::ChasingEnemy(std::pair<float, float>location, std::pair<float, float>scale, int health, int damage, int moveSpeed, std::string animationDataFilePath) : Enemy(location, scale, health, damage, moveSpeed, animationDataFilePath)
{
	const std::vector<Unit*> allObjects = Game::getGame()->getSceneManager()->getUnitVector();

	for (int i = 0; i < allObjects.size(); i++)
	{
		if (dynamic_cast<Player*>(allObjects[i]) != nullptr)
		{
			mTargetPlayer = dynamic_cast<Player*>(allObjects[i]);
		}
	}
}

ChasingEnemy::~ChasingEnemy()
{

}

void ChasingEnemy::update(float deltaTime)
{
	std::pair<float, float> targetPos = mTargetPlayer->getLocation();
	std::pair<float, float> currentPos = getLocation();

	float dist = sqrt(pow(targetPos.first - currentPos.first, 2) + pow(targetPos.second - currentPos.second, 2));

	if (dist < maxTargetingRange)
	{
		std::pair<float, float> dirVector = std::make_pair(targetPos.first - currentPos.first, targetPos.second - currentPos.second);
		std::pair<float, float> upVector = std::make_pair(0, 1);

		float dot = (dirVector.first * upVector.first) + (dirVector.second * upVector.second);
		float determinant = (dirVector.first * upVector.second) + (upVector.first * dirVector.second);
		float angle = atan2(determinant, dot);

		float velocityX = 10 * sin(angle);
		float velocityY = 10 * cos(angle);

		std::pair<float, float> newPos = make_pair(currentPos.first + (velocityX * (0.01 * deltaTime)), currentPos.second + (velocityY * (0.01 * deltaTime)));

		std::vector<Unit*> collidedObjectsX = collision(make_pair(newPos.first, currentPos.second));
		std::vector<Unit*> collidedObjectsY = collision(make_pair(currentPos.first, newPos.second));

		for (int i = 0; i < collidedObjectsX.size(); i++)
		{
			if (dynamic_cast<Projectile*>(collidedObjectsX[i]) == nullptr &&
				dynamic_cast<Player*>(collidedObjectsX[i]) == nullptr &&
				dynamic_cast<Enemy*>(collidedObjectsX[i]) == nullptr)
			{
				newPos.first = currentPos.first;
			}
		}

		for (int i = 0; i < collidedObjectsY.size(); i++)
		{
			if (dynamic_cast<Projectile*>(collidedObjectsY[i]) == nullptr &&
				dynamic_cast<Player*>(collidedObjectsY[i]) == nullptr &&
				dynamic_cast<Enemy*>(collidedObjectsY[i]) == nullptr)
			{
				newPos.second = currentPos.second;
			}
		}

		updateLocation(newPos);
	}

	Unit::update(deltaTime);
}