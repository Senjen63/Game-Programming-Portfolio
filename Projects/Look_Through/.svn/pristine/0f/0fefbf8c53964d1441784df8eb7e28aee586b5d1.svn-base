#include "LevelManager.h"

#include <iostream>
#include <fstream>
#include <EventSystem.h>
#include "SpawnEvent.h"
#include "CollectEvent.h"
#include "NextLevelEvent.h"

using namespace std;

LevelManager::LevelManager(int numLevels)
{
	mIDLevel = 0;

	mCurrentLevel = 0;
	mCurrentFruit = nullptr;
	mWallAnimation = nullptr;

	for (int i = 0; i < POWERUP_TYPES; i++)
	{
		mPowerupAnimations[i] = nullptr;
	}

	for (int i = 0; i < numLevels; i++)
	{
		mLevels.push_back(new Level(i));
	}

	EventSystem* pEventSystem = EventSystem::getInstance();
	pEventSystem->addListener((EventType)SPAWN_EVENT, this);
	pEventSystem->addListener((EventType)DEATH_EVENT, this);
	pEventSystem->addListener((EventType)COLLECT_EVENT, this);
}

LevelManager::~LevelManager()
{
	for (size_t i = 0; i < mLevels.size(); i++) { delete mLevels[i]; }
	for (int i = 0; i < POWERUP_TYPES; i++) { delete mPowerupAnimations[i]; }
	for (size_t i = 0; i < mPowerups.size(); i++) { delete mPowerups[i]; }
	for (size_t i = 0; i < mWalls.size(); i++) { delete mWalls[i]; }

	delete mWallAnimation;
	delete mCurrentFruit;
}

void LevelManager::init()
{
	ifstream levelFile;

	for (size_t i = 0; i < mLevels.size(); i++) 
	{
		int currentLine = 0;
		string currentVar;
		levelFile.open(ASSET_PATH + to_string(i) + ".txt");
		assert(levelFile.is_open());

		levelFile >> currentVar; //skipping the first line

		while (currentLine < 8)
		{
			levelFile >> currentVar;
			switch (currentLine)
			{
			case 0:
				mLevels[i]->setSnakeSpeed(stoi(currentVar));
				break;

			case 1:
				mLevels[i]->setStartingSize(stoi(currentVar));
				break;

			case 2:
				mLevels[i]->setNeededSize(stoi(currentVar));
				break;

			case 3:
				mLevels[i]->setFoodPoints(stoi(currentVar));
				break;

			case 4:
				mLevels[i]->setPowerupTime(stoi(currentVar));
				break;

			case 5:
				mLevels[i]->setPowerupChance(0, stoi(currentVar));
				break;

			case 6:
				mLevels[i]->setPowerupChance(1, stoi(currentVar));
				break;

			case 7:
				mLevels[i]->setPowerupChance(2, stoi(currentVar));
				break;
			}

			currentLine++;
		}

		levelFile.close();
	}

	initFruit();
	loadLevelWalls();
}

void LevelManager::update(float elapsedTime)
{
	if (mCurrentLevel < (int)(mLevels.size()))
	{
		mLevels[mCurrentLevel]->update(elapsedTime);
		mCurrentFruit->update(elapsedTime);

		for (size_t i = 0; i < mPowerups.size(); i++) { mPowerups[i]->update(elapsedTime); }
		for (size_t i = 0; i < mWalls.size(); i++) { mWalls[i]->update(elapsedTime); }
	}
}

void LevelManager::draw()
{
	mCurrentFruit->draw();

	for (size_t i = 0; i < mPowerups.size(); i++) { mPowerups[i]->draw(); }
	for (size_t i = 0; i < mWalls.size(); i++) { mWalls[i]->draw(); }
}

void LevelManager::nextLevelCheck(int snakeSize)
{
	if (mLevels[mCurrentLevel]->getNeededSize() <= snakeSize)
	{
		gotoNextLevel();
	}
}

void LevelManager::gotoNextLevel()
{
	mCurrentLevel++;
	EventSystem::getInstance()->fireEvent(NextLevelEvent(mCurrentLevel));

	for (size_t i = 0; i < mWalls.size(); i++) { delete mWalls[i]; }
	mWalls.clear();
	for (size_t i = 0; i < mPowerups.size(); i++) { delete mPowerups[i]; }
	mPowerups.clear();
	delete mCurrentFruit;
	initFruit();

	loadLevelWalls();

	return;
}

void LevelManager::loadLevelWalls()
{
	ifstream levelFile;

	string currentX;
	string currentY;
	levelFile.open(ASSET_PATH + to_string(mCurrentLevel) + ".txt");
	assert(levelFile.is_open());

	for (int i = 0; i < 10; i++) { levelFile >> currentX; } //skipping to the walls section

	while (!levelFile.eof())
	{
		levelFile >> currentX;
		levelFile >> currentY;

		if (currentX == "[EOF]" || currentY == "[EOF]") { break; }

		mWalls.push_back(new Wall(stoi(currentX), stoi(currentY), new Animation(*mWallAnimation)));
	}

	levelFile.close();
}

void LevelManager::initFruit()
{ 
	mCurrentFruit = new Powerup(FRUIT,new Animation(*mPowerupAnimations[0]),-1);
	
	while (checkOverlap(mCurrentFruit)) { mCurrentFruit->setNewPosition(); }
}

bool LevelManager::checkOverlap(Powerup* toCheck)
{
	if (mCurrentFruit->getX() == toCheck->getX() && mCurrentFruit->getY() == toCheck->getY()) // fruit check
	{
		if (mCurrentFruit->getID() != toCheck->getID()) { return true; }
	}

	for (size_t i = 0; i < mWalls.size(); i++) // wall check
	{
		if (mWalls[i]->getX() == toCheck->getX() && mWalls[i]->getY() == toCheck->getY()) { return true; }
	}

	for (size_t i = 0; i < mPowerups.size(); i++) // other powerups check
	{
		if (mPowerups[i]->getX() == toCheck->getX() && mPowerups[i]->getY() == toCheck->getY()) 
		{ 
			if (mPowerups[i]->getID() != toCheck->getID()) { return true; }
		}
	}

	return false;
}

void LevelManager::handleEvent(const Event& theEvent)
{
	if (theEvent.getType() == DEATH_EVENT)
	{
		mCurrentLevel = 0;
		for (size_t i = 0; i < mPowerups.size(); i++) { delete mPowerups[i]; }
		mPowerups.clear();
		delete mCurrentFruit;
		initFruit();
	}

	else if (theEvent.getType() == SPAWN_EVENT)
	{
		const SpawnEvent& spawnEvent = static_cast<const SpawnEvent&>(theEvent);

		mPowerups.push_back(new Powerup(spawnEvent.getType(),new Animation(*mPowerupAnimations[spawnEvent.getType()]),mIDLevel));
		while (checkOverlap(mPowerups[mPowerups.size() - 1])) { mPowerups[mPowerups.size() - 1]->setNewPosition(); }

		mIDLevel++;
	}

	else if (theEvent.getType() == COLLECT_EVENT)
	{
		const CollectEvent& collectEvent = static_cast<const CollectEvent&>(theEvent);

		if (collectEvent.getType() == FRUIT) //move fruit somewhere else
		{
			do { mCurrentFruit->setNewPosition(); } while (checkOverlap(mCurrentFruit));
		}
		else //find powerup at pos and remove
		{
			for (size_t i = 0; i < mPowerups.size(); i++)
			{
				if (mPowerups[i]->getID() == collectEvent.getID())
				{
					delete mPowerups[i];
					mPowerups.erase(mPowerups.begin() + i);
				}
			}
		}
	}
}