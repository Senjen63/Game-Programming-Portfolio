#include "Snake.h"
#include "Game.h"

Snake::Snake()
{
    mInitialSpawnLocation = Vector2D(0, 0);
}


Snake::Snake(Vector2D initialSpawnLocation, Vector2D initialDirection, GraphicsBuffer* head, GraphicsBuffer* body)
{
    mpEventSystem = nullptr;
    mInitialSpawnLocation = initialSpawnLocation;
    mInitialDirection = initialDirection;
    mpHeadBuffer = head;
    mpBodyBuffer = body;
}


Snake::~Snake()
{
    //Graphics Buffer deletion handled by GraphicsBufferManager, may still be used by another object
    cleanup();
}


void Snake::init() 
{
    mpEventSystem = EventSystem::getInstance();

    mpEventSystem->addListener((EventType)TURN_EVENT, this);
    mpEventSystem->addListener((EventType)COLLISION_EVENT, this);
}


void Snake::cleanup()
{
    mpHeadBuffer = nullptr;
    mpBodyBuffer = nullptr;
}


SnakeUnit* Snake::getSnakeHead()
{
    if (mSnakeStorage.size() > 0)
    {
        return mSnakeStorage[0];
    }

    return nullptr;
}


SnakeUnit* Snake::getSnakeTail()
{
    if (mSnakeStorage.size() > 0)
    {
        return mSnakeStorage[mSnakeStorage.size() - 1];
    }

    return nullptr;
}


void Snake::setSnakeSpeed(float snakeSpeed) 
{ 
    if (snakeSpeed < MIN_SNAKE_SPEED)
    {
        snakeSpeed = MIN_SNAKE_SPEED;
    }

    for (unsigned int i = 1; i < mSnakeStorage.size(); i++)
    {
        float framesAcross = (mpBodyBuffer->getWidth() / snakeSpeed); //how many frames it takes for body to move its length

        if (i == 1)
        {
            framesAcross = (mpHeadBuffer->getWidth() / snakeSpeed);
        }

        mSnakeStorage[i]->speedChange(mSnakeSpeed, snakeSpeed, framesAcross);
    }

    mSnakeSpeed = snakeSpeed;
}


void Snake::handleEvent(const Event& currentEvent)
{
    if (mSnakeStorage.size() > 0)
    {
        if (currentEvent.getType() == TURN_EVENT)
        {
            const TurnEvent& turnEvent = static_cast<const TurnEvent&>(currentEvent);
            getSnakeHead()->setDirection(turnEvent.getDirection());

            for (unsigned int i = 1; i < mSnakeStorage.size(); i++)
            {
                mSnakeStorage[i]->addTurn(turnEvent.getDirection(), i);
            }
        }

        if (currentEvent.getType() == COLLISION_EVENT)
        {
            const CollisionEvent& collisionEvent = static_cast<const CollisionEvent&>(currentEvent);

            if (collisionEvent.getCollider()->getType() == WALL_UNIT_TYPE)
            {
                mDead = true;
            }

            if (collisionEvent.getCollider()->getType() == SNAKE_BODY_UNIT_TYPE)
            {
                if (mSnakeStorage.size() > 2) //check to make sure there is a first and second body segment
                {
                    SnakeUnit* otherCollider = static_cast<SnakeUnit*>(collisionEvent.getCollider());

                    //snake can't collide with first or second body segment or until spawned segments have started moving
                    if (otherCollider != mSnakeStorage[1] && otherCollider != mSnakeStorage[2] && otherCollider->getStartTimer() <= 0)
                    {
                        mDead = true;
                    }
                }
            }

            if (collisionEvent.getCollider()->getType() == FOOD_UNIT_TYPE)
            {
                addSegments(1, true);
            }

            if (collisionEvent.getCollider()->getType() == BONUS_POINTS_UNIT_TYPE)
            {
                addPoints(mFoodValue);
            }
        }
    }
}


void Snake::updateSnake(float timeElapsed)
{

    /// <summary>
    /// ///////////////////////////  NEED TO TIME LOOP SO NOT TIED TO FRAME RATE ///////////////////////////
    /// </summary>

    for (unsigned int i =  0; i < mSnakeStorage.size(); i++)
    {
        SnakeUnit* currentSegment = mSnakeStorage[i];

        currentSegment->changePosition(currentSegment->getPosition() + (currentSegment->getDirection() * mSnakeSpeed));

        //snap x and y position when in line behind a segment
        if (i > 0)
        {
            Vector2D thisDirection = mSnakeStorage[i]->getDirection();
            Vector2D otherDirection = mSnakeStorage[i - 1]->getDirection();

            Vector2D thisPosition = mSnakeStorage[i]->getPosition();
            Vector2D otherPosition = mSnakeStorage[i - 1]->getPosition();

            //make sure unit ahead of current is going same direction and current unit is not slated to turn (otherwise they all line up instead of turning)
            if (thisDirection == otherDirection && mSnakeStorage[i]->getTurnListSize() == mSnakeStorage[i - 1]->getTurnListSize() && mSnakeStorage[i]->getStartTimer() <= 0) 
            {
                if (abs(thisDirection.getX()) == 1) //moving right or left
                {
                    mSnakeStorage[i]->changePosition(Vector2D(otherPosition.getX() - (mpBodyBuffer->getWidth() * thisDirection.getX()), abs(thisDirection.getX()) * otherPosition.getY()));
                }
                else if (abs(thisDirection.getY()) == 1)//moving up or down
                {
                    mSnakeStorage[i]->changePosition(Vector2D(abs(thisDirection.getY()) * otherPosition.getX(), otherPosition.getY() - (mpBodyBuffer->getHeight() * thisDirection.getY())));
                }
                
            }
        }
    }

    if (mSnakeStorage.size() >= mEndSegmentNum)
    {
        mpEventSystem->fireEvent(EndLevelEvent(true));
    }

    mpEventSystem->fireEvent(ScoreEvent(mScore));
}


void Snake::addSegments(unsigned int count, bool usePoints)
{
    SnakeUnit* lastUnit = getSnakeTail();

    for (unsigned int i = 0; i < count; i++)
    {
        float framesAcross = (mpBodyBuffer->getWidth() / mSnakeSpeed); //how many frames it takes for body to move its length

        if (mSnakeStorage.size() < 2)
        {
            framesAcross = (mpHeadBuffer->getWidth() / mSnakeSpeed);
        }

        //frames until start moving, based on start timer of last segment to get timing of movement starts right
        float startTimer = mSnakeStorage[mSnakeStorage.size() - 1]->getStartTimer() + framesAcross; 

        SnakeUnit* newUnit = new SnakeUnit(getSnakeTail()->getDirection(), getSnakeTail()->getPosition(), mpBodyBuffer, DEFAULT_FPS, startTimer, framesAcross, true, SNAKE_BODY_UNIT_TYPE);
        
        if (lastUnit->getDirection() != Vector2D(0, 0))
        {
            newUnit->addTurn(lastUnit->getDirection(), i);
        }
        newUnit->syncTurnList(lastUnit, i + 1); //add turn list of last unit to the new unit


        mSnakeStorage.push_back(newUnit);

        mpEventSystem->fireEvent(SpawnSnakeEvent(newUnit));
    }
    
    if (usePoints)
    {
        addPoints(count * mFoodValue);
    }
}


void Snake::addPoints(unsigned int count)
{
    mScore += count;
}


void Snake::clearSnake()
{
    mSnakeStorage.clear();
}


void Snake::resetSnake()
{
    mDead = false;

    SnakeUnit* snakeHead = new SnakeUnit(mInitialDirection, mInitialSpawnLocation, mpHeadBuffer, DEFAULT_FPS, 0, 0, true, SNAKE_HEAD_UNIT_TYPE);
    mSnakeStorage.push_back(snakeHead);
    mpEventSystem->fireEvent(SpawnSnakeEvent(snakeHead));

    addSegments(mStartSegmentNum - 1, false);
}


void Snake::startNewLevel(float snakeSpeed, unsigned int startSegments, unsigned int endSegments, int foodValue)
{
    mBaseSnakeSpeed = snakeSpeed;
    mSnakeSpeed = snakeSpeed;
    mStartSegmentNum = startSegments;
    mScore = 0;
    mEndSegmentNum = endSegments;
    mFoodValue = foodValue;

    resetSnake();
}
