/*******************************************************
* Author: Aven Presseisen
* Class: GPR-250-02
* Assignment: Assignment 1
* Certification of Authenticity:
* I certify that this assignment is entirely my own work.
************/

#include <string>

#include <PerformanceTracker.h>
#include <MemoryTracker.h>
#include <Timer.h>

#include "GraphicsSystem.h"
#include "Color.h"

using namespace std;

int main()
{
	PerformanceTracker * pPerformanceTracker = new PerformanceTracker;

	const string INIT_TRACKER_NAME = "init";
	const string DRAW_TRACKER_NAME = "draw";
	const string WAIT_TRACKER_NAME = "wait";

	const int DISP_WIDTH = 800;
	const int DISP_HEIGHT = 600;

	const string ASSET_PATH = "..\\..\\common\\assets\\";
	const string QUIMBY_FILENAME = "mayor_quimby.png";
	const string FONT_FILENAME = "cour.ttf";
	const string STEPS_FILENAME = "steps.png";
	const string SMURF_FILENAME = "smurf_sprites.png";
	const int FONT_SIZE = 64;

	// main graphics system
	GraphicsSystem graphicsSystem( DISP_WIDTH, DISP_HEIGHT );

	// main font
	Font font( ( ASSET_PATH + FONT_FILENAME ).c_str(), FONT_SIZE );

	// sprites and buffers
	GraphicsBuffer smurfBuffer( ( ASSET_PATH + SMURF_FILENAME ).c_str() );
	GraphicsBuffer stepsBuffer( ( ASSET_PATH + STEPS_FILENAME ).c_str() );
	GraphicsBuffer redBuffer( DISP_WIDTH, DISP_HEIGHT );
	GraphicsBuffer quimbyBuffer( ( ASSET_PATH + QUIMBY_FILENAME ).c_str() );

	Sprite stepsSprite( stepsBuffer, 0, 0, stepsBuffer.getWidth(), stepsBuffer.getHeight() );
	Sprite redSprite( redBuffer, 0, 0, redBuffer.getWidth(), redBuffer.getHeight() );
	Sprite quimbySprite( quimbyBuffer, 0, 0, quimbyBuffer.getWidth(), quimbyBuffer.getHeight() );

	// clears red buffer to red
	graphicsSystem.clear( redSprite.getGraphicsBuffer(), Color::createColor( 255, 0, 0 ) );

	// draw quimby sprite onto red buffer
	graphicsSystem.draw( redSprite.getGraphicsBuffer(), 0, 0, quimbySprite );

	// write text onto red buffer in middle
	graphicsSystem.writeText( redSprite.getGraphicsBuffer(), DISP_WIDTH / 2, DISP_HEIGHT / 2, font, Color::createColor( 0, 0, 0 ), "Curse you papa smurf!" );

	// draw steps sprite to backbuffer
	graphicsSystem.draw( 0, 0, stepsSprite );

	// draw red buffer at two thirds the size onto backbuffer
	const float TWO_THIRDS = 2.0f / 3.0f;
	graphicsSystem.draw( redSprite.getWidth() * TWO_THIRDS - DISP_WIDTH / 2.0f, redSprite.getHeight() * TWO_THIRDS - DISP_HEIGHT / 2.0f, redSprite, TWO_THIRDS );

	// generate 16 smurfs in random locations
	const int TOTAL_SMURFS = 16;
	const int SMURFS_PER_ROW = 4;
	const int SMURF_STRIDE = 60;
	int row = 0;
	int col = 0;
	vector<Sprite> smurfs;
	for( int i = 0; i < TOTAL_SMURFS; i++ )
	{
		smurfs.push_back( move( Sprite { smurfBuffer, col * SMURF_STRIDE, row * SMURF_STRIDE, SMURF_STRIDE, SMURF_STRIDE } ) );
		int xLoc = rand() % DISP_WIDTH;
		int yLoc = rand() % DISP_HEIGHT;
		graphicsSystem.draw( xLoc, yLoc, smurfs[ i ] );
		if( ++col % SMURFS_PER_ROW == 0 )
		{
			col = 0;
			row++;
		}
	}

	// save backbuffer bitmap to file
	graphicsSystem.saveBuffer( graphicsSystem.getBackBuffer(), "backbuffer.jpg" );

	// save redbuffer to file
	graphicsSystem.saveBuffer( redBuffer, "redbuffer.jpg" );

	// flip backbuffer
	graphicsSystem.flip();

	bool keepRunning = true;
	Timer timer;

	const int SECONDS_TO_SLEEP = 5;
	const double SECONDS_TO_MILLI = 1000.0;
	timer.sleep( SECONDS_TO_SLEEP * SECONDS_TO_MILLI );

	pPerformanceTracker->stopTracking( "loop" );
	//cout << "Frame Took:" << pPerformanceTracker->getElapsedTime("loop") << " ms" << endl;

	pPerformanceTracker->clearTracker( "loop" );

	// Clear display
	graphicsSystem.cleanup();

	delete pPerformanceTracker;

	MemoryTracker::getInstance()->reportAllocations( cout );

	system( "pause" );
	return 0;
}