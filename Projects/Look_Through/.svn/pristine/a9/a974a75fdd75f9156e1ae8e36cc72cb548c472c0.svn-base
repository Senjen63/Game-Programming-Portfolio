#include "Unit.h"
#include "Game.h"

Unit::Unit()
{
    mPos = Vector2D(DEFAULT_X, DEFAULT_Y);
    mFps = DEFAULT_FPS;
    mTimeScale = Game::getGame()->getTimeScale();
    mTimePerFrame = *mTimeScale / mFps;
    mType = DEFAULT_UNIT_TYPE;

    mPhysics = PhysicsComponent(this, *mTimeScale / mFps, false, false);

    init();
}


Unit::Unit(Vector2D pos, int fps, bool physicsActive, bool gravityActive, bool physicsColliderActive)
{
    mFps = fps;
    mTimeScale = Game::getGame()->getTimeScale();
    mTimePerFrame = *mTimeScale / mFps;
    mPos = pos;
    mType = DEFAULT_UNIT_TYPE;
    mPhysicsColliderActive = physicsColliderActive;

    mPhysics = PhysicsComponent(this, *mTimeScale / mFps, physicsActive, gravityActive);

    init();
}


Unit::Unit(Vector2D pos, AnimationFrames* anim, int fps, bool loopAnimation, int type, bool physicsActive, bool gravityActive, bool physicsColliderActive)
{
    mPos = pos;
    mFps = fps;
    mTimeScale = Game::getGame()->getTimeScale();
    mTimePerFrame = *mTimeScale / mFps;
    addAnimation(anim, fps, loopAnimation);
    mType = type;
    mPhysicsColliderActive = physicsColliderActive;

    mPhysics = PhysicsComponent(this, *mTimeScale / mFps, physicsActive, gravityActive);

    init();
}


Unit::~Unit()
{

}


void Unit::init()
{
    mpGraphicsSystem = Game::getGame()->getGraphicsSystem();
    mpEventSystem = EventSystem::getInstance();

    //add action event if player unit
    //if (mType == UnitTypes::PLAYER_UNIT_TYPE)
    //{
        mPhysics.init();
        mpEventSystem->addListener((EventType)ACTION_GAME_EVENT, this);
    //}
}


int Unit::getAnimCount()
{
    return mAnims.size();
}


int Unit::getCurrentIndex() 
{
    return mCurrentIndex;
}


int Unit::getCurrentFrameIndex()
{
    return mAnims[mCurrentIndex].getCurrentFrame();
}


bool Unit::getIsPlaying()
{
    return mPlay;
}


Vector2D Unit::getPosition()
{
    return mPos;
}


Vector2D Unit::getDimensions()
{
    //dimensions change when rotated to match what's on screen
    Vector2D dimensions = Vector2D(
        abs((cos(mAngle * (3.14159f / 180)) * mAnims[mCurrentIndex].getCurrentSprite().getWidthHeight().getX()) +
        (sin(mAngle * (3.14159f / 180)) * mAnims[mCurrentIndex].getCurrentSprite().getWidthHeight().getY())),

        abs((sin(mAngle * (3.14159f / 180)) * mAnims[mCurrentIndex].getCurrentSprite().getWidthHeight().getX()) +
        (cos(mAngle * (3.14159f / 180)) * mAnims[mCurrentIndex].getCurrentSprite().getWidthHeight().getY())));

    return dimensions;
}


bool Unit::getDelete()
{
    return mDelete;
}


int Unit::getType()
{
    return mType;
}


int Unit::getFps()
{
    return mFps;
}


float Unit::getTimeScale()
{
    return *mTimeScale;
}


float Unit::getFrameCount()
{
    return mAnims[mCurrentIndex].getFrameTotal();
}


bool Unit::getPhysicsColliderActive()
{
    return mPhysicsColliderActive;
}


float Unit::getAngle()
{
    return mAngle;
}


void Unit::setDelete(bool del)
{
    mDelete = del;
}


void Unit::setType(int type)
{
    mType = type;
}


void Unit::setPosition(Vector2D pos)
{
    mPos = pos;
}


void Unit::setPhysicsColliderActive(bool active)
{
    mPhysicsColliderActive = active;
}


void Unit::setAngle(float angle)
{
    mAngle = angle;
}


void Unit::update(float timeElapsed)
{
    mPhysics.update(timeElapsed);

    if (mAnims.size() > 0 && mPlay)
    {
        mAnims[mCurrentIndex].update(timeElapsed);
    }
}


void Unit::draw()
{
    if (mAnims.size() > 0)
    {
        //Vector2D offset = Vector2D(mAnims[mCurrentIndex].getCurrentSprite().getWidthHeight()) / 2;
        
        //positions are centered regardless of rotation
        //Vector2D offset = Vector2D(
            //(cos(mAngle) * mAnims[mCurrentIndex].getCurrentSprite().getWidthHeight().getX()) +
            //(sin(mAngle) * mAnims[mCurrentIndex].getCurrentSprite().getWidthHeight().getY()),

            //(sin(mAngle) * mAnims[mCurrentIndex].getCurrentSprite().getWidthHeight().getX()) +
            //(cos(mAngle) * mAnims[mCurrentIndex].getCurrentSprite().getWidthHeight().getY())) / 2;
        //Vector2D pos = mPos - offset;
        //mpGraphicsSystem->draw(pos.getX(), pos.getY(), mAnims[mCurrentIndex].getCurrentSprite(), 1, 1, mAngle);
        mpGraphicsSystem->draw(mPos.getX(), mPos.getY(), mAnims[mCurrentIndex].getCurrentSprite(), 1, 1, mAngle);
    }
}


void Unit::changePosition(Vector2D newPos)
{
    mPos = newPos;
}


void Unit::addAnimation(AnimationFrames* anim)
{
    Animation newAnim = Animation(anim, mFps, DEFAULT_LOOP);
    mAnims.push_back(newAnim);
}


void Unit::addAnimation(AnimationFrames* anim, int fps, bool loop)
{
    Animation newAnim = Animation(anim, fps, loop);
    mAnims.push_back(newAnim);
}


void Unit::setAnimation(int index)
{
    mAnims[index].sync(mAnims[mCurrentIndex]);
    mCurrentIndex = index;
    setFps(mFps);
}


void Unit::setFps(int fps)
{
    mFps = fps;
    if (mAnims.size() > 0)
    {
        mAnims[mCurrentIndex].changeSpeed(fps);
    }
}


void Unit::togglePlay(bool play)
{
    mPlay = play;
}


bool Unit::isMouseOver(Vector2D mousePos)
{
    float xDist = abs(mPos.getX() - mousePos.getX());
    float yDist = abs(mPos.getY() - mousePos.getY());

    float xRadius = getDimensions().getX() / 2;
    float yRadius = getDimensions().getY() / 2;
    
    if (xDist <= xRadius && yDist <= yRadius)
    {
        return true;
    }

    return false;
}