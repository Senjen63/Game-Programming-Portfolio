#include "Game.h"
#include "Player.h"
#include "RandomlyMovingEnemy.h"
#include "SceneManager.h"
#include "AudioManager.h"
#include "ChasingEnemy.h"
#include "RandomlyMovingEnemy.h"

Game* Game::mpsGame = nullptr;

Game::Game(float displayWidth, float displayHeight)
{
	mpGraphicsSystem = new GraphicsSystem("Game", displayWidth, displayHeight);
	mpInputSystem = new InputSystem();
	mpMenuManager = new MenuManager();
	mpSceneManager = new SceneManager();
	mpAudioManager = new AudioManager();

	EventSystem* pEventSystem = EventSystem::getInstance();
	pEventSystem->addListener((EventType)INPUT_EVENT, this);
}

Game::~Game()
{

}

void Game::createInstance(float displayWidth, float displayHeight)
{
	mpsGame = new Game(displayWidth, displayHeight);
}

void Game::deleteInstance()
{
	delete(mpsGame);
	mpsGame = nullptr;
}

void Game::init()
{
	SDL_Init(SDL_INIT_EVERYTHING);
	TTF_Init();
	Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048);
}

void Game::clean()
{
	delete(mpAudioManager);
	delete(mpSceneManager);
	delete(mpMenuManager);
	delete(mpInputSystem);
	delete(mpGraphicsSystem);
	TTF_Quit();
	SDL_Quit();
}

Game* Game::getGame()
{
	return mpsGame;
}


void Game::saveGame()
{
	std::ofstream saveData;
	saveData.open("Assets/SaveData.txt");
	WaveManager* waveManager = mpSceneManager->getWaveManager();

	saveData << mpSceneManager->getCurrentScene() << endl;
	saveData << waveManager->getCurrentWave() << endl;
	saveData << waveManager->getEndWave() << endl;
	saveData << waveManager->getWaveProgress() << endl;
	saveData << waveManager->getWaveGoal() << endl << endl;

	std::vector<Unit*> sceneManagerVector = mpSceneManager->getUnitVector();

	for (int i = 0; i < sceneManagerVector.size(); i++)
	{
		if (dynamic_cast<Player*>(sceneManagerVector[i]) != nullptr)
		{
			Player* player = dynamic_cast<Player*>(sceneManagerVector[i]);
			saveData << "Player" << endl;
			saveData << player->getLocation().first << endl;
			saveData << player->getLocation().second << endl;
			saveData << player->getHealth() << endl;
			saveData << player->getScore() << endl << endl;
		}

		else if (dynamic_cast<ChasingEnemy*>(sceneManagerVector[i]) != nullptr)
		{
			ChasingEnemy* enemy = dynamic_cast<ChasingEnemy*>(sceneManagerVector[i]);
			saveData << "ChasingEnemy" << endl;
			saveData << enemy->getLocation().first << endl;
			saveData << enemy->getLocation().second << endl;
			saveData << enemy->getHealth() << endl;
			saveData << enemy->getDamage() << endl;
			saveData << enemy->getMoveSpeed() << endl << endl;
		}

		else if (dynamic_cast<RandomlyMovingEnemy*>(sceneManagerVector[i]) != nullptr)
		{
			RandomlyMovingEnemy* enemy = dynamic_cast<RandomlyMovingEnemy*>(sceneManagerVector[i]);
			saveData << "RandomlyMovingEnemy" << endl;
			saveData << enemy->getLocation().first << endl;
			saveData << enemy->getLocation().second << endl;
			saveData << enemy->getHealth() << endl;
			saveData << enemy->getDamage() << endl;
			saveData << enemy->getMoveSpeed() << endl;
			saveData << enemy->getTimeToUpdate() << endl << endl;
		}
	}

	saveData.close();
}

void Game::loadGame()
{
	// reminder to update the values corresponding to the player spawned by loadscene instead of creating a new one
	std::ifstream saveData;
	saveData.open("Assets/SaveData.txt");

	std::string currentLine;
	std::string trash;

	std::string sceneName;
	std::string currentWave;
	std::string lastWave;
	std::string waveProgress;
	std::string waveGoal;

	std::getline(saveData, sceneName);
	std::getline(saveData, currentWave);
	std::getline(saveData, lastWave);
	std::getline(saveData, waveProgress);
	std::getline(saveData, waveGoal);

	// Default to LevelData if the file can't be found
	std::ifstream test(sceneName.c_str());
	if (!test.good())
	{
		mpSceneManager->loadScene("Assets/LevelData.txt");
		return;
	}
	test.close();

	mpSceneManager->loadScene(sceneName);
	WaveManager* waveManager = mpSceneManager->getWaveManager();
	waveManager->updateCurrentWave(std::stoi(currentWave));
	waveManager->updateLastWave(std::stoi(lastWave));
	waveManager->updateWaveProgress(std::stoi(waveProgress) - 1);
	waveManager->updateWaveGoal(std::stoi(waveGoal));

	while (!saveData.eof())
	{
		std::getline(saveData, currentLine);

		if (currentLine == "Player")
		{
			std::string playerPosX;
			std::string playerPosY;
			std::string playerHealth;
			std::string playerScore;

			std::getline(saveData, playerPosX);
			std::getline(saveData, playerPosY);
			std::getline(saveData, playerHealth);
			std::getline(saveData, playerScore);

			std::pair<int, int>playerPos = make_pair(stoi(playerPosX), stoi(playerPosY));

			Player* player = mpSceneManager->getPlayer();
			player->updateLocation(playerPos);
			player->setHealth(stoi(playerHealth));
			player->updateHealth(0);
			player->updateScore(stoi(playerScore));
		}

		if (currentLine == "ChasingEnemy")
		{
			std::string enemyPosX;
			std::string enemyPosY;
			std::string enemyHealth;
			std::string enemyDamage;
			std::string enemyMoveSpeed;

			std::getline(saveData, enemyPosX);
			std::getline(saveData, enemyPosY);
			std::getline(saveData, enemyHealth);
			std::getline(saveData, enemyDamage);
			std::getline(saveData, enemyMoveSpeed);

			std::pair<int, int>enemyPos = make_pair(stoi(enemyPosX), stoi(enemyPosY));

			ChasingEnemy* newEnemy = new ChasingEnemy(enemyPos, make_pair(3, 3), stoi(enemyHealth), stoi(enemyDamage), stoi(enemyMoveSpeed), "Assets/ChasingEnemyAnimationData.txt");
			mpSceneManager->addEnemy(newEnemy);
		}

		if (currentLine == "RandomlyMovingEnemy")
		{
			std::string enemyPosX;
			std::string enemyPosY;
			std::string enemyHealth;
			std::string enemyDamage;
			std::string enemyMoveSpeed;
			std::string enemyUpdateTime;

			std::getline(saveData, enemyPosX);
			std::getline(saveData, enemyPosY);
			std::getline(saveData, enemyHealth);
			std::getline(saveData, enemyDamage);
			std::getline(saveData, enemyMoveSpeed);
			std::getline(saveData, enemyUpdateTime);

			std::pair<int, int>enemyPos = make_pair(stoi(enemyPosX), stoi(enemyPosY));

			RandomlyMovingEnemy* newEnemy = new RandomlyMovingEnemy(enemyPos, make_pair(3, 3), stoi(enemyHealth), stoi(enemyDamage), stoi(enemyMoveSpeed), "Assets/RandomlyMovingEnemyAnimationData.txt", stoi(enemyUpdateTime));
			mpSceneManager->addEnemy(newEnemy);
		}
	}

	saveData.close();
}

void Game::handleEvent(const Event& theEvent)
{
	if (theEvent.getType() == INPUT_EVENT)
	{
		const InputEvent& inputEvent = static_cast<const InputEvent&>(theEvent);

		if (inputEvent.getInputType() == ESCAPE_PRESSED)
		{
			continueLoop = false;
		}
	}
}

void Game::doLoop()
{
	srand(time(NULL));

	double targetFPS = 60;
	double targetTimeMS = 1000 / targetFPS;
	double currentTimeMS = targetTimeMS;

	mpMenuManager->loadMenu("Main Menu");
	mpAudioManager->loadSounds();

	while (continueLoop)
	{
		mpGraphicsSystem->clearRenderer();

		mpInputSystem->update();
		mpSceneManager->updateAll(currentTimeMS);
		mpMenuManager->updateAll(currentTimeMS);

		mpSceneManager->drawAll(mpGraphicsSystem);
		mpMenuManager->drawAll(mpGraphicsSystem);

		mpGraphicsSystem->flipBackBuffer();

		SDL_Delay(currentTimeMS); // replace with abstracted method
	}

	if (mInGame)
	{
		saveGame();
	}
}