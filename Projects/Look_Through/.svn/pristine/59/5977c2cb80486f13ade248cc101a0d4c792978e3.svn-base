#include "UnitManager.h"
#include "Game.h"

UnitManager::UnitManager()
{

}
UnitManager::~UnitManager()
{
    cleanup();
}
void UnitManager::init()
{
    mpEventSystem = EventSystem::getInstance();
}
void UnitManager::cleanup()
{
    clearAll();
}
Unit* UnitManager::getLastUnit()
{
    if (mUnits.size() > 0)
    {
        return mUnits.back();
    }
    
    return nullptr;
}
int UnitManager::getUnitCount()
{
    return mUnits.size();
}
void UnitManager::handleEvent(const Event& currentEvent)
{

}
void UnitManager::addUnit(Unit* unit)
{
    mUnits.push_back(unit);
}
Unit* UnitManager::addUnit(Vector2D pos, int fps)
{
    Unit* newUnit = new Unit(pos, fps);

    mUnits.push_back(newUnit);

    return getLastUnit();
}
Unit* UnitManager::addUnit(Vector2D pos, GraphicsBuffer* newBuffer, int fps, bool loopAnimation, int type)
{
    Unit* newUnit = new Unit(pos, newBuffer, fps, loopAnimation, type);

    mUnits.push_back(newUnit);

    return getLastUnit();
}
void UnitManager::deleteUnit(Unit* unit)
{
    delete unit;

    vector<Unit*>::iterator target = find(mUnits.begin(), mUnits.end(), unit);
    mUnits.erase(target);
}
void UnitManager::deleteUnits(vector<Unit*>* units)
{
    for (unsigned int i = 0; i < units->size(); i++)
    {
        deleteUnit((*units)[i]);
    }
}
void UnitManager::deleteUnitsOfType(int type)
{
    for (unsigned int i = 0; i < mUnits.size(); i++)
    {
        if (mUnits[i]->getType() == type)
        {
            deleteUnit(mUnits[i]);
            i--;
        }
    }
}
void UnitManager::deleteUnitsAtPosition(Vector2D mousePosition)
{
    for (int i = mUnits.size() - 1; i >= 0; i--) //delete last unit first
    {
        if (mUnits[i]->isMouseOver(mousePosition))
        {
            delete mUnits[i];

            mUnits.erase(mUnits.begin() + i);
        }
    }
}
void UnitManager::clearAll()
{
    for (unsigned int i = 0; i < mUnits.size(); i++)
    {
        delete mUnits[i];
    }

    mUnits.clear();
}
void UnitManager::nextAnimationForLastUnit()
{
    int nextIndex = getLastUnit()->getCurrentIndex() + 1;

    if (nextIndex >= getLastUnit()->getAnimCount())
    {
        nextIndex = 0;
    }

    getLastUnit()->setAnimation(nextIndex);
}
void UnitManager::setAllPlay(bool play)
{
    for (unsigned int i = 0; i < mUnits.size(); i++)
    {
        Unit* current = mUnits[i];
        current->togglePlay(play);
    }
}
void UnitManager::switchAllPlay()
{
    for (unsigned int i = 0; i < mUnits.size(); i++)
    {
        Unit* current = mUnits[i];
        current->togglePlay(!current->getIsPlaying());
    }
}
vector<Unit*> UnitManager::checkAnyCollisions(Unit* checkUnit)
{
    vector<Unit*> collided;

    for (auto other : mUnits)
    {
        if (other != nullptr)
        {
            if (other != checkUnit && !other->getDelete())
            {
                float xDist = abs(other->getLocation().getX() - checkUnit->getLocation().getX());
                float yDist = abs(other->getLocation().getY() - checkUnit->getLocation().getY());

                float otherXRadius = other->getDimensions().getX() / 2;
                float otherYRadius = other->getDimensions().getY() / 2;
                float thisXRadius = checkUnit->getDimensions().getX() / 2;
                float thisYRadius = checkUnit->getDimensions().getY() / 2;

                if ((xDist <= otherXRadius + thisXRadius) && (yDist <= otherYRadius + thisYRadius))
                {
                    collided.push_back(other);

                    mpEventSystem->fireEvent(CollisionEvent(checkUnit, other));
                }
            }
        }
        else
        {

        }
    }

    return collided;
}
vector<Unit*> UnitManager::checkCollisionOfType(Unit* checkUnit, int type)
{
    vector<Unit*> collided;

    for (auto other : mUnits)
    {
        if (other != nullptr)
        {
            if (other != checkUnit && other->getType() == type && !other->getDelete())
            {
                float xDist = abs(other->getLocation().getX() - checkUnit->getLocation().getX());
                float yDist = abs(other->getLocation().getY() - checkUnit->getLocation().getY());

                float otherXRadius = other->getDimensions().getX() / 2;
                float otherYRadius = other->getDimensions().getY() / 2;
                float thisXRadius = checkUnit->getDimensions().getX() / 2;
                float thisYRadius = checkUnit->getDimensions().getY() / 2;

                if ((xDist <= otherXRadius + thisXRadius) && (yDist <= otherYRadius + thisYRadius))
                {
                    collided.push_back(other);
                }
            }
        }
        else
        {

        }
    }

    return collided;
}
vector<Unit*> UnitManager:: checkCollisionInArea(Vector2D pos, float xDiameter, float yDiameter)
{
    vector<Unit*> collided;

    float areaXRadius = xDiameter / 2;
    float areaYRadius = yDiameter / 2;

    for (auto other : mUnits)
    {
        if (other != nullptr)
        {
            if (!other->getDelete())
            {
                float xDist = abs(other->getLocation().getX() - pos.getX());
                float yDist = abs(other->getLocation().getY() - pos.getY());

                float otherXRadius = other->getDimensions().getX() / 2;
                float otherYRadius = other->getDimensions().getY() / 2;

                if ((xDist <= otherXRadius + areaXRadius) && (yDist <= otherYRadius + areaYRadius))
                {
                    collided.push_back(other);
                }
            }
        }
        else
        {

        }
        
    }

    return collided;
}
void UnitManager::updateAll(float elapsedTime)
{
    for (int i = mUnits.size() - 1; i >= 0; i--)
    {
        if (mUnits[i]->getDelete()) //delete flagged units
        {
            deleteUnit(mUnits[i]); 
        }
        else
        {
            mUnits[i]->update(elapsedTime);
        }
    }
}
void UnitManager::drawAll()
{
    for (int i = mUnits.size() - 1; i >= 0; i--) //draw last item first, appears lower in rendering order
    {
        mUnits[i]->draw();
    }
}
Unit* UnitManager::clickedUnit(Vector2D mousePos)
{
    for (int i = mUnits.size() - 1; i >= 0; i--) //delete last unit first
    {
        if (mUnits[i]->isMouseOver(mousePos))
        {
            return mUnits[i];
        }
    }

    return nullptr;
}
vector<Unit*>* UnitManager::clickedUnits(Vector2D mousePos)
{
    vector<Unit*>* units = new vector<Unit*>;

    for (unsigned int i = 0; i < mUnits.size(); i++)
    {
        if (mUnits[i]->isMouseOver(mousePos))
        {
            units->push_back(mUnits[i]);
        }
    }

    return units;
}