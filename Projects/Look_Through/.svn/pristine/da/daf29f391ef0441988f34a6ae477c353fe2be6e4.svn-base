#include "Animation.h"

Animation::Animation(double speed, bool isLooping)
{
	mSpeed = speed;
	mIsLooping = isLooping;
	mSpritesToUse = {};
	mCurrentFrame = 0;
	mTimeInFrame = 0;
}

Animation::Animation(const Animation &anim)
{
	mSpeed = anim.mSpeed;
	mIsLooping = anim.mIsLooping;
	mSpritesToUse = anim.mSpritesToUse;

	mCurrentFrame = 0;
	mTimeInFrame = 0;
}

Animation::~Animation()
{

}

void Animation::update(float elapsedTime)
{
	if (!mIsRunning) { return; }

	mTimeInFrame += mSpeed * elapsedTime;

	int framesToProgress = (int)mTimeInFrame; //if mSpeed > 1, determine how many frames to jump ahead

	mTimeInFrame -= framesToProgress;
	mCurrentFrame += framesToProgress;

	if (size_t(mCurrentFrame) >= mSpritesToUse.size()) { 
		if (mIsLooping) 
		{ 
			/*determine "bonus" frames (e.g. in a 10-frame animation, speed 3, jump from frame 9 -> frame 2)
			
			what I'm doing here with the conversion to int is rounding it down to the nearest N, where N = size of the vector
			this solution is kinda janky but it's efficient and C++ doesn't come with a function to do this as far as I know
			*/
			mCurrentFrame -= int(mCurrentFrame / mSpritesToUse.size()) * mSpritesToUse.size();
		}
		else 
		{ 
			mCurrentFrame = mSpritesToUse.size() - 1;
			mSpeed = 0;
		}
	}
}