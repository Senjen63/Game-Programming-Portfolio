#include "Animation.h"

#include "MathHelp.h"

Animation::Animation(const std::vector<Sprite>& sprites, float frameRate, bool loops) :
    mSprites(sprites),
    mFrameRate(frameRate),
    mLoops(loops)
{}

Animation::Animation(GraphicsBuffer* pSpriteSheetBuffer, float frameRate, int spriteWidth, int spriteHeight, int numSprites, int sheetWidth, int sheetHeight, Vector2D sheetStart, bool loops)
    : mLoops(loops), mFrameRate(frameRate)
{
    mSprites = Sprite::slice(pSpriteSheetBuffer, spriteWidth, spriteHeight, numSprites, sheetWidth, sheetHeight, sheetStart);
}

Animation::Animation(Sprite sprite) :
    mFrameRate(1), mLoops(false)
{
    mSprites.push_back(sprite);
}

void Animation::update(double deltaTime)
{
    // Scale to to be amount of frames past: 
    // multiply it by 1/1000 to go from ms to sec then 
    // multiply it by the framerate to get from seconds to number of frames 
    mFramesPast += deltaTime * 0.001 * mFrameRate;
}

Vector2D Animation::getMaxSize() const
{
    int xSize = 0;
    int ySize = 0;
    for (const Sprite& sprite : mSprites)
    {
        xSize = max(xSize, sprite.getWidth());
        ySize = max(ySize, sprite.getHeight());
    }
    return Vector2D(xSize, ySize);
}

const Sprite& Animation::getCurrentSprite() const
{
    // Return last sprite when done and not looping 
    if (!mLoops && (int)mFramesPast >= (int)mSprites.size())
        return mSprites[mSprites.size() - 1];

    // modulus to wrap when it exceeds the number of frames 
    return mSprites[(int)mFramesPast % mSprites.size()];
}
