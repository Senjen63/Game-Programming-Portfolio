/*
Author: David Silverman
Class: GPR-250-01
Assignment: Assignment 3
Certification of Authenticity:
I certify that this assignment is entirely my own work.
 */


#pragma once
#include "game.h"
#include "snakemanager.h"
#include "gameevent.h"
#include <Event.h>
#include <EventSystem.h>
#include "collision.h"
#include "escape.h"
#include "food.h"
#include "fps.h"
#include "message.h"
#include "move.h"
#include "power.h"
#include "score.h"
#include "grow.h"
#include "victory.h"

using namespace std;

Game* Game::mpsGame = nullptr;


/* Pre:  Nothing
*  Post:  A game
*  Purpose:  Create the game
*********************************************************/
Game::Game()
{

}

/* Pre:  The game
*  Post:  Nothing
*  Purpose:  Destroy the game
*********************************************************/
Game::~Game()
{

}

/* Pre:  The Game
*  Post:  The Game
*  Purpose:  Initialize the game
*********************************************************/
void Game::Init()
{
	EventSystem::initInstance();
	mpGraphics = new GraphicsSystem;
	mpInput = new InputSystem;
	mpUnits = new SnakeManager;
	mpWall = new WallManager;
	mpFood = new FoodManager;
	mpPower = new PowerUpManager;
	mpGBuffers = new GraphicsBufferManager;
	mpEventSystem = EventSystem::getInstance();
	mpScore = new int;
	mpLevelNum = new int;
	mpEventSystem->init();
	mpCollided = new bool;
	mPaused = true;

	mpGraphics->Init(DISPLAY_WIDTH, DISPLAY_HEIGHT);
	mpInput->Init();
	loadData(DATA);

	mpGBuffers->addBuffer(mHeadFilename, SMARF, SMARF);
	mpGBuffers->addBuffer(mBodyFilename, SMARF, SMARF);
	mpGBuffers->addBuffer(mTailFilename, SMARF, SMARF);
	mpGBuffers->addBuffer(mWallFilename, SMARF, SMARF);
	mpGBuffers->addBuffer(mFoodFilename, SMARF, SMARF);
	mpGBuffers->addBuffer(mPowerFilename, SMARF, SMARF);

	mpGBuffers->addBuffer(mBackgroundFilename1, mLevelHeight1, mLevelWidth1);
	mpGBuffers->addBuffer(mBackgroundFilename2, mLevelHeight2, mLevelWidth2);
	mpGBuffers->addBuffer(mBackgroundFilename3, mLevelHeight3, mLevelWidth3);
	
	mpSmurfAnimation = new Animation(mpGBuffers->getBuffer(SMURF_FILENAME), LEVEL_ONE, LEVEL_ONE, SMARF, SMARF, SIXTY_FRAMES);
	mpDeanAnimation = new Animation(mpGBuffers->getBuffer(DEAN_FILENAME), LEVEL_ONE, LEVEL_ONE, SMARF, SMARF, SIXTY_FRAMES);
	mpTailAnimation = new Animation(mpGBuffers->getBuffer(mTailFilename), LEVEL_ONE, LEVEL_ONE, SMARF, SMARF, SIXTY_FRAMES);
	mpWallAnimation = new Animation(mpGBuffers->getBuffer(mWallFilename), LEVEL_ONE, LEVEL_ONE, SMARF, SMARF, SIXTY_FRAMES);
	mpFoodAnimation = new Animation(mpGBuffers->getBuffer(mFoodFilename), SMURFS, SMURFS, FEED, FEED, SIXTY_FRAMES);
	mpPowerAnimation = new Animation(mpGBuffers->getBuffer(mPowerFilename), SMURFS, SMURFS, FEED, FEED, SIXTY_FRAMES);

	mpBackground = new Sprite(TOP_LEFT, mLevelHeight1, mLevelWidth1, mpGBuffers->getBuffer(mBackgroundFilename1));
	mpBackground2 = new Sprite(TOP_LEFT, mLevelHeight2, mLevelWidth2, mpGBuffers->getBuffer(mBackgroundFilename2));
	mpBackground3 = new Sprite(TOP_LEFT, mLevelHeight3, mLevelWidth3, mpGBuffers->getBuffer(mBackgroundFilename3));

	mpUnits->setAnimations(mpSmurfAnimation, mpDeanAnimation, mpTailAnimation);
	mpWall->setAnimations(mpWallAnimation, mpWallAnimation);
	mpFood->setAnimations(mpFoodAnimation, mpFoodAnimation);
	mpPower->setAnimations(mpPowerAnimation, mpPowerAnimation);


	mLevMan.addLevel(mpGBuffers, mBackgroundFilename1, mRows1, mColumns1, mRequiredScore1, mRate1, mSpeed1, mRequiredScore1, mScore1, mBackgroundFilename1, mScale1);
	mLevMan.addLevel(mpGBuffers, mBackgroundFilename2, mRows2, mColumns2, mRequiredScore2, mRate2, mSpeed2, mRequiredScore2, mScore2, mBackgroundFilename2, mScale2);
	mLevMan.addLevel(mpGBuffers, mBackgroundFilename3, mRows3, mColumns3, mRequiredScore3, mRate3, mSpeed3, mRequiredScore3, mScore3, mBackgroundFilename3, mScale3);

	mpCurrentLevel = mLevMan.getLevel(mBackgroundFilename1);

	mRate = RATE;
	mpPerformanceTracker = new PerformanceTracker;

	EventSystem* pEventSystem = EventSystem::getInstance();
	pEventSystem->addListener((EventType)COLLISION, this);
	pEventSystem->addListener((EventType)MOVE, this);
	pEventSystem->addListener((EventType)ESCAPE, this);
	pEventSystem->addListener((EventType)FOOD, this);
	pEventSystem->addListener((EventType)SCORE, this);
	pEventSystem->addListener((EventType)EAT, this);
	pEventSystem->addListener((EventType)FRAME, this);
	pEventSystem->addListener((EventType)BUTTON, this);
	pEventSystem->addListener((EventType)MOUSE, this);
	pEventSystem->addListener((EventType)GROW, this);
	pEventSystem->addListener((EventType)MOUSE, this);
	pEventSystem->addListener((EventType)POWERUP, this);
	pEventSystem->addListener((EventType)TEXT, this);
	pEventSystem->addListener((EventType)VICTORY, this);

	mpUnits->AddNewUnit(mpCurrentLevel->getStartingPosition());
	mpUnits->AddNewUnit(mpCurrentLevel->getStartingPosition());
	mpUnits->AddNewUnit(mpCurrentLevel->getStartingPosition());

	mpCurrentLevel->PlaceSnake();

	for (int i = 0; i < mLWalls1.size(); i++)
	{
		mpWall->AddNewUnit(ORIGIN);
	}
	
	mpCurrentLevel->PlaceWalls(mpWall, mLWalls1);
	*mpScore = 0;
	*mpLevelNum = 1;

	mRunning = true;
	mpScript = new Font();
}

/* Pre:  The game
*  Post:  The game
*  Purpose:  Destroy the game's pointers
*********************************************************/
void Game::Cleanup()
{
	delete mpPerformanceTracker;
	delete mpSmurfAnimation;
	delete mpDeanAnimation;
	delete mpTailAnimation;
	delete mpWallAnimation;
	delete mpPowerAnimation;
	delete mpFoodAnimation;
	delete mpBackground;
	delete mpBackground2;
	delete mpBackground3;
	delete mpFirstLevel;
	delete mpSecondLevel;
	delete mpThirdLevel;
	mpGraphics->Cleanup();
	mpInput->Cleanup();
	mpUnits->Cleanup();
	mpWall->Cleanup();
	mpPower->Cleanup();
	mpFood->Cleanup();
	mpGBuffers->Cleanup();
	mLevMan.Cleanup();
	delete mpGraphics;
	delete mpInput;
	delete mpUnits;
	delete mpWall;
	delete mpPower;
	delete mpFood;
	delete mpGBuffers;
	delete mpLevelNum;
	delete mpScore;
	delete mpFPS;
	delete mpContinue;
	delete mpScript;
	//al_destroy_event_queue(mpQueue);
}

/* Pre:  The game
*  Post:  Animation
*  Purpose:  Draw the game
*********************************************************/
void Game::doLoop()
{
	while (mRunning)
	{
		Timer loopTimer;
		loopTimer.start();

		mpPerformanceTracker->clearTracker("mpPerformanceTracker");
		mpPerformanceTracker->startTracking("mpPerformanceTracker");

		mpInput->getKeyState();

		mpGraphics->Draw(TOP_LEFT, displayCurrent(), mpCurrentLevel->getScale().getX(), mpCurrentLevel->getScale().getX());

		mpFood->drawAll(mpCurrentLevel->getScale(), true);
		mpPower->drawAll(mpCurrentLevel->getScale(), true);
		mpWall->drawAll(mpCurrentLevel->getScale(), true);
		mpUnits->drawAll(mpCurrentLevel->getScale(), false);
		mHud.drawHUD(1000.0f / mFrameRate, *mpScore);
		
		if(mPaused)
			mpEventSystem->fireEvent(Message(HERE + to_string(*mpLevelNum) + PLACE + PLAY));

		if (mHit)
			mpEventSystem->fireEvent(Message(RESTART));

		mpGraphics->Flip();

		if (mPaused == false && mHit == false)
		{
			mpCurrentLevel->CheckSnake(mpUnits, SIXTY_FRAMES, mpCurrentLevel->getScale());

			mpUnits->updateAll(mpCurrentLevel, SIXTY_FRAMES, mDirection);
			mpFood->updateAll(SIXTY_FRAMES);
			mpPower->updateAll(SIXTY_FRAMES);

			if (mpCurrentLevel->returnRate())
				mpCurrentLevel->PlaceFood(mpFood);

			if (mpCurrentLevel->returnRate())
				mpCurrentLevel->PlacePower(mpPower);

			mpEventSystem->fireEvent(Collision(mpCurrentLevel, mDirection));
			mpEventSystem->fireEvent(Food(mpUnits, mpFood));
			mpEventSystem->fireEvent(Power(mpUnits, mpPower));
		}

		loopTimer.sleepUntilElapsed(SIXTY_FRAMES);
		mpPerformanceTracker->stopTracking("mpPerformanceTracker");
		mFrameRate = mpPerformanceTracker->getElapsedTime("mpPerformanceTracker");
		//cout << mpPerformanceTracker->getElapsedTime("mpPerformanceTracker") << endl;

		if (*mpCollided == true)
			mHit = true;

		if (mpCurrentLevel->isFull(*mpScore))
			toNextLevel();

	}
}

/* Pre:  Nothing
*  Post:  Nothing
*  Purpose:  Set the smurf animation
*********************************************************/
void Game::setSmurfAnimation(Animation animation)
{
	*mpSmurfAnimation = animation;
}

/* Pre:  Nothing
*  Post:  Nothing
*  Purpose:  Set the dean animation
*********************************************************/
void Game::setDeanAnimation(Animation animation)
{
	*mpDeanAnimation = animation;
}

/* Pre:  Nothing
*  Post:  A game
*  Purpose:  Get the game
*********************************************************/
Game* Game::getInstance()
{
	assert(mpsGame);
	return mpsGame;
}

/* Pre:  Nothing
*  Post:  A game
*  Purpose:  Create the game
*********************************************************/
void Game::createInstance()
{
	mpsGame = new Game;
}

/* Pre:  The Game
*  Post:  Nothing
*  Purpose:  Destroy the game
*********************************************************/
void Game::destroyInstance()
{
	delete mpsGame;
	mpsGame = NULL;
}

void Game::loadData(string fileName)
{
	ifstream input(SELF_PATH + fileName);
	if (input.good())
	{
		string key;

		while (!input.eof())
		{
			input >> key;
			if (key == "level1")
			{
				
				input >> mBackgroundFilename1;
			}
			else if (key == "level2")
			{
				input >> mBackgroundFilename2;
			}
			else if (key == "level3")
			{
				input >> mBackgroundFilename3;
			}
			else if (key == "dimen1")
			{
				input >> mLevelWidth1 >> mLevelHeight1;
			}
			else if (key == "dimen2")
			{
				input >> mLevelWidth2 >> mLevelHeight2;
			}
			else if (key == "dimen3")
			{
				input >> mLevelWidth3 >> mLevelHeight3;
			}
			else if (key == "disp1")
			{
				input >> mDPWidth1 >> mDPHeight1;
			}
			else if (key == "disp2")
			{
				input >> mDPWidth2 >> mDPHeight2;
			}
			else if (key == "disp3")
			{
				input >> mDPWidth3 >> mDPHeight3;
			}
			else if (key == "points1")
			{
				input >> mRequiredScore1;
			}
			else if (key == "points2")
			{
				input >> mRequiredScore2;
			}
			else if (key == "points3")
			{
				input >> mRequiredScore3;
			}
			else if (key == "rate1")
			{
				input >> mRate1;
			}
			else if (key == "rate2")
			{
				input >> mRate2;
			}
			else if (key == "rate3")
			{
				input >> mRate3;
			}
			else if (key == "grid1")
			{
				input >> mRows1 >> mColumns1;
			}
			else if (key == "grid2")
			{
				input >> mRows2 >> mColumns2;
			}
			else if (key == "grid3")
			{
				input >> mRows3 >> mColumns3;
			}
			else if (key == "food1")
			{
				input >> mScore1;
			}
			else if (key == "food2")
			{
				input >> mScore2;
			}
			else if (key == "food3")
			{
				input >> mScore3;
			}
			else if (key == "scale1")
			{
				float i, j;
				input >> i >> j;
				mScale1 = Vector2D(i, j);
			}
			else if (key == "scale2")
			{
				float i, j;
				input >> i >> j;
				mScale2 = Vector2D(i, j);
			}
			else if (key == "scale3")
			{
				float i, j;
				input >> i >> j;
				mScale3 = Vector2D(i, j);
			}
			else if (key == "pos1")
			{
				int i, j;
				input >> i >> j;
				mLWalls1.push_back(Vector2D(i, j));
			}
			else if (key == "pos2")
			{
				int i, j;
				input >> i >> j;
				mLWalls2.push_back(Vector2D(i, j));
			}
			else if (key == "pos3")
			{
				int i, j;
				input >> i >> j;
				mLWalls3.push_back(Vector2D(i, j));
			}
			else if (key == "snake1")
			{
				input >> mHeadFilename;
			}
			else if (key == "snake2")
			{
				input >> mBodyFilename;
			}
			else if (key == "snake3")
			{
				input >> mTailFilename;
			}
			else if (key == "food")
			{
				input >> mFoodFilename;
			}
			else if (key == "power")
			{
				input >> mPowerFilename;
			}
			else if (key == "wall")
			{
				input >> mWallFilename;
			}
			else if (key == "font")
			{
				input >> mFontFilename;
			}
		}
	}
}

void Game::setContinue(bool cont)
{
	*mpContinue = cont;
}

bool Game::getCollision()
{
	return mpCollided;
}

void Game::setCollision(bool coll)
{
	*mpCollided = coll;
}

void Game::setScore(int score)
{
	mpScore = &score;
}

void Game::setFPS(float frPeSe)
{
	mpFPS = &frPeSe;
}

int Game::getScore()
{
	return *mpScore;
}

float Game::getFPS()
{
	return *mpFPS;
}

void Game::removeFood()
{
	int i = -1;
	for each (Vector2D food in mpCurrentLevel->getFood())
	{
		i++;
		if (food == mpCurrentLevel->getHeadCell())
		{
			mpFood->DestroyUnit(i);
			mpCurrentLevel->deleteFood(i);
			mpUnits->AddNewUnit();
			*mpScore += mpCurrentLevel->foodFullness();
		}
	}
}

void Game::removePowerup()
{
	int i = -1;
	for each (Vector2D power in mpCurrentLevel->getPowerup())
	{
		i++;
		if (power == mpCurrentLevel->getHeadCell())
		{
			mpPower->DestroyUnit(i);
			mpCurrentLevel->deletePower(i);
			mpCurrentLevel->makeFast();
		}
	}
}

void Game::placeNewFood()
{
	mpCurrentLevel->PlaceFood(mpFood);
}

void Game::placeNewPower()
{
	mpCurrentLevel->PlaceFood(mpFood);
}

int Game::foodScore()
{
	switch (*mpLevelNum)
	{
	case 1:
		return mLvlPoints1;
		break;
	case 2:
		return mLvlPoints2;
		break;
	case 3:
		return mLvlPoints3;
		break;
	default:
		return mLvlPoints1;
		break;
	}
}

bool Game::nextLevel()
{
	switch (*mpLevelNum)
	{
	case 1:
		return mLvlPoints1;
		break;
	case 2:
		return mLvlPoints2;
		break;
	case 3:
		return mLvlPoints3;
		break;
	default:
		return mLvlPoints1;
		break;
	}
}

int Game::neededScore()
{
	switch (*mpLevelNum)
	{
	case 1:
		return mRequiredScore1;
		break;
	case 2:
		return mRequiredScore2;
		break;
	case 3:
		return mRequiredScore3;
		break;
	default:
		return mRequiredScore1;
		break;
	}
}

void Game::toNextLevel()
{
	*mpScore = 0;

	switch (*mpLevelNum)
	{
	case 1:
		*mpLevelNum = 2;
		setUpLevel(mBackgroundFilename2, mLWalls2);
		mpGraphics->setWidth(mDPWidth2);
		mpGraphics->setHeight(mDPHeight2);
		break;
	case 2:
		*mpLevelNum = 3;
		setUpLevel(mBackgroundFilename3, mLWalls3);
		mpGraphics->setWidth(mDPWidth3);
		mpGraphics->setHeight(mDPHeight3);
		break;
	case 3:
		*mpLevelNum = 1;
		setUpLevel(mBackgroundFilename1, mLWalls1);
		mpGraphics->setWidth(mDPWidth1);
		mpGraphics->setHeight(mDPHeight1);
		break;
	default:
		setUpLevel(mBackgroundFilename2, mLWalls2);
		break;
	}
}

void Game::resetSize()
{
	mpUnits->Clear();
}

void Game::setLength(int newLength)
{
	mpUnits->Clear();
	for (int i = 0; i < newLength; i++)
		mpUnits->AddNewUnit();
}

void Game::grow()
{
	mpUnits->AddNewUnit();
}

void Game::setUpLevel(string lvl, vector<Vector2D> vec)
{
	mpCurrentLevel = mLevMan.getLevel(lvl);
	mpFood->Clear();
	mpPower->Clear();
	mpWall->Clear();
	for(int i = mpUnits->getLength(); i > BABY_SNAKE; i--)
		mpUnits->DestroyUnit(i);
	for (int i = 0; i < vec.size(); i++)
		mpWall->AddNewUnit();
	mpCurrentLevel->PlaceWalls(mpWall, vec);
	mpCurrentLevel->PlaceSnake();
	mPaused = true;
}



void Game::handleEvent(const Event& theEvent)
{
	if (theEvent.getType() == COLLISION)
	{
		const Collision& colli = static_cast<const Collision&>(theEvent);
		Game::setCollision(colli.hasCollided());
	}
	else if (theEvent.getType() == MOVE)
	{	
		HeadDirection moving = UP;

		const Move& movi = static_cast<const Move&>(theEvent);

		switch (movi.getButton())
		{
		case ALLEGRO_KEY_W:
			if (down == false)
			{
				up = true;
				down = false;
				left = false;
				right = false;
			}
			break;
		case ALLEGRO_KEY_UP:
			if (down == false)
			{
				up = true;
				down = false;
				left = false;
				right = false;
			}
			break;
		case ALLEGRO_KEY_S:
			if (up == false)
			{
				up = false;
				down = true;
				left = false;
				right = false;
			}
			break;
		case ALLEGRO_KEY_DOWN:
			if (up == false)
			{
				up = false;
				down = true;
				left = false;
				right = false;
			}
			break;
		case ALLEGRO_KEY_A:
			if (right == false)
			{
				up = false;
				down = false;
				left = true;
				right = false;
			}
			break;
		case ALLEGRO_KEY_LEFT:
			if (right == false)
			{
				up = false;
				down = false;
				left = true;
				right = false;
			}
			break;
		case ALLEGRO_KEY_D:
			if (left == false)
			{
				up = false;
				down = false;
				left = false;
				right = true;
			}
			break;
		case ALLEGRO_KEY_RIGHT:
			if (left == false)
			{
				up = false;
				down = false;
				left = false;
				right = true;
			}
			break;
		case ALLEGRO_KEY_ESCAPE:
			mRunning = false;
			break;
		case ALLEGRO_KEY_SPACE:
			mPaused = false;
			break;
		case ALLEGRO_KEY_ENTER:
			Game::setCollision(false);
			mHit = false;
			*mpLevelNum = 1;
			setUpLevel(mBackgroundFilename1, mLWalls1);
			mpGraphics->setWidth(mDPWidth1);
			mpGraphics->setHeight(mDPHeight1);
			break;
		}

		if (up)
			moving = UP;
		if (down)
			moving = DOWN;
		if (left)
			moving = LEFT;
		if (right)
			moving = RIGHT;

		mDirection = moving;

	}
	else if (theEvent.getType() == ESCAPE)
	{
		ALLEGRO_KEYBOARD_STATE mState;
		al_get_keyboard_state(&mState);

		while (!al_is_event_queue_empty(mpInput->getQueue()))
		{
			ALLEGRO_EVENT evnt;
			al_get_next_event(Game::mpInput->getQueue(), &evnt);
			if (evnt.type == ALLEGRO_EVENT_KEY_DOWN)
			{
				switch (evnt.keyboard.keycode)
				{
				case ALLEGRO_KEY_ESCAPE:
					*mpContinue = false;
					break;
				}
			}
		}
	}
	else if (theEvent.getType() == SCORE)
	{
		Color color(0, 0, 0);
		const Score& movi = static_cast<const Score&>(theEvent);
		mpGraphics->WriteText(SCORE_POSITION, *mpScript, color, movi.returnText());
	}
	else if (theEvent.getType() == FRAME)
	{
		Color color(0, 0, 0);
		const FPS& movi = static_cast<const FPS&>(theEvent);
		mpGraphics->WriteText(FPS_POSITION, *mpScript, color, movi.returnText());
	}
	else if (theEvent.getType() == TEXT)
	{
		Color color(0, 0, 0);
		const Message& movi = static_cast<const Message&>(theEvent);
		mpGraphics->WriteText(TEXT_POSITION, *mpScript, color, movi.returnText());
	}
	else if (theEvent.getType() == FOOD)
	{
		const Food& headOver = static_cast<const Food&>(theEvent);
		if (headOver.eating())
		{
			Game::removeFood();
		}
	}
	else if (theEvent.getType() == POWERUP)
	{
		const Power& headOver = static_cast<const Power&>(theEvent);

		if (headOver.eating())
		{
			Game::removePowerup();
		}
	}

}

void Game::eventTrigger(const Event& theEvent)
{
	mpEventSystem->fireEvent(theEvent);
}

Sprite Game::displayCurrent()
{
	switch (*mpLevelNum)
	{
	case 1:
		return *mpBackground;
		break;
	case 2:
		return *mpBackground2;
		break;
	case 3:
		return *mpBackground3;
		break;
	default:
		return *mpBackground;
		break;
	}
}