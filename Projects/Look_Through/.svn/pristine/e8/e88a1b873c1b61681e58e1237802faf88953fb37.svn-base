#include "AnimationManager.h"
// update to cut out any line skips or unneeded characters
AnimationManager::AnimationManager(std::string animationDataFilePath)
{
	std::ifstream animationData;
	animationData.open(animationDataFilePath);

	// This feels a bit unsafe
	if (!animationData.is_open())
	{
		return;
	}

	std::string animationImageFilePath;
	getline(animationData, animationImageFilePath);

	std::string trash;
	getline(animationData, trash);

	mpAnimationBuffer = new GraphicsBuffer(animationImageFilePath);

	while (!animationData.eof())
	{
		std::string animationName;
		getline(animationData, animationName);

		std::string sNumberOfSprites;
		getline(animationData, sNumberOfSprites);

		std::string sAnimationFrames;
		int iAnimationFrames;
		getline(animationData, sAnimationFrames);
		iAnimationFrames = std::stoi(sAnimationFrames);

		std::string sTimePerSprite;
		float fTimePerSprite;
		getline(animationData, sTimePerSprite);
		fTimePerSprite = std::stof(sTimePerSprite);

		std::string sShouldLoop;
		bool bShouldLoop;
		getline(animationData, sShouldLoop);

		if (sShouldLoop == "True")
		{
			bShouldLoop = true;
		}

		else
		{
			bShouldLoop = false;
		}

		std::string sUniqueSpriteOrder;
		bool bUniqueSpriteOrder;
		getline(animationData, sUniqueSpriteOrder);

		if (sUniqueSpriteOrder == "True")
		{
			bUniqueSpriteOrder = true;
		}

		else
		{
			bUniqueSpriteOrder = false;
		}

		Animation* newAnimation = new Animation(fTimePerSprite, bShouldLoop, bUniqueSpriteOrder);

		for (int i = 0; i < std::stoi(sNumberOfSprites); i++)
		{
			std::string sSpriteSourceX;
			std::string sSpriteSourceY;
			std::string sSpriteWidth;
			std::string sSpriteHeight;

			getline(animationData, sSpriteSourceX);
			getline(animationData, sSpriteSourceY);
			getline(animationData, sSpriteWidth);
			getline(animationData, sSpriteHeight);

			float fSpriteSourceX = std::stof(sSpriteSourceX);
			float fSpriteSourceY = std::stof(sSpriteSourceY);
			float fSpriteWidth = std::stof(sSpriteWidth);
			float fSpriteHeight = std::stof(sSpriteHeight);

			Sprite newSprite = Sprite(mpAnimationBuffer, fSpriteSourceX, fSpriteSourceY, fSpriteWidth, fSpriteHeight);

			newAnimation->addSprite(newSprite);
		}

		std::vector<int> spriteOrder;

		for (int i = 0; i < iAnimationFrames; i++)
		{
			switch (bUniqueSpriteOrder)
			{
				case true:
				{
					std::string sNextSprite;
					getline(animationData, sNextSprite);
					spriteOrder.push_back(std::stoi(sNextSprite));
					break;
				}

				case false:
				{
					spriteOrder.push_back(i);
					break;
				}
			}
		}

		newAnimation->updateSpriteOrder(spriteOrder);

		mAnimations.insert(std::pair<std::string, Animation*>(animationName, newAnimation));

		tempPointerVec.push_back(newAnimation);

		getline(animationData, trash);
	}

	// defaults to first animation
	mpCurrentAnimation = mAnimations.begin()->second;
	mCurrentAnimationName = mAnimations.begin()->first;
}

AnimationManager::~AnimationManager()
{
	mpCurrentAnimation = nullptr;

	std::map<std::string, Animation*>::iterator i = mAnimations.begin();

	while (i != mAnimations.end())
	{
		delete (i)->second;
		i++;
	}

	mAnimations.erase(mAnimations.begin(), mAnimations.end());

	delete(mpAnimationBuffer);
}

void AnimationManager::changeAnimation(std::string animationName)
{
	if (mAnimations[animationName])
	{
		if (mCurrentAnimationName != animationName && mCurrentAnimationName != "none")
		{
			mpCurrentAnimation->mCurrentSprite = 0;
			mpCurrentAnimation->mTimeRemaining = mpCurrentAnimation->mTimePerSprite;
		}

		mCurrentAnimationName = animationName;
		mpCurrentAnimation = mAnimations[animationName];
	}
}

void AnimationManager::update(float deltaTime)
{
	mpCurrentAnimation->update(deltaTime);
}