#include "Snake.h"
#include "Color.h"
#include "Game.h"
#include "GraphicsBufferManager.h"
#include "GraphicsBuffer.h"
#include "GraphicsSystem.h"
#include <vector>
#include "LevelManager.h"
#include "Level.h"
#include <EventSystem.h>
#include "GameEvent.h"
#include "DeadEvent.h"
#include "PowerUpEvent.h"
#include "PowerUps.h"
#include <fstream>

Snake::Snake()
{
	Game* pGame = Game::getInstance();

	int red = 0;
	int green = 0;
	int blue = 0;
	int a = 0;

	ifstream input("./data_files/snake.txt");
	if (input.good())
	{
		string key;

		while (!input.eof())
		{
			input >> key;
			if (key == "snake_color")
			{
				input >> red >> green >> blue >> a;
				this->mpSnakeColor =  new Color(red, green, blue, a);
			}
		}
	}
	input.close();

	const string SNAKE_KEY = "snake";
	int snakeWidth = pGame->getGridSlotSize().getX();
	int snakeHeight = pGame->getGridSlotSize().getY();

	pGame->getGraphicsBufferManager()->createAndAddGraphicsBuffer(SNAKE_KEY, snakeWidth, snakeHeight);

	pGame->getGraphicsSystem()->setColor(pGame->getGraphicsBufferManager()->getGraphicsBuffer(SNAKE_KEY), mpSnakeColor);

	this->mpSnakeSprite = new Sprite(snakeWidth, snakeHeight, Vector2D(0, 0), pGame->getGraphicsBufferManager()->getGraphicsBuffer(SNAKE_KEY));
	this->mSnakeSpeed = 0;
	this->mSnakeSpeedRemaining = 0;
	this->mSnakeDirection = "left";

	initSnake();
}

Snake::~Snake()
{
	delete mpSnakeSprite;
	delete mpSnakeColor;
}

void Snake::initSnake()
{
	Game* pGame = Game::getInstance();

	int snakeWidth = pGame->getGridSlotSize().getX();
	int snakeHeight = pGame->getGridSlotSize().getY();

	int snakeStartLocationX = pGame->getLevelManager()->getLevels()[pGame->getLevelManager()->getCurrentLevel() - 1]->getSnakeStartLocation().getX();
	int snakeStartLocationY = pGame->getLevelManager()->getLevels()[pGame->getLevelManager()->getCurrentLevel() - 1]->getSnakeStartLocation().getY();;

	mSnakeSpeed = pGame->getLevelManager()->getLevels()[pGame->getLevelManager()->getCurrentLevel() - 1]->getSnakeSpeed();
	mSnakeSpeedRemaining = mSnakeSpeed;

	for (int i = 0; i < pGame->getLevelManager()->getLevels()[pGame->getLevelManager()->getCurrentLevel() - 1]->getSnakeStartSegements(); i++)
	{
		mSnakePartLocations.push_back(Vector2D(snakeStartLocationX + (i * snakeWidth), snakeStartLocationY));
	}
}

void Snake::drawSnake(double dt)
{
	Game* pGame = Game::getInstance();

	for (auto location : mSnakePartLocations)
	{
		pGame->getGraphicsSystem()->draw(location, *mpSnakeSprite);
	}
}

bool Snake::isCollision(Vector2D newSnakeLocation)
{
	Game* pGame = Game::getInstance();

	bool isWallOrSnake = false;

	for (auto wall : pGame->getLevelManager()->getLevels()[pGame->getLevelManager()->getCurrentLevel() - 1]->getWallCoords())
	{
		if (wall == newSnakeLocation)
		{
			isWallOrSnake = true;
			EventSystem::getInstance()->fireEvent(DeadEvent());
		}
	}

	for (auto snake : mSnakePartLocations)
	{
		if (snake == newSnakeLocation)
		{
			isWallOrSnake = true;
			EventSystem::getInstance()->fireEvent(DeadEvent());
		}
	}

	powerUpCollision(newSnakeLocation);
	
	return isWallOrSnake;
}

void Snake::powerUpCollision(Vector2D& newSnakeLocation)
{
	Game* pGame = Game::getInstance();

	const int OFFSET = 16;

	Vector2D foodLocation = Vector2D(pGame->getPowerUps()->getFoodLocation().getX() - OFFSET, pGame->getPowerUps()->getFoodLocation().getY() - OFFSET);
	Vector2D bonusPointLocation = Vector2D(pGame->getPowerUps()->getBonusPointLocation().getX() - OFFSET, pGame->getPowerUps()->getBonusPointLocation().getY() - OFFSET);
	Vector2D slowSpeedLocation = Vector2D(pGame->getPowerUps()->getSlowSpeedLocation().getX() - OFFSET, pGame->getPowerUps()->getSlowSpeedLocation().getY() - OFFSET);

	if (newSnakeLocation == foodLocation)
	{
		EventSystem::getInstance()->fireEvent(PowerUpEvent("food"));
	}
	else if (newSnakeLocation == bonusPointLocation)
	{
		EventSystem::getInstance()->fireEvent(PowerUpEvent("bonusPoint"));
	}
	else if (newSnakeLocation == slowSpeedLocation)
	{
		if (pGame->getPowerUps()->getIsSlow())
		{
			EventSystem::getInstance()->fireEvent(PowerUpEvent("slow"));
		}
		else
		{
			EventSystem::getInstance()->fireEvent(PowerUpEvent("speed"));
		}
	}
}

void Snake::snakeMovement(double dt)
{
	Game* pGame = Game::getInstance();

	int snakeWidth = pGame->getGridSlotSize().getX();
	int snakeHeight = pGame->getGridSlotSize().getY();

	if (pGame->getIsStart())
	{
		return;
	}
	else if (pGame->getIsDead())
	{
		return;
	}
	else if (pGame->getIsWin())
	{
		return;
	}
	else if (pGame->getIsNextLevel())
	{
		return;
	}

	mSnakeSpeedRemaining -= dt;

	if (mSnakeSpeedRemaining <= 0)
	{
		if (mSnakeDirection == "left")
		{
			Vector2D newSnakeLocation = Vector2D(mSnakePartLocations.front().getX() - snakeWidth, mSnakePartLocations.front().getY());

			addSnakePart(newSnakeLocation);
		}
		else if (mSnakeDirection == "right")
		{
			Vector2D newSnakeLocation = Vector2D(mSnakePartLocations.front().getX() + snakeWidth, mSnakePartLocations.front().getY());

			addSnakePart(newSnakeLocation);
		}
		else if (mSnakeDirection == "up")
		{
			Vector2D newSnakeLocation = Vector2D(mSnakePartLocations.front().getX(), mSnakePartLocations.front().getY() - snakeHeight);

			addSnakePart(newSnakeLocation);
		}
		else if (mSnakeDirection == "down")
		{
			Vector2D newSnakeLocation = Vector2D(mSnakePartLocations.front().getX(), mSnakePartLocations.front().getY() + snakeHeight);

			addSnakePart(newSnakeLocation);
		}

		if (!pGame->getIsDead())
		{
			mSnakePartLocations.pop_back();
		}

		mSnakeSpeedRemaining = mSnakeSpeed;
	}
}

void Snake::setSnakeDirection(string direction)
{ 
	if (mSnakeDirection == "left")
	{
		if (direction != "right")
		{
			mSnakeDirection = direction;
		}
	}
	else if (mSnakeDirection == "right")
	{
		if (direction != "left")
		{
			mSnakeDirection = direction;
		}
	}
	else if (mSnakeDirection == "up")
	{
		if (direction != "down")
		{
			mSnakeDirection = direction;
		}
	}
	else if (mSnakeDirection == "down" )
	{
		if (direction != "up")
		{
			mSnakeDirection = direction;
		}
	}
}

void Snake::addSnakePart(Vector2D newSnakeLocation)
{
	Game* pGame = Game::getInstance();

	if (!isCollision(newSnakeLocation))
	{
		mSnakePartLocations.insert(mSnakePartLocations.begin(), newSnakeLocation);
	}
}

void Snake::growSnake()
{
	Game* pGame = Game::getInstance();

	for (int i = 0; i < pGame->getLevelManager()->getLevels()[pGame->getLevelManager()->getCurrentLevel() - 1]->getSnakeGrowth(); i++)
	{
		mSnakePartLocations.push_back(mSnakePartLocations.back());
	}
}

void Snake::clearSnake()
{
	mSnakePartLocations.clear();
}

void Snake::speedUpSnake()
{
	mSnakeSpeed = mSnakeSpeed / 2;
}

void Snake::slowDownSnake()
{
	mSnakeSpeed = mSnakeSpeed * 2;
}

void Snake::resetSnakeSpeed()
{
	Game* pGame = Game::getInstance();

	mSnakeSpeed = pGame->getLevelManager()->getLevels()[pGame->getLevelManager()->getCurrentLevel() - 1]->getSnakeSpeed();;
}

void Snake::resetSnakeDirection()
{
	mSnakeDirection = "left";
}

