/*
Author: David Silverman
Class: GPR-250-01
Assignment: Assignment 3
Certification of Authenticity:
I certify that this assignment is entirely my own work.
 */


#pragma once
#include "level.h"
#include "snakemanager.h"
#include "wallmanager.h"
#include "powerupmanager.h"
#include "foodmanager.h"
#include "game.h"

using namespace std;

Level::Level()
{

}

Level::Level(GraphicsBuffer* buff, int rows, int colums, int score, string title, float spawn, float speed, int length, int food)
{
	mSpeed = false;
	mDimensions = Vector2D(buff->getHeight(), buff->getWidth());
	mpSprite = new Sprite(ORIGIN, buff->getHeight(), buff->getWidth(), buff);
	mRows = rows;
	mColumbs = colums;
	mCellDimensions = Vector2D(mDimensions.getX() / colums, mDimensions.getY() / rows);
	mScale = DEFAULT;

	for (int i = 0; i < colums; i++)
	{
		mCellPos.push_back(vector<Vector2D>());
		for (int j = 0; j < rows; j++)
		{
			mCellPos[i].push_back(Vector2D(mCellDimensions.getX() * i, mCellDimensions.getY() * j));
		}
	}

	mTitle = title;
	mSpawnRate = spawn;
	mNormalSpeed = SPEED;
	mFastSpeed = speed * SPEED;
	mTiming = mNormalSpeed;
	mNeededLength = length;
	mRequiredScore = score;
	mStartingPos = mCellPos[(colums / 2)][(rows / 2)];
	mHeadPoS = Vector2D((colums / 2), (rows / 2));
	mFoodPotency = food;
}

Level::Level(GraphicsBuffer* buff, int rows, int colums, int score, string title, float spawn, float speed, int length, int food, Vector2D xToYScale)
{
	mSpeed = false;
	mDimensions = Vector2D(buff->getHeight(), buff->getWidth());
	mpSprite = new Sprite(ORIGIN, buff->getHeight(), buff->getWidth(), buff);
	mRows = rows;
	mColumbs = colums;
	mCellDimensions = Vector2D(mDimensions.getX() / colums, mDimensions.getY() / rows);
	mScale = xToYScale;

	for (int i = 0; i < colums; i++)
	{
		mCellPos.push_back(vector<Vector2D>());
		for (int j = 0; j < rows; j++)
		{
			mCellPos[i].push_back(Vector2D(mCellDimensions.getX() * i, mCellDimensions.getY() * j));
		}
	}

	mTitle = title;
	mSpawnRate = spawn;
	mNormalSpeed = SPEED;
	mFastSpeed = speed * SPEED;
	mTiming = mNormalSpeed;
	mNeededLength = length;
	mRequiredScore = score;
	mStartingPos = mCellPos[(colums / 2)][(rows / 2)];
	mHeadPoS = Vector2D((colums / 2), (rows / 2));
	mHeadPos = Vector2D((colums / 2), (rows / 2));
	mFoodPotency = food;
}

void Level::CheckSnake(SnakeManager*  snaMan, double dt, Vector2D scale)
{
	mTimeLeft -= dt;

	if (mTimeLeft <= 0)
	{
		mSnakePos.clear();
		mSnakeCells.clear();

		for (int i = 0; i < snaMan->getLength(); i++)
		{
			mSnakePos.push_back(snaMan->getUnitPosition(i));
		}

		mHeadPoS = loop(snaMan->getDirection(), snaMan->getHeight(), snaMan->getWidth());
		mHeadPoS = Vector2D(mHeadPoS.getX() * scale.getX(), mHeadPoS.getY() * scale.getY());

		for (int j = snaMan->getLength() - 1; j > 0; j--)
		{
			snaMan->setUnitPosition(snaMan->getUnitPosition(j - 1), j);
		}

		snaMan->setUnitPosition(mHeadPoS, 0);

		for (int l = 1; l < snaMan->getLength(); l++)
		{
			float wi = snaMan->getUnitPosition(l).getX() / snaMan->getWidth();
			float hi = snaMan->getUnitPosition(l).getY() / snaMan->getHeight();
			mSnakeCells.push_back(Vector2D(wi, hi));
		}

		mTimeLeft = mTiming;
	}
}

void Level::PlaceSnake()
{
	mSnakeHeadPos = mHeadPos;
}

void Level::PlaceWalls(WallManager* walMan, vector<Vector2D> walCells)
{
	mWallPos = walCells;

	for (int i = 0; i < mWallPos.size(); i++)
	{
		walMan->setUnitPosition(Vector2D((mWallPos[i].getX() * walMan->getWidth()), (mWallPos[i].getY() * walMan->getHeight())), i);
	}
}

void Level::PlaceFood(FoodManager* foodMan)
{
	Vector2D nwPos;

	do
	{
		int xPos = rand() % mColumbs;
		int yPos = rand() % mRows;

		nwPos = Vector2D(xPos, yPos);

		if ((unOverlapping(mSnakePos, nwPos) && unOverlapping(mWallPos, nwPos)) && (unOverlapping(mPowerPos, nwPos) && unOverlapping(mFoodPos, nwPos)))
			mLooping = true;
	} while (mLooping == false);

	mFoodPos.push_back(nwPos);
	foodMan->AddNewUnit(Vector2D((nwPos.getX() * foodMan->getWidth()), (nwPos.getY() * foodMan->getHeight())));
}

void Level::PlacePower(PowerUpManager* upMan)
{
	bool looping = false;
	Vector2D nwPos;

	do
	{
		int xPos = rand() % mColumbs;
		int yPos = rand() % mRows;

		nwPos = Vector2D(xPos, yPos);

		if ((unOverlapping(mSnakePos, nwPos) && unOverlapping(mWallPos, nwPos)) && (unOverlapping(mPowerPos, nwPos) && unOverlapping(mFoodPos, nwPos)))
			looping = true;
	} 
	while (looping == false);

	mPowerPos.push_back(nwPos);
	upMan->AddNewUnit(Vector2D((nwPos.getX() * upMan->getWidth()), (nwPos.getY() * upMan->getHeight())));
}

void Level::draw()
{
	Game::getInstance()->mpGraphics->Draw(ORIGIN, *mpSprite, mScale.getX(), mScale.getY());
}

bool Level::SnakeCollision()
{
	return false;
}

Vector2D Level::getStartingPosition()
{
	return mStartingPos;
}

Vector2D Level::loop(HeadDirection head, int hi, int wi)
{
	switch (head)
	{
		case UP:
			if (mSnakeHeadPos.getY() == 0)
			{
				mSnakeHeadPos = Vector2D(mSnakeHeadPos.getX(), float(mRows - 1));
			}
			else
			{
				mSnakeHeadPos = Vector2D(mSnakeHeadPos.getX(), mSnakeHeadPos.getY() - 1);
			}
			break;
		case DOWN:
			if (mSnakeHeadPos.getY() == mRows - 1)
			{
				mSnakeHeadPos = Vector2D(mSnakeHeadPos.getX(), 0.0f);
			}
			else
			{
				mSnakeHeadPos = Vector2D(mSnakeHeadPos.getX(), mSnakeHeadPos.getY() + 1);
			}
			break;
		case LEFT:
			if (mSnakeHeadPos.getX() == 0)
			{
				mSnakeHeadPos = Vector2D(float(mColumbs - 1), mSnakeHeadPos.getY());
			}
			else
			{
				mSnakeHeadPos = Vector2D(mSnakeHeadPos.getX() - 1, mSnakeHeadPos.getY());
			}
			break;
		case RIGHT:
			if (mSnakeHeadPos.getX() == mColumbs - 1)
			{
				mSnakeHeadPos = Vector2D(0.0f, mSnakeHeadPos.getY());
			}
			else
			{
				mSnakeHeadPos = Vector2D(mSnakeHeadPos.getX() + 1, mSnakeHeadPos.getY());
			}
			break;
	
	}

	cout << mSnakeHeadPos.getX() << ", " << mSnakeHeadPos.getY() << endl;

	return Vector2D((mSnakeHeadPos.getX() * wi), (mSnakeHeadPos.getY() * hi));
}

int Level::getCellHeadX()
{
	return mSnakeHeadPos.getX();
}

int Level::getCellHeadY()
{
	return mSnakeHeadPos.getY();
}

bool Level::unOverlapping(vector<Vector2D> objects, Vector2D pos)
{
	for (int i = 0; i < objects.size(); i++)
	{
		if (objects[i].getX() == pos.getX() || objects[i].getY() == pos.getY())
			return false;
	}

	return true;
}

Vector2D Level::getHeadCell()
{
	return mSnakeHeadPos;
}

int Level::getHeadX()
{
	return mHeadPoS.getX();
}

int Level::getHeadY()
{
	return mHeadPoS.getY();
}

int Level::getLevelWidth()
{
	return mColumbs;
}

int Level::getLevelHeight()
{
	return mRows;
}

vector<Vector2D> Level::getSnakeBody()
{
	return mSnakePos;
}

vector<Vector2D> Level::getWalls()
{
	return mWallPos;
}

vector<Vector2D> Level::getFood()
{
	return mFoodPos;
}

vector<Vector2D> Level::getPowerup()
{
	return mPowerPos;
}

Sprite Level::returnBackground()
{
	return *mpSprite;
}

void Level::setSpeed(float speed)
{
	mNormalSpeed = speed;
	mFastSpeed = speed * FAST;
}

void Level::makeFast()
{
	if (mSpeed == false)
	{
		mTiming = mFastSpeed;
		mSpeed = true;
	}	
	else
	{
		mTiming = mNormalSpeed;
		mSpeed = false;
	}
}

int Level::getFoodX(int power)
{
	return mFoodPos[power].getX();
}

int Level::getFoodY(int power)
{
	return mFoodPos[power].getY();
}

void Level::deleteFood(int dele)
{
	mFoodPos.erase(mFoodPos.begin() + dele);
}

void Level::deletePower(int dele)
{
	mPowerPos.erase(mPowerPos.begin() + dele);
}

int Level::foodFullness()
{
	return mFoodPotency;
}

void Level::switchSpeed()
{
	if (mSwitched)
	{
		mTiming = mNormalSpeed;
	}
	else
	{
		mTiming = mFastSpeed;
	}
}

vector<Vector2D> Level::limbs()
{
	return mSnakeCells;
}

bool Level::isFull(int take)
{
	if (take >= mRequiredScore)
		return true;
	else
		return false;
}

bool Level::returnRate()
{
	int should = rand() % RATE;

	if (should <= mSpawnRate)
		return true;
	else
		return false;
}

Vector2D Level::getScale()
{
	return mScale;
}