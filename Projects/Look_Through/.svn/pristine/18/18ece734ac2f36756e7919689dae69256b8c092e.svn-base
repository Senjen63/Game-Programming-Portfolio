#include "Animation.h"

Animation::Animation(double speed, AnimationBase* base)
{
	mSpeed = speed;
	mBase = base;
	mCurrentFrame = 0;
	mTimeInFrame = 0;
}

Animation::~Animation()
{
}

void Animation::update(double elapsedTime)
{
	if (!mIsRunning) { return; }

	mTimeInFrame += mSpeed * elapsedTime;

	int framesToProgress = (int)mTimeInFrame; //if mSpeed > 1, determine how many frames to jump ahead

	mTimeInFrame -= framesToProgress;
	mCurrentFrame += framesToProgress;

	if (size_t(mCurrentFrame) >= mBase->mSpritesToUse.size()) {
		if (mBase->mIsLooping)
		{ 
			/*determine "bonus" frames (e.g. in a 10-frame animation, speed 3, jump from frame 9 -> frame 2)
			
			what I'm doing here with the conversion to int is rounding it down to the nearest N, where N = size of the vector
			this solution is kinda janky but it's efficient and C++ doesn't come with a function to do this as far as I know
			*/
			mCurrentFrame -= int(mCurrentFrame / mBase->mSpritesToUse.size()) * mBase->mSpritesToUse.size();
		}
		else 
		{ 
			mCurrentFrame = mBase->mSpritesToUse.size() - 1;
			mSpeed = 0;
			mIsFinished = true;
		}
	}
}