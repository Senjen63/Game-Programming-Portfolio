#include "game.h"

Game::Game()
{
	mpGraphicsSystemObject = new GraphicsSystem();
}
Game::Game(int width, int height)
{
	mWidth = width;
	mHeight = height;
}
Game::~Game()
{
	gameCleanup();
}

Game* gpGame = nullptr;

void Game::gameInit()
{
	if (!mInit)
	{
		mpGraphicsSystemObject->GraphicsInit();
		mInputSystemObject.inputInit();

		mpGraphicsSystemObject = new GraphicsSystem(mWidth, mHeight);
		mInputSystemObject = InputSystem();

		mInit = true;
	}
}
void Game::gameCleanup()
{
	if (!mClean)
	{
		delete mpGraphicsSystemObject;
		mClean = true;
	}
}

void Game::doLoop()
{
	mLoopRunning = true;

	double animationFps = 16.0;
	double fps = 60.0;
	const int smurfRow = 4;
	const int smurfColumn = 4;
	const int scale = 1;
	const Vector2D vecZero(0, 0);
	const Vector2D vecSize(mWidth, mHeight);

	PerformanceTracker* pPerformance = new PerformanceTracker;

	GraphicsBuffer* pWoodsAsset = new GraphicsBuffer(ASSET_PATH+ WOODS_FILENAME);
	GraphicsBuffer* pSmurfAsset = new GraphicsBuffer(ASSET_PATH+ SMURF_FILENAME);
	GraphicsBuffer* pDealAsset = new GraphicsBuffer(ASSET_PATH+ DEAN_FILENAME);

	Animation smurfAnim(animationFps, true);
	Animation deanAnim(animationFps, true);

	Vector2D graphicsHeightWidth = Vector2D(mpGraphicsSystemObject->getWidth() / 2, mpGraphicsSystemObject->getHeight() / 2);

	Unit* pObj = new Unit(graphicsHeightWidth, animationFps);

	for (int i = 0; i < smurfRow; i++)
	{
		for (int k = 0; k < smurfColumn; k++)
		{
			Sprite smurfSprite(pSmurfAsset, Vector2D(pSmurfAsset->getWidth() / smurfRow * k, pSmurfAsset->getHeight() / smurfColumn * i), pSmurfAsset->getWidth() / smurfRow, pSmurfAsset->getHeight() / smurfColumn);
			smurfAnim.addSprite(smurfSprite);
		}
	}
	for (int i = 0; i < smurfRow; i++)
	{
		for (int k = 0; k < smurfColumn; k++)
		{
			Sprite deanSprite(pDealAsset, Vector2D(pDealAsset->getWidth() / smurfRow * k, pDealAsset->getHeight() / smurfColumn * i), pDealAsset->getWidth() / smurfRow, pDealAsset->getHeight() / smurfColumn);
			deanAnim.addSprite(deanSprite);
		}
	}

	pObj->addAnimation(smurfAnim);
	pObj->addAnimation(deanAnim);

	double targetMS = 1000.0 / fps;
	bool pressF = false, pressS = false, pressEnter = false;

	while (mLoopRunning)
	{
		pPerformance->clearTracker(LOOP_TRACKER_NAME);
		pPerformance->startTracking(LOOP_TRACKER_NAME);

		Timer timer;
		timer.start();

		Vector2D checkMouseInput = mInputSystemObject.getMouseState(LEFT_MOUSE_BUTTON);



		if (checkMouseInput != Vector2D(-1, -1))
		{
			cout << "Mouse Clicked" << checkMouseInput<<endl;
			pObj->changePosition(checkMouseInput);
		}

		if (mInputSystemObject.getKeyState(F_KEY))
		{
			if (!pressF)
			{
				pressF = true;

				mFps += FRAME_CHANGE_FACTOR;

				if (mFps > FRAME_RATE_CAP)
				{
					mFps = FRAME_RATE_CAP;
				}

				pObj->setFps(mFps);
				cout << "Fps up: " << mFps << endl;
			}
		}
		else
		{
			pressF = false;
		}

		if (mInputSystemObject.getKeyState(S_KEY))
		{
			if (!pressS)
			{
				pressS = true;

				mFps -= FRAME_CHANGE_FACTOR;
				if (mFps < FRAME_RATE_MIN)
				{
					mFps = FRAME_RATE_MIN;
				}

				pObj->setFps(mFps);
				cout << "Fps Slow: " << mFps << endl;
			}
		}
		else
		{
			pressS = false;
		}

		if (mInputSystemObject.getKeyState(ESC_KEY))
		{
			mLoopRunning = false;
		}
		if (mInputSystemObject.getKeyState(ENTER_KEY))
		{
			if (!pressEnter)
			{
				pressEnter = true;
				int nextIndex = pObj->getCurrentIndex() + 1;
				if (nextIndex >= pObj->getAnimationVectorCount())
				{
					nextIndex = 0;
				}

				pObj->setAnimation(nextIndex);
				cout << "Switch Animation" << pObj->getCurrentIndex() << endl;
			}
		}
		else
		{
			pressEnter = false;
		}

		mpGraphicsSystemObject->draw(pWoodsAsset, 0, 0, mWidth / pWoodsAsset->getWidth(), mHeight / pWoodsAsset->getHeight());

		mpGraphicsSystemObject->draw(pObj->getLocation().getX(), pObj->getLocation().getY(), pObj->currentAnimation().getCurrentSprite(),1.0f,1.0f);

		mpGraphicsSystemObject->flipDisplay();

		pObj->unitUpdate(targetMS);

		timer.sleepUntilElapsed(targetMS);

		pPerformance->stopTracking(LOOP_TRACKER_NAME);
		//cout << pPerformance->getElapsedTime(LOOP_TRACKER_NAME) << endl;
	}

	delete pObj;
	delete pDealAsset;
	delete pSmurfAsset;
	delete pWoodsAsset;
	delete pPerformance;
}