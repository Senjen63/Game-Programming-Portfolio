#pragma once
#include "PerformanceTracker.h"
#include "Game.h"
#include "InputSystem.h"
#include "Unit.h"
#include "Animation.h"

Game* Game::mpsGame = nullptr;

const string INIT_TRACKER_NAME = "init";
const string DRAW_TRACKER_NAME = "draw";
const string WAIT_TRACKER_NAME = "wait";
const string LOOP_TRACKER_NAME = "loop";

const string ASSET_PATH = "..\\..\\common\\assets\\";
const string BACKGROUND_FILENAME = "woods.png";
const string SMURFS_FILENAME = "smurf_sprites.png";
const string DEAN_FILENAME = "dean_sprites.png";

const int SMURFS_LENGTH = 4;
const int SPRITE_NUM = 16;
const float DEFAULT_TARGET_TIME = 16;
const float DEFAULT_SCALE = 1;
const float DEFAULT_BUFFER = 10;

void Game::createGame()
{
	if (!mpsGame)
		mpsGame = new Game();
}

void Game::destroyGame()
{
	delete mpsGame;
	mpsGame = nullptr;
}

Game* Game::getGame()
{
	return mpsGame;
}

Game::Game()
{
	mContinue = true;
	mTargetTime = DEFAULT_TARGET_TIME;
	mpGraphicsSys = nullptr;
	mpInputSys = nullptr;
	mpUnitMan = nullptr;
	mpGBMan = nullptr;
}

Game::~Game()
{
	cleanup();
}

void Game::init( float fps, int dispW, int dispH )
{
	mpGraphicsSys = new GraphicsSystem();
	mpGraphicsSys->init(dispW, dispH);

	mpInputSys = new InputSystem();
	mpInputSys->init();

	mpUnitMan = new UnitManager();

	mpGBMan = new GraphicsBufferManager();

	mTargetTime = 1000/fps;
}

void Game::cleanup()
{
	delete mpGBMan;
	delete mpUnitMan;
	delete mpInputSys;
	delete mpGraphicsSys;
}

void Game::doLoop()
{
	PerformanceTracker* pPerformanceTracker = new PerformanceTracker;
	Timer loopTimer;
	bool enterKeyPressed = false;
	bool spaceKeyPressed = false;

	mpGBMan->addGraphicsBuff( ASSET_PATH + BACKGROUND_FILENAME, "woods" );
	mpGBMan->addGraphicsBuff( ASSET_PATH + SMURFS_FILENAME, "smurfs" );
	mpGBMan->addGraphicsBuff( ASSET_PATH + DEAN_FILENAME, "deans" );

	while ( getIfContinue() )
	{
		pPerformanceTracker->clearTracker( LOOP_TRACKER_NAME ); 
		pPerformanceTracker->startTracking( LOOP_TRACKER_NAME );

		loopTimer.start();

		/*// slows down or speeds up animation if s or f pressed (respectively)
		if (mpInputSys->getKeyboardInput(KeyCode::FKEY))
			pCharUnit->getCurAnim().changeSpeed( 2 );
		if ( mpInputSys->getKeyboardInput( KeyCode::SKEY ) )
			pCharUnit->getCurAnim().changeSpeed( -2 );*/

		// changes animation on last created unit if enter pressed
		if ( mpInputSys->getKeyboardInput( KeyCode::ENTER ) )
		{
			if ( !enterKeyPressed )
			{
				enterKeyPressed = true;
				mpUnitMan->getLastUnit()->setAnimation();
			}
		}
		else
			enterKeyPressed = false;

		// quits application if esc pressed
		if ( mpInputSys->getKeyboardInput( KeyCode::ESCAPE ) )
		{
			setIfContinue( false );
		}

		// toggles if animating for all units if space pressed
		if ( mpInputSys->getKeyboardInput( KeyCode::SPACE ) )
		{
			if ( !spaceKeyPressed )
			{
				spaceKeyPressed = true;
				for (int i = 0; i < mpUnitMan->getUnits().size(); i++)
				{
					mpUnitMan->getUnits()[ i ]->getCurAnim().togglePlay();
				}
			}
			else
				spaceKeyPressed = false;
		}

		// create units when mouse click left down wherever cursor is
		if ( mpInputSys->getMouseInput( KeyCode::LEFTMOUSE ) )
		{
			mpUnitMan->createUnit( mpInputSys->getMouseX(), mpInputSys->getMouseY(), DEFAULT_TARGET_TIME, mpGBMan->getGraphicsBuff( "smurfs" ), mpGBMan->getGraphicsBuff( "deans" ) );
		}

		// delete units close to mouse position when click right button
		if (mpInputSys->getMouseInput(KeyCode::RIGHTMOUSE))
		{
			//mpUnitMan->createUnit(mpInputSys->getMouseX(), mpInputSys->getMouseY(), DEFAULT_TARGET_TIME, mpGBMan->getGraphicsBuff("smurfs"), mpGBMan->getGraphicsBuff("deans"));
			
			for ( int i = 0; i < mpUnitMan->getUnits().size(); i++ )
			{
				if ( mpUnitMan->getUnits()[ i ]->getX() >= mpInputSys->getMouseX() - DEFAULT_BUFFER && mpUnitMan->getUnits()[ i ]->getX() <= mpInputSys->getMouseX() + DEFAULT_BUFFER
				&& mpUnitMan->getUnits()[ i ]->getY() >= mpInputSys->getMouseY() - DEFAULT_BUFFER && mpUnitMan->getUnits()[ i ]->getY() <= mpInputSys->getMouseY() + DEFAULT_BUFFER )
				{
					mpUnitMan->deleteUnit( mpUnitMan->getUnits()[ i ] );
				}
			}
		}

		mpGraphicsSys->draw( mpGBMan->getGraphicsBuff( "woods" ), 1 );

		mpUnitMan->updateAll( mTargetTime ); // mTargetTime should be same as deltaTime
		mpUnitMan->drawAll();

		mpGraphicsSys->flip();

		loopTimer.sleepUntilElapsed( mTargetTime );

		pPerformanceTracker->stopTracking( LOOP_TRACKER_NAME );
		std::cout << "Frame Took:" << pPerformanceTracker->getElapsedTime( LOOP_TRACKER_NAME ) << "ms" << std::endl;
	};

	delete pPerformanceTracker;
}

Game* gpGame = nullptr;