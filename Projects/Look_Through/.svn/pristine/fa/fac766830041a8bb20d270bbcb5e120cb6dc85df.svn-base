#include "SnakePlayer.h"
#include "Game.h"
#include "Color.h"
#include "GraphicsBufferManager.h"
#include "GraphicsBuffer.h"
#include "GraphicsSystem.h"
#include "Level.h"
#include "LevelManager.h"
#include "GameEvent.h"
#include "DeathEvent.h"
#include "PowerUpEvent.h"
#include "Animation.h"
#include "UnitManager.h"
#include "Unit.h"
#include <EventSystem.h>
#include <vector>

SnakePlayer::SnakePlayer()
{
	Game* pGame = Game::getGameInstance();
	GraphicsBufferManager* pBufferManager = pGame->getGraphicsBufferManager();

	pBufferManager->createGraphicsBuffer(PLAYER_KEY, PLAYER_SPRITE);
	pBufferManager->createGraphicsBuffer(SEGMENT_KEY, SEGMENT_SPRITE);

	this->mpPlayerSprite = new Sprite(Vector2D(0, 0), pGame->getGraphicsBufferManager()->getGraphicsBuffer(PLAYER_KEY),
									  pGame->getGraphicsBufferManager()->getGraphicsBuffer(PLAYER_KEY)->getBitmapWidth(),
									  pGame->getGraphicsBufferManager()->getGraphicsBuffer(PLAYER_KEY)->getBitmapHeight());
	this->mpSegmentSprite = new Sprite(Vector2D(0, 0), pGame->getGraphicsBufferManager()->getGraphicsBuffer(SEGMENT_KEY),
									  pGame->getGraphicsBufferManager()->getGraphicsBuffer(SEGMENT_KEY)->getBitmapWidth(),
									  pGame->getGraphicsBufferManager()->getGraphicsBuffer(SEGMENT_KEY)->getBitmapHeight());

	this->mNumOfSegments = 4;
	this->mDefaultTick = 0;
	this->mCurrentTick = 0;
	this->mRemainingTick = 0;
	this->mDirection = MOVE_LEFT;

	initPlayer();
}

SnakePlayer::~SnakePlayer()
{
	delete mpPlayerSprite;
	delete mpSegmentSprite;
}

void SnakePlayer::initPlayer()
{
	Game* pGame = Game::getGameInstance();

	int size = 32;

	int startX = pGame->getLevelManager()->getLevelList()[pGame->getLevelManager()->getCurrentLevelIndex() - 1]->getPlayerSpawnPoint().getX();
	int startY = pGame->getLevelManager()->getLevelList()[pGame->getLevelManager()->getCurrentLevelIndex() - 1]->getPlayerSpawnPoint().getY();

	mDefaultTick = pGame->getLevelManager()->getLevelList()[pGame->getLevelManager()->getCurrentLevelIndex() - 1]->getPlayerSpeed();
	this->mCurrentTick = this->mDefaultTick;
	this->mRemainingTick = this->mDefaultTick;

	for (int i = 0; i < mNumOfSegments; i++)
	{
		mSegmentLocations.push_back(Vector2D(startX + (i * size), startY));
	}
}

void SnakePlayer::drawPlayer()
{
	Game* pGame = Game::getGameInstance();

	for (auto loc : mSegmentLocations)
	{
		if(loc == mSegmentLocations[0]) { pGame->getGraphicsSystem()->draw(loc, *mpPlayerSprite); }
		else { pGame->getGraphicsSystem()->draw(loc, *mpSegmentSprite); }
	}

	mPlayerAnimation.update(pGame->GAME_TICK);
}

void SnakePlayer::playerMovement(double tickTime)
{
	Game* pGame = Game::getGameInstance();

	mRemainingTick -= tickTime;

	if (pGame->getGameState() != GAME_LOOP)
	{
		return;
	}

	if (mRemainingTick <= 0)
	{
		float currentXPos = mSegmentLocations.front().getX();
		float currentYPos = mSegmentLocations.front().getY();

		// grid based movement
		switch (mDirection)
		{
			case MOVE_UP:
			{
				Vector2D moveToLocation = Vector2D(currentXPos, currentYPos - pGame->TILE_SIZE);
				addSegment(moveToLocation);

				break;
			}

			case MOVE_LEFT:
			{
				Vector2D moveToLocation = Vector2D(currentXPos - pGame->TILE_SIZE, currentYPos);
				addSegment(moveToLocation);

				break;
			}

			case MOVE_DOWN:
			{
				Vector2D moveToLocation = Vector2D(currentXPos, currentYPos + pGame->TILE_SIZE);
				addSegment(moveToLocation);

				break;
			}

			case MOVE_RIGHT:
			{
				Vector2D moveToLocation = Vector2D(currentXPos + pGame->TILE_SIZE, currentYPos);
				addSegment(moveToLocation);

				break;
			}
		}

		if (pGame->getGameState() == GAME_LOOP)
		{
			mSegmentLocations.pop_back();
		}

		mRemainingTick = mCurrentTick;
	}
}

bool SnakePlayer::isColliding(Vector2D playerLocation)
{
	Game* pGame = Game::getGameInstance();

	bool isCollidingWithWallOrBody = false;

	for (auto wall : pGame->getLevelManager()->getLevelList()[pGame->getLevelManager()->getCurrentLevelIndex() - 1]->getWallCoordinates())
	{
		if (wall == playerLocation)
		{
			isCollidingWithWallOrBody = true;
			EventSystem::getInstance()->fireEvent(DeathEvent());
		}
	}

	for (auto body : mSegmentLocations)
	{
		if (body == playerLocation)
		{
			isCollidingWithWallOrBody = true;
			EventSystem::getInstance()->fireEvent(DeathEvent());
		}
	}

	powerUpCollision(playerLocation);

	return isCollidingWithWallOrBody;
}

void SnakePlayer::powerUpCollision(Vector2D& currentPlayerLocation)
{
	Game* pGame = Game::getGameInstance();
	EventSystem* pEventSystem = EventSystem::getInstance();

	const int OFFSET = 16;

	Vector2D foodLocation = Vector2D(pGame->getPowerUps()->getFoodLocation().getX(), pGame->getPowerUps()->getFoodLocation().getY());
	Vector2D bonusFoodLocation = Vector2D(pGame->getPowerUps()->getBonusFoodLocation().getX(), pGame->getPowerUps()->getBonusFoodLocation().getY());
	Vector2D speedUpLocation = Vector2D(pGame->getPowerUps()->getSpeedUpLocation().getX(), pGame->getPowerUps()->getSpeedUpLocation().getY());
	Vector2D slowDownLocation = Vector2D(pGame->getPowerUps()->getSlowDownLocation().getX(), pGame->getPowerUps()->getSlowDownLocation().getY());

	if (currentPlayerLocation == foodLocation)
	{
		pEventSystem->fireEvent(PowerUpEvent("food"));
	}
	else if (currentPlayerLocation == bonusFoodLocation)
	{
		pEventSystem->fireEvent(PowerUpEvent("bonusPoints"));
	}
	else if (currentPlayerLocation == speedUpLocation)
	{
		pEventSystem->fireEvent(PowerUpEvent("speedup"));
	}
	else if (currentPlayerLocation == slowDownLocation)
	{
		pEventSystem->fireEvent(PowerUpEvent("slowdown"));
	}
}

void SnakePlayer::addSegment(Vector2D newLocation)
{
	Game* pGame = Game::getGameInstance();

	if (!isColliding(newLocation))
	{
		mSegmentLocations.insert(mSegmentLocations.begin(), newLocation);
	}
}

void SnakePlayer::growPlayerBody()
{
	Game* pGame = Game::getGameInstance();

	for (int i = 0; i < pGame->getLevelManager()->getLevelList()[pGame->getLevelManager()->getCurrentLevelIndex() - 1]->getPlayerGrowth(); i++)
	{
		mSegmentLocations.push_back(mSegmentLocations.back());
	}
}

void SnakePlayer::setPlayerDirection(MovementDirections newDirection)
{
	if (mDirection == MOVE_LEFT)
	{
		if (newDirection != MOVE_RIGHT) { mDirection = newDirection; };
	}
	else if (mDirection == MOVE_RIGHT)
	{
		if (newDirection != MOVE_LEFT) { mDirection = newDirection; };
	}
	else if (mDirection == MOVE_UP)
	{
		if (newDirection != MOVE_DOWN) { mDirection = newDirection; };
	}
	else if (mDirection == MOVE_DOWN)
	{
		if (newDirection != MOVE_UP) { mDirection = newDirection; };
	}
}

void SnakePlayer::increasePlayerSpeed()
{
	mCurrentTick /= 2;
}

void SnakePlayer::decreasePlayerSpeed()
{
	mCurrentTick *= 2;
}

void SnakePlayer::resetPlayerDirection()
{
	mDirection = MOVE_LEFT;
}

void SnakePlayer::resetPlayerSpeed()
{
	Game* pGame = Game::getGameInstance();

	mCurrentTick = pGame->getLevelManager()->getLevelList()[pGame->getLevelManager()->getCurrentLevelIndex() - 1]->getPlayerSpeed();
}

void SnakePlayer::clearPlayer()
{
	mSegmentLocations.clear();
}