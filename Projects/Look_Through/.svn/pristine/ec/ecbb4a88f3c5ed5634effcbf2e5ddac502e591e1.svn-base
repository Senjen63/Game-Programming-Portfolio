#include "UnitManager.h"

UnitManager::UnitManager()
{
	mCurrentTime = 0;
	mSpeed = DEFAULT_SPEED;
	mCurrentDir = Direction::RIGHT;
	mNormalSpeed = NORMAL_SPEED;
	mSlowSpeed = SLOW_SPEED;
	mFastSpeed = FAST_SPEED;
	mPowerUpTime = 0;
	mPowerCurrentTime = 0;
	canTurn = true;
}

UnitManager::~UnitManager()
{
	cleanUp();
}

void UnitManager::makeUnit()
{
	Unit* pUnit = new Unit();
	mpUnitVector.push_back(pUnit);
}

void UnitManager::makeUnit(Vector2D loc, GraphicsBuffer* pBuffer)
{
	Unit* pUnit = new Unit(loc, pBuffer);
	mpUnitVector.push_back(pUnit);
}

void UnitManager::clear()
{
	for (unsigned int i = 0; i < mpUnitVector.size(); i++)
	{
		delete mpUnitVector[i];
	}
	mpUnitVector.clear();
}

void UnitManager::removeUnit(Unit* destroy)
{
	for (unsigned int i = 0; i < mpUnitVector.size(); i++)
	{
		Unit* temp = mpUnitVector[i];
		if (temp == destroy)
		{
			delete temp;
			mpUnitVector.erase(mpUnitVector.begin() + i);
			return;
		}
	}
}

void UnitManager::cleanUp()
{
	clear();
	mCurrentTime = 0;
	mNormalSpeed = 0;
	mSlowSpeed = 0;
	mFastSpeed = 0;
	mPowerUpTime = 0;
	mPowerCurrentTime = 0;
	canTurn = true;
}

void UnitManager::updateSnake(Direction newDir, float time)
{
	Vector2D newPos = mpUnitVector[0]->getPos();

	if (newDir == Direction::DOWN && mCurrentDir != Direction::UP && canTurn)
	{
		setDirection(newDir, newPos);
		mCurrentDir = newDir;
		canTurn = false;
	}
	else if (newDir == Direction::UP && mCurrentDir != Direction::DOWN && canTurn)
	{
		setDirection(newDir, newPos);
		mCurrentDir = newDir;
		canTurn = false;
	}
	else if (newDir == Direction::LEFT && mCurrentDir != Direction::RIGHT && canTurn)
	{
		setDirection(newDir, newPos);
		mCurrentDir = newDir;
		canTurn = false;
	}
	else if (newDir == Direction::RIGHT && mCurrentDir != Direction::LEFT && canTurn)
	{
		setDirection(newDir, newPos);
		mCurrentDir = newDir;
		canTurn = false;
	}
	else
		setDirection(mCurrentDir, newPos);

	if (mSpeed != mNormalSpeed && mSpeed != DEFAULT_SPEED)
	{
		mPowerCurrentTime += time;
		if (mPowerCurrentTime > mPowerUpTime)
		{
			mSpeed = mNormalSpeed;
			mPowerCurrentTime = 0;
		}
	}	
	
	mCurrentTime += time;
	if (mCurrentTime > mSpeed)
	{
		mCurrentTime = 0;	
		updateSnakeBody();
		mpUnitVector[0]->setPos(newPos);
		canTurn = true;
	}
}

void UnitManager::drawAll(GraphicsSystem* display)
{
	for (unsigned int i = 0; i < mpUnitVector.size(); i++)
	{
		mpUnitVector[i]->Draw(display);
	}
}

void UnitManager::setDirection(Direction dir, Vector2D& pos)
{
	if (dir == Direction::DOWN)
	{
		pos.setY(pos.getY() + MOVEMENT_DISTANCE);
	}
	else if (dir == Direction::UP)
	{
		pos.setY(pos.getY() - MOVEMENT_DISTANCE);
	}
	else if (dir == Direction::LEFT)
	{
		pos.setX(pos.getX() - MOVEMENT_DISTANCE);
	}
	else if (dir == Direction::RIGHT)
	{
		pos.setX(pos.getX() + MOVEMENT_DISTANCE);
	}
}

void UnitManager::updateSnakeBody()
{
	for (unsigned int i = mpUnitVector.size() - 1; i > 0; i--)
	{
		mpUnitVector[i]->setPos(mpUnitVector[i - 1]->getPos());
	}
}
