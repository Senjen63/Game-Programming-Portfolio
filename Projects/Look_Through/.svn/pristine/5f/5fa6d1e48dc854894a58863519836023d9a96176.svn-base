#include "AnimationManager.h"


std::vector<Sprite>* AnimationManager::getAnimationFrames(const std::string& animationFramesName)
{
	return mAnimationFrames[animationFramesName];
}


void AnimationManager::addAnimationFrames(const std::string& animationFramesName, std::vector<Sprite>& frames)
{
	if (mAnimationFrames.find(animationFramesName) != mAnimationFrames.end() && mAnimationFrames[animationFramesName] != nullptr)
	{
		delete mAnimationFrames[animationFramesName];
	}

	mAnimationFrames[animationFramesName] = createSpriteVectorCopy(frames);
}


void AnimationManager::removeAnimationFrames(const std::string& animationFramesName)
{
	if (mAnimationFrames.find(animationFramesName) != mAnimationFrames.end() && mAnimationFrames[animationFramesName] != nullptr)
	{
		delete mAnimationFrames[animationFramesName];
		mAnimationFrames.erase(animationFramesName);
	}
}


void AnimationManager::insertFrames(const std::string& animationFramesName, Sprite& newFrame, int frameIndex)
{
	insertFrames(animationFramesName, { newFrame }, frameIndex);
}


void AnimationManager::insertFramesAtBeginning(const std::string& animationFramesName, Sprite& newFrame)
{
	insertFrames(animationFramesName, newFrame, 0);
}


void AnimationManager::insertFramesAtEnd(const std::string& animationFramesName, Sprite& newFrame)
{
	insertFrames(animationFramesName, newFrame, mAnimationFrames[animationFramesName]->size());
}


void AnimationManager::insertFrames(const std::string& animationFramesName, std::vector<Sprite>& newFrames, int frameIndex)
{
	std::vector<Sprite>* vs = mAnimationFrames[animationFramesName];
	vs->insert(vs->begin() + frameIndex, newFrames.begin(), newFrames.end());
}


void AnimationManager::insertFramesAtBeginning(const std::string& animationFramesName, std::vector<Sprite>& newFrames)
{
	insertFrames(animationFramesName, newFrames, 0);
}


void AnimationManager::insertFramesAtEnd(const std::string& animationFramesName, std::vector<Sprite>& newFrames)
{
	insertFrames(animationFramesName, newFrames, mAnimationFrames[animationFramesName]->size());
}


void AnimationManager::removeFrames(const std::string& animationFramesName, int startIndexInclusive, int endIndexExclusive)
{
	std::vector<Sprite>* vs = mAnimationFrames[animationFramesName];
	vs->erase(vs->begin() + startIndexInclusive, vs->begin() + endIndexExclusive);
}


std::vector<Sprite>* AnimationManager::createSpriteVectorCopy(std::vector<Sprite>& sv)
{
	std::vector<Sprite>* returnSV = new std::vector<Sprite>();

	for (Sprite& s : sv)
	{
		returnSV->push_back(Sprite(s));
	}

	return returnSV;
}


void AnimationManager::cleanup()
{
	for (auto sk : mAnimationFrames)
	{
		delete sk.second;
	}

	mAnimationFrames.clear();

	for (auto ak : mAnimations)
	{
		delete ak.second;
	}

	mAnimations.clear();
}


Animation* AnimationManager::addAnimation(std::string name, std::string framesName, float fps, bool shouldLoop)
{
	if (mAnimations.find(name) != mAnimations.end() && mAnimations[name] != nullptr)
	{
		delete mAnimations[name];
	}

	mAnimations[name] = new Animation(*this, framesName, fps, shouldLoop);
	return mAnimations[name];
}