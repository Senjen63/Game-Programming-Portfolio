#include "PlayerMovement.h"
#include <cassert>

#include "BoxCollider.h"
#include "Game.h"

void PlayerMovement::init()
{
	EventSystem::getInstance()->addListener((EventType)PLAYER_1_MOVE_START, static_cast<EventListener*>(this));
	EventSystem::getInstance()->addListener((EventType)PLAYER_2_MOVE_START, static_cast<EventListener*>(this));
	EventSystem::getInstance()->addListener((EventType)PLAYER_1_MOVE_STOP, static_cast<EventListener*>(this));
	EventSystem::getInstance()->addListener((EventType)PLAYER_2_MOVE_STOP, static_cast<EventListener*>(this));

	EventSystem::getInstance()->addListener((EventType)PLAYER_1_TURN_START, static_cast<EventListener*>(this));
	EventSystem::getInstance()->addListener((EventType)PLAYER_2_TURN_START, static_cast<EventListener*>(this));
	EventSystem::getInstance()->addListener((EventType)PLAYER_1_TURN_STOP, static_cast<EventListener*>(this));
	EventSystem::getInstance()->addListener((EventType)PLAYER_2_TURN_STOP, static_cast<EventListener*>(this));
}

void PlayerMovement::cleanUp()
{
	EventSystem::getInstance()->removeListener((EventType)PLAYER_1_MOVE_START, static_cast<EventListener*>(this));
	EventSystem::getInstance()->removeListener((EventType)PLAYER_2_MOVE_START, static_cast<EventListener*>(this));
	EventSystem::getInstance()->removeListener((EventType)PLAYER_1_MOVE_STOP, static_cast<EventListener*>(this));
	EventSystem::getInstance()->removeListener((EventType)PLAYER_2_MOVE_STOP, static_cast<EventListener*>(this));

	EventSystem::getInstance()->removeListener((EventType)PLAYER_1_TURN_START, static_cast<EventListener*>(this));
	EventSystem::getInstance()->removeListener((EventType)PLAYER_2_TURN_START, static_cast<EventListener*>(this));
	EventSystem::getInstance()->removeListener((EventType)PLAYER_1_TURN_STOP, static_cast<EventListener*>(this));
	EventSystem::getInstance()->removeListener((EventType)PLAYER_2_TURN_STOP, static_cast<EventListener*>(this));
}

PlayerMovement::PlayerMovement(PlayerNumber playerNum, float maxSpeed, float maxTurnSpeed) :
	Component(PLAYER_MOVEMENT_NAME), mPlayerNum(playerNum), mMaxSpeed(maxSpeed), mMaxTurnSpeed(maxTurnSpeed)
{}

void PlayerMovement::Update(double deltaTime)
{
	// If we shouldn't move/turn, then mSeed/mCurrTurnSpeed is 0 and therefore does not move 
	turn(mCurrTurnSpeed);
	move(mCurrSpeed);
}

void PlayerMovement::handleEvent(const Event& theEvent)
{
	bool correctPlayer = false;

	// First get if this entity should do anything 
	switch (theEvent.getType())
	{
		/* ---============--- */
		/* ---=== Move ===--- */
		/* ---============--- */
	case PlayerEventType::PLAYER_1_MOVE_START:
		if (mPlayerNum == PlayerNumber::PLAYER_ONE) correctPlayer = true;
		break;
	case PlayerEventType::PLAYER_2_MOVE_START:
		if (mPlayerNum == PlayerNumber::PLAYER_TWO) correctPlayer = true;
		break;

	case PlayerEventType::PLAYER_1_MOVE_STOP:
		if (mPlayerNum == PlayerNumber::PLAYER_ONE) correctPlayer = true;
		break;
	case PlayerEventType::PLAYER_2_MOVE_STOP:
		if (mPlayerNum == PlayerNumber::PLAYER_TWO) correctPlayer = true;
		break;

		/* ---============--- */
		/* ---=== Turn ===--- */
		/* ---============--- */
	case PlayerEventType::PLAYER_1_TURN_START:
		if (mPlayerNum == PlayerNumber::PLAYER_ONE) correctPlayer = true;
		break;
	case PlayerEventType::PLAYER_2_TURN_START:
		if (mPlayerNum == PlayerNumber::PLAYER_TWO) correctPlayer = true;
		break;

	case PlayerEventType::PLAYER_1_TURN_STOP:
		if (mPlayerNum == PlayerNumber::PLAYER_ONE) correctPlayer = true;
		break;
	case PlayerEventType::PLAYER_2_TURN_STOP:
		if (mPlayerNum == PlayerNumber::PLAYER_TWO) correctPlayer = true;
		break;
	}

	// Now do something if you should 
	switch (theEvent.getType())
	{
		/* ---============--- */
		/* ---=== Move ===--- */
		/* ---============--- */
	case PlayerEventType::PLAYER_1_MOVE_START:
	case PlayerEventType::PLAYER_2_MOVE_START:
		if (correctPlayer)
		{
			const PlayerMoveEvent& moveEvent = static_cast<const PlayerMoveEvent&>(theEvent);

			MoveDirection dir = moveEvent.getDirection();
			assert(dir != MoveDirection::INVALID);

			mCurrSpeed = mMaxSpeed * (int)dir;
		}
		break;

	case PlayerEventType::PLAYER_1_MOVE_STOP:
	case PlayerEventType::PLAYER_2_MOVE_STOP:
		if (correctPlayer)
		{
			mCurrSpeed = 0;
		}
		break;

		/* ---============--- */
		/* ---=== Turn ===--- */
		/* ---============--- */
	case PlayerEventType::PLAYER_1_TURN_START:
	case PlayerEventType::PLAYER_2_TURN_START:
		if (correctPlayer)
		{
			const PlayerTurnEvent& turnEvent = static_cast<const PlayerTurnEvent&>(theEvent);

			TurnDirection dir = turnEvent.getTurnDirection();
			assert(dir != TurnDirection::INVALID);

			mCurrTurnSpeed = mMaxTurnSpeed * (int)dir;
		}
		break;

	case PlayerEventType::PLAYER_1_TURN_STOP:
	case PlayerEventType::PLAYER_2_TURN_STOP:
		if (correctPlayer)
		{
			mCurrTurnSpeed = 0;
		}
		break;
	}
}

void PlayerMovement::turn(float angleDiff)
{
	mpParentEntity->addtoAngle(angleDiff);
}

void PlayerMovement::move(float speed)
{
	if (mCurrSpeed == 0)
		return;

	const Vector2D& dir = mpParentEntity->getForwardVector();

	Collider* collider = static_cast<Collider*>(mpParentEntity->getComponent(COLLIDER_TYPE));
	const Collider* otherWall = Game::getInstance()->getCollisionManager()->testAddPosition(CollisionTag::WALL, collider, dir * speed);
	if (otherWall)
	{
		return;
	}

	mpParentEntity->addPosition(dir * speed);
}
