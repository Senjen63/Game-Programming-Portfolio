#include "LevelManager.h"

LevelManager::LevelManager(float cellSize)
{
	mCellSize = cellSize;

	std::string collisionBufferFilePath = "Assets/collision.png";
	mpCollisionBuffer = new GraphicsBuffer("Assets/collision.png");
	mpCollisionAnimation = new Animation(0, false);
	Sprite collisionSprite = Sprite(mpCollisionBuffer);
	mpCollisionAnimation->addSprite(collisionSprite);

	loadNextLevel();
}

LevelManager::~LevelManager()
{
	while (!mCollisionList.empty())
	{
		delete mCollisionList.back();
		mCollisionList.pop_back();
	}

	mCollisionList.clear();

	delete mpSnakeManager;
	delete mpPowerUpManager;
	delete mpCollisionAnimation;
	delete mpCollisionBuffer;
}

void LevelManager::reloadCurrentLevel()
{
	mpSnakeManager->init();
	mpPowerUpManager->clear();
}

void LevelManager::loadNextLevel()
{
	if (mManagersInitialized)
	{
		mpPowerUpManager->clear();
		mpSnakeManager->clear();
	}
	clearCurrentLevel();

	mCurrentLevel++;
	std::ifstream levelData;
	levelData.open(LEVEL_DIRECTORY + "level" + std::to_string(mCurrentLevel) + ".txt");

	if (!levelData)
	{
		EventSystem* pEventSystem = EventSystem::getInstance();
		pEventSystem->fireEvent(WinEvent());
		mCurrentLevel = 1;
		levelData.open(LEVEL_DIRECTORY + "level" + std::to_string(mCurrentLevel) + ".txt");
	}

	std::string startingSegmentsStr;
	std::getline(levelData, startingSegmentsStr);
	startingSegmentsStr.erase(0, 19);
	mStartingSegments = std::stoi(startingSegmentsStr);

	std::string segmentsToNextLevelStr;
	std::getline(levelData, segmentsToNextLevelStr);
	segmentsToNextLevelStr.erase(0, 24);
	mSegmentsToNextLevel = std::stoi(segmentsToNextLevelStr);

	std::string startingSpeedStr;
	std::getline(levelData, startingSpeedStr);
	startingSpeedStr.erase(0, 20);
	mStartingSpeed = std::stoi(startingSpeedStr);

	std::string timePerUpdateStr;
	std::getline(levelData, timePerUpdateStr);
	timePerUpdateStr.erase(0, 19);
	mTimePerUpdate = std::stof(timePerUpdateStr);

	std::string scorePerPowerUpStr;
	std::getline(levelData, scorePerPowerUpStr);
	scorePerPowerUpStr.erase(0, 20);
	mScorePerPowerUp = std::stoi(scorePerPowerUpStr);

	std::string currentLine;
	int currentRowIndex = 0;
	int currentColumnIndex = 0;

	while (!levelData.eof())
	{
		currentColumnIndex = 0;

		std::getline(levelData, currentLine);

		for (int i = 0; i < currentLine.size(); i += 2)
		{
			if (currentLine[i] == 'X')
			{
				addCollision(std::make_pair((currentColumnIndex * mCellSize) + mCellSize / 2, (currentRowIndex * mCellSize) + mCellSize / 2));
			}

			else if (currentLine[i] == 'S')
			{
				mPlayerStartPos = std::make_pair((currentColumnIndex * mCellSize) + mCellSize / 2, (currentRowIndex * mCellSize) + mCellSize / 2);
			}

			currentColumnIndex++;
		}
		currentRowIndex++;
	}

	mDisplaySize = make_pair(currentColumnIndex, currentRowIndex);

	if (!mManagersInitialized)
	{
		mpPowerUpManager = new PowerUpManager(mCellSize, mDisplaySize, mTimePerUpdate, mScorePerPowerUp);
		mpSnakeManager = new SnakeManager(mCellSize, mStartingSpeed, mStartingSegments, mPlayerStartPos);
		mManagersInitialized = true;
	}

	else
	{
		mpSnakeManager->init(mStartingSpeed, mStartingSegments, mPlayerStartPos);
	}

	levelData.close();
}

void LevelManager::clearCurrentLevel()
{
	while (!mCollisionList.empty())
	{
		delete mCollisionList.back();
		mCollisionList.pop_back();
	}
}

void LevelManager::draw(GraphicsSystem* currentGraphicsSystem)
{
	mpPowerUpManager->draw(currentGraphicsSystem);
	mpSnakeManager->draw(currentGraphicsSystem);

	std::list<CollisionObj*>::iterator i;
	for (i = mCollisionList.begin(); i != mCollisionList.end(); i++)
	{
		(*i)->draw(currentGraphicsSystem);
	}
}

void LevelManager::update(float deltaTime)
{
	std::list<CollisionObj*>::iterator i;
	for (i = mCollisionList.begin(); i != mCollisionList.end(); i++)
	{
		(*i)->update(deltaTime);
	}

	mpPowerUpManager->update(deltaTime);
	mpSnakeManager->update(deltaTime);
}

void LevelManager::addCollision(std::pair<float, float> position)
{
	CollisionObj* collisionObj = new CollisionObj(position, mpCollisionAnimation);
	mCollisionList.push_back(collisionObj);
}