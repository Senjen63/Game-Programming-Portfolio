#include "Level.h"
#include "Game.h"
#include "GameEvent.h"
#include "SpawnEvent.h"
//
//const int MAX_NUM_POWERUP = 3;
//
//enum class UnitTypes;

const int DEFAULT_MOVE_SPEED = 64;
const int TRUCK_MOVE_SPEED = 2;

void Level::init(std::string levelDataFullPath, LevelManagerNew* levelManagerOwner)
{
	EventSystem::getInstance()->addListener(EventType(GameEventType::SPAWN_LOG_EVENT), this);
	EventSystem::getInstance()->addListener(EventType(GameEventType::SPAWN_TRUCK_EVENT), this);

	mLevelManagerOwner = levelManagerOwner;

	std::ifstream input = std::ifstream(levelDataFullPath);

	if (!input.good())
	{
		throw "Level init failed";
	}

	std::string key;

	while (!input.eof())
	{
		input >> key;

		if (key == "LevelLayout") // Level layout has to be at end
		{
			placeTerrain(input);
		}
	}

	spawnFrog(Vector2D(0, 0));
}


void Level::init(std::string levelDataFullPath, LevelManagerNew* levelManagerOwner, Vector2D frogStartPos)
{
	EventSystem::getInstance()->addListener(EventType(GameEventType::SPAWN_LOG_EVENT), this);
	EventSystem::getInstance()->addListener(EventType(GameEventType::SPAWN_TRUCK_EVENT), this);

	mLevelManagerOwner = levelManagerOwner;

	std::ifstream input = std::ifstream(levelDataFullPath);

	if (!input.good())
	{
		throw "Level init failed";
	}

	std::string key;

	while (!input.eof())
	{
		input >> key;

		if (key == "LevelLayout") // Level layout has to be at end
		{
			placeTerrain(input);
		}
	}

	spawnFrog(frogStartPos);
}


void Level::cleanup()
{
	EventSystem::getInstance()->removeListenerFromAllEvents(this);
}


void Level::handleEvent(const Event& theEvent)
{
	if (mLevelManagerOwner->getCurLevel() != this)
	{
		return;
	}

	if (theEvent.getType() != (EventType)GameEventType::SPAWN_LOG_EVENT && theEvent.getType() != (EventType)GameEventType::SPAWN_TRUCK_EVENT)
	{
		return;
	}

	switch (theEvent.getType())
	{
	case EventType(GameEventType::SPAWN_TRUCK_EVENT):
		{
		const SpawnTruckEvent& stEvent = static_cast<const SpawnTruckEvent&>(theEvent);
		spawnTruck(stEvent.getY(), stEvent.getDir(), stEvent.getNum());
		}
		break;
	case EventType(GameEventType::SPAWN_LOG_EVENT):
		{
		const SpawnLogEvent& slEvent = static_cast<const SpawnLogEvent&>(theEvent);
		spawnLog(slEvent.getY(), slEvent.getDir(), slEvent.getNum());
		}
		break;
	}

}

	//const KeyPressEvent& kEvent = static_cast<const KeyPressEvent&>(theEvent);

void Level::update(int deltaTime)
{
	mLastFrogPos = getFrog()->getAttachedUnit()->getPos();
}


Level::~Level()
{
	cleanup();
}


void Level::spawnFrog(Vector2D startPos)
{
	mLastFrogPos = startPos;

	std::vector<CollisionLayer> frogCollisionMask{ CollisionLayer::WATER, CollisionLayer::TRUCK, CollisionLayer::LOG };

	std::vector<Component*> frogUnitComponents;
	frogUnitComponents.push_back(new SnakeComponent(Vector2D(0, 0), DEFAULT_MOVE_SPEED));
	frogUnitComponents.push_back(new CollisionDriver(frogCollisionMask));

	mLevelManagerOwner->mFrogParams.startPos = startPos;
	Game::getInstance()->getUnitManager()->createUnit(mLevelManagerOwner->mFrogParams, frogUnitComponents);

	SnakeComponent* sc = static_cast<SnakeComponent*>(frogUnitComponents[0]);
	sc->init(); // Need to call separate init to make sure CollisionDriver is attached to unit

	mpFrog = sc;
}


void Level::spawnTruck(int startY, Vector2D direction, int num)
{
	std::vector<CollisionLayer> truckCollisionMask{ CollisionLayer::SNAKE_HEAD };

	for (int i = 0; i < num; i++)
	{
		if (direction == Vector2D(-1, 0))
		{
			Vector2D pos = Vector2D(Game::getInstance()->getGraphicsSystem()->getBackBuffer()->getWidth() - (250 * i), startY);
			mLevelManagerOwner->mTruckParams.startPos = pos;
			mLevelManagerOwner->mTruckParams.startAnimName = "TruckRightAnim";
		}
		else if (direction == Vector2D(1, 0))
		{
			Vector2D pos = Vector2D(250* i, startY);
			mLevelManagerOwner->mTruckParams.startPos = pos;
			mLevelManagerOwner->mTruckParams.startAnimName = "TruckLeftAnim";
		}
		else
		{
			Vector2D pos = Vector2D(0, startY);
			mLevelManagerOwner->mTruckParams.startPos = pos;
			mLevelManagerOwner->mTruckParams.startAnimName = "TruckLeftAnim";
		}

		//mLevelManagerOwner->mTruckParams.startPos = startPos;

		std::vector<Component*> truckUnitComponents;
		truckUnitComponents.push_back(new TruckComponent(TRUCK_MOVE_SPEED * int(mLevelManagerOwner->getCurDiffLev()), direction));
		truckUnitComponents.push_back(new CollisionDriver(truckCollisionMask));

		Game::getInstance()->getUnitManager()->createUnit(mLevelManagerOwner->mTruckParams, truckUnitComponents);

		TruckComponent* truck = static_cast<TruckComponent*>(truckUnitComponents[0]);
		truck->init();
	}

	

	//mpTrucks.push_back(truck);
}


void Level::spawnLog(int startY, Vector2D direction, int num)
{
	std::vector<CollisionLayer> logCollisionMask{ CollisionLayer::SNAKE_HEAD };

	for (int i = 0; i < num; i++)
	{
		if (direction == Vector2D(-1, 0))
		{
			Vector2D pos = Vector2D(Game::getInstance()->getGraphicsSystem()->getBackBuffer()->getWidth() - (250 * i), startY);
			mLevelManagerOwner->mLogParams.startPos = pos;
		}
		else if (direction == Vector2D(1, 0))
		{
			Vector2D pos = Vector2D(250 * i, startY);
			mLevelManagerOwner->mLogParams.startPos = pos;
		}
		else
		{
			Vector2D pos = Vector2D(0, startY);
			mLevelManagerOwner->mLogParams.startPos = pos;
		}

		//mLevelManagerOwner->mTruckParams.startPos = startPos;

		std::vector<Component*> logUnitComponents;
		logUnitComponents.push_back(new LogComponent(TRUCK_MOVE_SPEED * int(mLevelManagerOwner->getCurDiffLev()), direction));
		logUnitComponents.push_back(new CollisionDriver(logCollisionMask));

		Game::getInstance()->getUnitManager()->createUnit(mLevelManagerOwner->mLogParams, logUnitComponents);

		LogComponent* log = static_cast<LogComponent*>(logUnitComponents[0]);
		log->init();
	}

	

	//mpLogs.push_back(log);
}


void Level::placeTerrain(std::ifstream& wallLayout)
{
	std::string row;

	int r = 0;

	while (!wallLayout.eof())
	{
		wallLayout >> row;

		for (unsigned int c = 0; c < row.size(); c++)
		{
			if (row[c] == 'g') // Place grass
			{
				for (int i = 0; i < LevelManagerNew::LEVEL_WIDTH; i++)
				{
					Vector2D pos = Vector2D(i * LevelManagerNew::CELL_SIZE, r * LevelManagerNew::CELL_SIZE);
					mLevelManagerOwner->mGrassParams.startPos = pos;
					std::vector<Component*> grassComponents;
					Game::getInstance()->getUnitManager()->createUnit(mLevelManagerOwner->mGrassParams, grassComponents);
				}
			}
			else if (row[c] == 'w') // Place water
			{
				for (int i = 0; i < LevelManagerNew::LEVEL_WIDTH; i++)
				{
					Vector2D pos = Vector2D(i * LevelManagerNew::CELL_SIZE, r * LevelManagerNew::CELL_SIZE);
					mLevelManagerOwner->mWaterParams.startPos = pos;
					std::vector<Component*> waterComponents;
					Game::getInstance()->getUnitManager()->createUnit(mLevelManagerOwner->mWaterParams, waterComponents);
				}
				EventSystem::getInstance()->fireEvent(SpawnLogEvent(r * LevelManagerNew::CELL_SIZE, mRowDirections[r], 3));
				//spawnLog(r * LevelManagerNew::CELL_SIZE, mRowDirections[r]);
			}
			else if (row[c] == 's') // Place street
			{
				for (int i = 0; i < LevelManagerNew::LEVEL_WIDTH; i++)
				{
					Vector2D pos = Vector2D(i * LevelManagerNew::CELL_SIZE, r * LevelManagerNew::CELL_SIZE);
					mLevelManagerOwner->mStreetParams.startPos = pos;
					std::vector<Component*> streetComponents;
					Game::getInstance()->getUnitManager()->createUnit(mLevelManagerOwner->mStreetParams, streetComponents);
				}
				EventSystem::getInstance()->fireEvent(SpawnTruckEvent(r * LevelManagerNew::CELL_SIZE, mRowDirections[r], 3));
				//spawnTruck(r * LevelManagerNew::CELL_SIZE, mRowDirections[r]);
			}
			else if (row[c] == '<') // Moving left
			{
				mRowDirections.push_back(Vector2D(-1, 0));
			}
			else if (row[c] == '>') // Moving right
			{
				mRowDirections.push_back(Vector2D(1, 0));
			}
		}

		std::cout << row << std::endl;

		r++;
	}
}
