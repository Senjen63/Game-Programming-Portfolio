#include "SnakeManager.h"
#include "Game.h"
#include <random>

using namespace std;

SnakeManager::SnakeManager()
{
	mSpeed = 0;
	mTimeToJump = 0;
	mDir = BASE_DIR;
	mStartX = 0;
	mStartY = 0;

	mSegments = {};
}

SnakeManager::~SnakeManager()
{
	cleanup();
}

void SnakeManager::cleanup()
{
	for (size_t i = 0; i < mSegments.size(); i++) { delete mSegments[i]; }

	mSegments.clear();
}

void SnakeManager::addSegment(Segment* toAdd)
{
	int newX = 0;
	int newY = 0;

	if (mSegments.size() > 0) {
		newX = mSegments[mSegments.size() - 1]->getX();
		newY = mSegments[mSegments.size() - 1]->getY();

		if (mSegments[mSegments.size() - 1]->getDir() == 0) { newY += SEGMENT_DISTANCE; }
		else if (mSegments[mSegments.size() - 1]->getDir() == 90) { newX -= SEGMENT_DISTANCE; }
		else if (mSegments[mSegments.size() - 1]->getDir() == 180) { newY -= SEGMENT_DISTANCE; }
		else if (mSegments[mSegments.size() - 1]->getDir() == 270) { newX += SEGMENT_DISTANCE; }

		toAdd->setDir(mSegments[mSegments.size() - 1]->getDir());
		toAdd->setPosition(newX, newY);
	}
	else {
		toAdd->setDir(BASE_DIR);
		toAdd->setPosition(mStartX, mStartY);
	}

	mSegments.push_back(toAdd);
}

void SnakeManager::removeSegment()
{
	delete mSegments[mSegments.size() - 1];
	mSegments.erase(mSegments.begin() + mSegments.size() - 1);
}

void SnakeManager::setSpeed(double newSpeed)
{
	mSpeed = newSpeed;
}

Segment* SnakeManager::getSegment(int pos)
{
	if (pos < (int)mSegments.size()) { return mSegments[pos]; }

	else { return nullptr; }
}

void SnakeManager::changeDir(int newDir)
{
	mDir = newDir;

	mSegments[0]->setDir(newDir);
}

void SnakeManager::updateAll(float elapsedTime)
{
	mTimeToJump--;
	if (mTimeToJump < 0) //update positions
	{
		for (size_t i = mSegments.size() - 1; i > 0; i--)
		{
			mSegments[i]->setPosition(mSegments[i - 1]->getX(), mSegments[i - 1]->getY());
			mSegments[i]->setDir(mSegments[i - 1]->getDir());
		}

		mTimeToJump = mSpeed;
		if (mDir == 0) { mSegments[0]->setPosition(mSegments[0]->getX(),mSegments[0]->getY() - Game::TILE_SIZE); }
		else if (mDir == 90) { mSegments[0]->setPosition(mSegments[0]->getX() + Game::TILE_SIZE, mSegments[0]->getY()); }
		else if (mDir == 180) { mSegments[0]->setPosition(mSegments[0]->getX(), mSegments[0]->getY() + Game::TILE_SIZE); }
		else if (mDir == 270) { mSegments[0]->setPosition(mSegments[0]->getX() - Game::TILE_SIZE, mSegments[0]->getY()); }
	}

	for (size_t i = 0; i < mSegments.size(); i++)
	{
		mSegments[i]->update(elapsedTime);
	}
}

void SnakeManager::drawAll()
{
	for (size_t i = 0; i < mSegments.size(); i++)
	{
		mSegments[i]->draw();
	}
}

void SnakeManager::setupSnake(int speed, int numSegments, Animation* headAnims[], Animation* bodyAnims[])
{
	mDir = BASE_DIR;
	mSpeed = speed;

	//in the middle
	mStartX = (Game::LEVEL_WIDTH / 2) * Game::TILE_SIZE;
	mStartY = (Game::LEVEL_HEIGHT / 2) * Game::TILE_SIZE;

	cleanup();

	for (int i = 0; i < numSegments; i++)
	{
		Segment* newSegment = new Segment();
		for (int j = 0; j < Game::DIR_COUNT; j++)
		{
			if (i == 0) { newSegment->setAnimation(new Animation(*headAnims[j]),j); }
			else { newSegment->setAnimation(new Animation(*bodyAnims[j]),j); }
		}

		addSegment(newSegment);
	}
}