#include "Game.h"

Game* gpGame = nullptr;

Game::Game()
{
	mWidth = DISP_WIDTH;
	mHeight = DISP_HEIGHT;
    mpSystem = new GraphicsSystem(mWidth, mHeight);
}

Game::~Game()
{
	cleanup();
}

void Game::init()
{
	mpSystem->init();
	mInput.init();
}

void Game::cleanup()
{
	mpSystem->cleanup();
}

void Game::doLoop()
{
	PerformanceTracker* pPerformanceTracker = new PerformanceTracker;

	const string INIT_TRACKER_NAME = "init";
	const string DRAW_TRACKER_NAME = "draw";
	const string WAIT_TRACKER_NAME = "wait";

	pPerformanceTracker->clearTracker("loop");

	pPerformanceTracker->startTracking("loop");

	const string ASSET_PATH = "..\\..\\common\\assets\\";
	const string BACKGROUND_FILENAME = "Woods.png";
	const string DEAN_FILENAME = "dean_sprites.png";
	const string SMURF_FILENAME = "smurf_sprites.png";
	const Vector2D vecZero(0, 0);
	const Vector2D vecSize(mWidth, mHeight);
	double animationFps = 16.0;
	double fps = 60.0;
	const int smurfRow = 4;
	const int smurfColumn = 4;
	const int scale = 1;
	float FPS_CHANGE = 20;
	float MAX_FPS = 120;
	float MIN_FPS = 1;

	Unit* pAnimations = new Unit(mpSystem->mWidth / 2, mpSystem->mHeight / 2);

	GraphicsBuffer* pWoods = new GraphicsBuffer(ASSET_PATH, BACKGROUND_FILENAME);

	GraphicsBuffer* pSmurf = new GraphicsBuffer(ASSET_PATH, SMURF_FILENAME);

	GraphicsBuffer* pDean = new GraphicsBuffer(ASSET_PATH, DEAN_FILENAME);

	Animation smurfAnimation(animationFps);

	Animation deanAnimation(animationFps);

	bool shouldContinue = true;
	double targetMS = 1000.0/fps;
	Timer timer;

	for (int i = 0; i < smurfRow; i++)
	{
		for (int k = 0; k < smurfColumn; k++)
		{
			Sprite smurfSprite(pSmurf, Vector2D(pSmurf->getWidth() / smurfRow * k, pSmurf->getHeight() / smurfColumn * i), pSmurf->getWidth() / smurfRow, pSmurf->getHeight() / smurfColumn);
			smurfAnimation.addSprite(smurfSprite);
		}
	}

	for (int i = 0; i < smurfRow; i++)
	{
		for (int k = 0; k < smurfColumn; k++)
		{
			Sprite deanSprite(pDean, Vector2D(pDean->getWidth() / smurfRow * k, pDean->getHeight() / smurfColumn * i), pDean->getWidth() / smurfRow, pDean->getHeight() / smurfColumn);
			deanAnimation.addSprite(deanSprite);
		}
	}

	pAnimations->addAnimation(smurfAnimation);
	pAnimations->addAnimation(deanAnimation);

	bool enterPressed = false;
	bool fPressed = false;
	bool sPressed = false;

	while (shouldContinue)
	{

		timer.start();

		Sprite woodsSprite(pWoods, vecZero, mWidth, mHeight);

		mpSystem->draw(vecZero, vecZero, woodsSprite, scale);

		pAnimations->draw(Vector2D(pAnimations->currentAnimation().getCurrentSprite().getLoc().getX(), pAnimations->currentAnimation().getCurrentSprite().getLoc().getY()), Vector2D(pAnimations->currentAnimation().getCurrentSprite().getWidth(), pAnimations->currentAnimation().getCurrentSprite().getHeight()), Vector2D(pAnimations->mLocationX, pAnimations->mLocationY), Vector2D(pAnimations->currentAnimation().getCurrentSprite().getWidth() * scale, pAnimations->currentAnimation().getCurrentSprite().getHeight() * scale), 1);

		mpSystem->flip();

		pAnimations->update(targetMS);

		timer.sleepUntilElapsed(targetMS);

		pPerformanceTracker->stopTracking("loop");
		cout << pPerformanceTracker->getElapsedTime("loop") << endl;

		if (mInput.getKeyState(ENTER))
		{
			if (!enterPressed)
			{
				enterPressed = true;

				pAnimations->setAnimation();
			}
		}
		else
		{
			enterPressed = false;
		}

		if (mInput.getKeyState(F))
		{
			if (!fPressed)
			{
				fPressed = true;

				cout << animationFps << endl;
				animationFps += FPS_CHANGE;
				if (animationFps > MAX_FPS)
				{
					animationFps = MAX_FPS;
				}

				cout << animationFps << endl;
				pAnimations->currentAnimation().speedUpAnim(animationFps);
			}
		}
		else
		{
			fPressed = false;
		}

		if (mInput.getKeyState(S))
		{
			if (!sPressed)
			{
				sPressed = true;

				cout << animationFps << endl;
				animationFps -= FPS_CHANGE;
				if (animationFps < MIN_FPS)
				{
					animationFps = MIN_FPS;
				}

				cout << animationFps << endl;
				pAnimations->currentAnimation().slowDownAnim(animationFps);
			}
		}
		else
		{
			sPressed = false;
		}

		if (mInput.getMouseState(LEFT))
		{
			ALLEGRO_MOUSE_STATE mouseState;
			al_get_mouse_state(&mouseState);
			pAnimations->mLocationX = mouseState.x;
			pAnimations->mLocationY = mouseState.y;

		}

		if (mInput.getKeyState(ESCAPE))
		{
			shouldContinue = false;
		}
	}
	delete pPerformanceTracker;
}