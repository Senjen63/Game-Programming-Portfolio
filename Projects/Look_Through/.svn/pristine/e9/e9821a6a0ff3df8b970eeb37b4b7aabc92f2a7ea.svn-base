#include "PowerUpManager.h"

PowerUpManager::PowerUpManager(float cellSize, std::pair<int, int> displaySize, float timePerUpdate, int scorePerPowerUp)
{
	mCellSize = cellSize;
	mDisplaySize = displaySize;
	mTimePerUpdate = timePerUpdate * 40;
	mTimeRemaining = mTimePerUpdate;
	mScorePerPowerUp = scorePerPowerUp;

	const std::string pointsBufferFilePath = "Assets/powerUp1.png";
	mpPointsBuffer = new GraphicsBuffer(pointsBufferFilePath);
	mpPointsAnimation = new Animation(0, false);
	Sprite pointsSprite = Sprite(mpPointsBuffer);
	mpPointsAnimation->addSprite(pointsSprite);

	const std::string speedUpBufferFilePath = "Assets/powerUp2.png";
	mpSpeedUpBuffer = new GraphicsBuffer(speedUpBufferFilePath);
	mpSpeedUpAnimation = new Animation(0, false);
	Sprite speedUpSprite = Sprite(mpSpeedUpBuffer);
	mpSpeedUpAnimation->addSprite(speedUpSprite);

	const std::string speedDownBufferFilePath = "Assets/powerUp3.png";
	mpSpeedDownBuffer = new GraphicsBuffer(speedDownBufferFilePath);
	mpSpeedDownAnimation = new Animation(0, false);
	Sprite speedDownSprite = Sprite(mpSpeedDownBuffer);
	mpSpeedDownAnimation->addSprite(speedDownSprite);

	const std::string addSegmentBufferFilePath = "Assets/powerUp4.png";
	mpAddSegmentBuffer = new GraphicsBuffer(addSegmentBufferFilePath);
	mpAddSegmentAnimation = new Animation(0, false);
	Sprite addSegmentSprite = Sprite(mpAddSegmentBuffer);
	mpAddSegmentAnimation->addSprite(addSegmentSprite);

	EventSystem* pEventSystem = EventSystem::getInstance();
	pEventSystem->addListener((EventType)MOVE_EVENT, this);
	pEventSystem->addListener((EventType)POWER_UP_EVENT, this);
}

PowerUpManager::~PowerUpManager()
{
	while (!mPowerUpList.empty())
	{
		delete mPowerUpList.back();
		mPowerUpList.pop_back();
	}

	mPowerUpList.clear();

	delete(mpPointsAnimation);
	delete(mpPointsBuffer);

	delete(mpSpeedUpAnimation);
	delete(mpSpeedUpBuffer);

	delete(mpSpeedDownAnimation);
	delete(mpSpeedDownBuffer);

	delete(mpAddSegmentAnimation);
	delete(mpAddSegmentBuffer);
}

void PowerUpManager::clear()
{
	while (!mPowerUpList.empty())
	{
		delete mPowerUpList.back();
		mPowerUpList.pop_back();
	}
}

void PowerUpManager::draw(GraphicsSystem* currentGraphicsSystem)
{
	std::list<PowerUp*>::iterator i;
	for (i = mPowerUpList.begin(); i != mPowerUpList.end(); i++)
	{
		(*i)->draw(currentGraphicsSystem);
	}
}

void PowerUpManager::update(float deltaTime)
{
	mTimeRemaining -= deltaTime;

	if (mTimeRemaining <= 0)
	{
		mTimeRemaining = mTimePerUpdate;

		addPowerUp();
	}
}

void PowerUpManager::addPowerUp()
{
	int totalCellsX = mDisplaySize.first;
	int totalCellsY = mDisplaySize.second;

	int randCellX = rand() % totalCellsX + 1;
	int randCellY = rand() % totalCellsY + 1;

	std::pair<float, float> randPosition = std::make_pair((randCellX * mCellSize) - (mCellSize / 2), (randCellY * mCellSize) - (mCellSize / 2));

	std::list<PowerUp*>::iterator i;
	for (i = mPowerUpList.begin(); i != mPowerUpList.end(); i++)
	{
		if ((*i)->getLocation() == randPosition)
		{
			delete *i;
			mPowerUpList.remove(*i);
			break;
		}
	}

	int powerUpTypeRand = rand() % 100 + 1;
	int powerUpType;
	PowerUp* newPowerUp;

	if (powerUpTypeRand <= 20)
	{
		powerUpType = 1;
		newPowerUp = new PowerUp(randPosition, mpSpeedUpAnimation, 1);
	}

	else if (powerUpTypeRand > 20 && powerUpTypeRand <= 40)
	{
		powerUpType = 2;
		newPowerUp = new PowerUp(randPosition, mpSpeedDownAnimation, 2);
	}

	else if (powerUpTypeRand > 40)
	{
		powerUpType = 3;
		newPowerUp = new PowerUp(randPosition, mpAddSegmentAnimation, 3);
	}

	else
	{
		powerUpType = 3;
		newPowerUp = new PowerUp(randPosition, mpAddSegmentAnimation, 3);
	}

	mPowerUpList.push_back(newPowerUp);
}

void PowerUpManager::handleEvent(const Event& theEvent)
{
	if (theEvent.getType() == MOVE_EVENT)
	{
		std::list<PowerUp*>::iterator i;
		for (i = mPowerUpList.begin(); i != mPowerUpList.end(); i++)
		{
			const MoveEvent& moveEvent = static_cast<const MoveEvent&>(theEvent);

			if (moveEvent.getPosition() == (*i)->getLocation() && moveEvent.getObjectTag() == "SnakeManager")
			{
				EventSystem* pEventSystem = EventSystem::getInstance();
				pEventSystem->fireEvent(PowerUpEvent(*i, moveEvent.getObject(), (*i)->getPowerUpType()));
				break;
			}
		}
	}

	// I feel like this could be handled better
	// Couldnt this lead to issues since the power up instance being
	// referenced might not exist anymore after this event is processed?
	if (theEvent.getType() == POWER_UP_EVENT)
	{
		const PowerUpEvent& powerUpEvent = static_cast<const PowerUpEvent&>(theEvent);

		SnakeManager* snakeInstance = dynamic_cast<SnakeManager*>(powerUpEvent.getSnake());
		const PowerUp* powerUpInstance = dynamic_cast<const PowerUp*>(powerUpEvent.getPowerUp());

		if (powerUpInstance != nullptr)
		{
			std::list<PowerUp*>::iterator i;
			for (i = mPowerUpList.begin(); i != mPowerUpList.end(); i++)
			{
				if ((*i) == powerUpInstance)
				{
					delete* i;
					mPowerUpList.remove(*i);
					break;
				}
			}

			EventSystem* mpEventSystem = EventSystem::getInstance();

			if (powerUpEvent.getPowerUpType() == 1)
			{
				snakeInstance->changeMoveSpeed(-100);
				mpEventSystem->fireEvent(UpdateScoreEvent(mScorePerPowerUp, 0));
			}

			else if (powerUpEvent.getPowerUpType() == 2)
			{
				snakeInstance->changeMoveSpeed(100);
				mpEventSystem->fireEvent(UpdateScoreEvent(mScorePerPowerUp, 0));
			}

			else if (powerUpEvent.getPowerUpType() == 3)
			{
				snakeInstance->addSegment();
				mpEventSystem->fireEvent(UpdateScoreEvent(mScorePerPowerUp, 1));
			}
		}
	}
}
