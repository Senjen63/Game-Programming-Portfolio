#include "Animation.h"
#include "Game.h"
#include "UnitManager.h"
#include "Unit.h"
#include <stdlib.h>

UnitManager::UnitManager()
{
	mNumUnits = 0;
	srand(time(NULL));
	mpSnakeHead = nullptr;
	mpSnakeTail = nullptr;
}


UnitManager::~UnitManager()
{
	CleanUp();
}


void UnitManager::CleanUp()
{
	for (int i = 0; i < mNumUnits; i++)
	{
		Unit* pUnit = mpUnits[i];
		delete pUnit;
	}
	mNumUnits = 0;
	mNumFloors = 0;
	mpFloors.clear();
	mpUnits.clear();
}
void UnitManager::CreateUnit()
{
	//create unit
	Unit* pUnit = new Unit();
	//manage the unit
	mpUnits.push_back(pUnit);
	mNumUnits++;
}

void UnitManager::CreateUnit(GraphicsBuffer* pBuffer)
{
	//create unit
	Unit* pUnit = new Unit(pBuffer);
	//manage the unit
	mpUnits.push_back(pUnit);
	mNumUnits++;
}

void UnitManager::CreateUnit(bool isWall, GraphicsBuffer* pBuffer)
{
	//create unit
	Unit* pUnit = new Unit(pBuffer);
	if (isWall) 
	{
		pUnit->SetWall();
	}
	else
	{
		pUnit->SetFloor();
	}
	//manage the unit
	mpUnits.push_back(pUnit);
	mNumUnits++;
}

void UnitManager::SetUnitPos(Vector2D& position)
{
	mpUnits[mNumUnits - 1]->SetPosition(position);
}


void UnitManager::DestroyUnit(Unit* pUnitToDestroy)
{
	for (int i = 0; i < mNumUnits; i++)
	{
		Unit* pUnit = mpUnits[i];
		if (pUnit == pUnitToDestroy)
		{
			delete pUnit;
			mpUnits.erase(mpUnits.begin() + i);
			mNumUnits--;
			break;
		}
	}
}


void UnitManager::DestroyUnits(Vector2D mousePos)
{
	Vector2D temp;
	float distance;

	for (int i = 0; i < mNumUnits; i++)
	{
		Unit* pUnit = mpUnits[i];

		distance = temp.getDistanceBetween(pUnit->GetPosition(), mousePos);

		if (distance <= (pUnit->CurrentSprite()->getWidth() / 2))
		{
			DestroyUnit(pUnit);
		}
	}
}


void UnitManager::Update(float elapsedTime)
{
	SnakeUpdate();
	TrySpawnPowerup();
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		pUnit->Update(elapsedTime);
	}
}


void UnitManager::UpdateTime(float amount)
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		pUnit->SetTime(amount);
	}
}


void UnitManager::DoAnimation()
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		pUnit->TogglePause();
	}
}


void UnitManager::Draw(GraphicsSystem* pGraphicsSystem)
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		pUnit->Draw(pGraphicsSystem);
	}
}


int UnitManager::GetNumUnits()
{
	return mNumUnits;
}


Unit* UnitManager::GetUnit()
{
	if (mpUnits.size() > 0)
		return mpUnits[0];
	else
		return nullptr;
}


Unit* UnitManager::GetUnit(int index)
{
	if (index <= mNumUnits)
		return mpUnits[index];
	else
		return NULL;
}


Unit* UnitManager::GetLastUnit()
{
	return mpUnits[mNumUnits - 1];
}


Vector2D UnitManager::GetPosition(int index)
{
	return mpUnits[index]->GetPosition();
}


void UnitManager::SetLastUnit()
{
	mpUnits[mNumUnits - 1]->SwitchAnimation();
}

void UnitManager::ChangeSnakeDirection(int newDirection)
{
	if((abs(mPrevDirection) - abs(newDirection)) != 0)
	{
		mCurrentDirection = newDirection;
	}
}

void UnitManager::SpawnSnake(Vector2D position, GraphicsBuffer* pBuffer, int startingSegments)
{
	if (mpSnakeBuffer == nullptr)
	{
		mpSnakeBuffer = pBuffer;
	}
	CreateUnit(true, pBuffer);
	mpSnakeHead = GetLastUnit();
	mpSnakeHead->SetPosition(position);
	Unit* prevUnit = GetLastUnit();
	Vector2D currPos = position;
	for (int i = 1; i < startingSegments; i++)
	{
		currPos.setX(currPos.getX() - SPRITE_WIDTH);
		CreateUnit(true, pBuffer);
		GetLastUnit()->SetPosition(currPos);
		GetLastUnit()->SetNextSegment(prevUnit);
		mpSnakeTail = GetLastUnit();
		prevUnit = GetLastUnit();
	}
	//creating vector of floors, put here for my sanity
	for(int i = 0; i < mNumUnits; i++)
	{
		if (mpUnits[i]->CheckIfFloor()) 
		{
			mpFloors.push_back(mpUnits[i]);
			mNumFloors++;
		}
	}
	SpawnFood();
}

void UnitManager::SetSnakeSpeed(int newSpeed)
{
	mSnakeSpeedTick = newSpeed;
}

void UnitManager::SpawnFood()
{
	int foodPosition = rand() % mNumFloors + 1;
	Unit* pUnit = new Unit(new Animation(Game::GetInstance()->GetBuffer(FOOD_FILENAME), FOOD_FRAMES, ANIM_TIME, true, FOOD_COLUMNS, FOOD_ROWS), mpFloors[foodPosition]->GetPosition());
	pUnit->SetPosition(mpFloors[foodPosition]->GetPosition());
	pUnit->SetFood();
	mpUnits.push_back(pUnit);
	mNumUnits++;
	mpFood = pUnit;
}

void UnitManager::TrySpawnPowerup()
{
	int chanceDrop = rand() % mPowerupFrequency + 1;
	if (chanceDrop == mPowerupFrequency) 
	{
		int powerupPosition = rand() % mNumFloors + 1;
		int powerupType = rand() % 2;
		if (powerupType == 0) 
		{
			Unit* pUnit = new Unit(new Animation(Game::GetInstance()->GetBuffer(SLOW_FILENAME), POWERUP_FRAMES, ANIM_TIME, true, POWERUP_COLUMNS, POWERUP_ROWS), mpFloors[powerupPosition]->GetPosition() - Vector2D(32, 32));
			pUnit->SetPowerUpType(1);
			pUnit->SetPosition(mpFloors[powerupPosition]->GetPosition());
			mpUnits.push_back(pUnit);
			mNumUnits++;
		}
		else
		{
			Unit* pUnit = new Unit(new Animation(Game::GetInstance()->GetBuffer(SPEED_FILENAME), POWERUP_FRAMES, ANIM_TIME, true, POWERUP_COLUMNS, POWERUP_ROWS), mpFloors[powerupPosition]->GetPosition() - Vector2D(32, 32));
			pUnit->SetPowerUpType(2);
			pUnit->SetPosition(mpFloors[powerupPosition]->GetPosition());
			mpUnits.push_back(pUnit);
			mNumUnits++;
		}
	}
}


void UnitManager::SnakeUpdate()
{
	if (mpSnakeBuffer != nullptr)
	{
		mCurrentSnakeTick++;
		//collision detection
		for (int i = 0; i < mNumUnits; i++)
		{
			if (mpUnits[i]->GetPosition() == mpSnakeHead->GetPosition())
			{
				if (mpUnits[i] != mpSnakeHead && mpUnits[i]->CheckIfWall())
				{
					Game::GetInstance()->SnakeHasDied();
				}
				else if (mpUnits[i]->CheckIfFood())
				{
					mAddingSegment = true;
					DestroyUnit(mpFood);
				}
				else if (mpUnits[i]->GetPowerUpType() != 0) 
				{
					int powerType = mpUnits[i]->GetPowerUpType();
					if (powerType == 1) 
					{
						if (!mHasSlowPowerup) 
						{
							mSnakeSpeedTick += 4;
							mHasSlowPowerup = true;
						}
						else
						{
							mSlowTick = 0;
						}
						DestroyUnit(mpUnits[i]);
					}
					else
					{
						if (!mHasSpeedPowerup)
						{
							mSnakeSpeedTick -= 4;
							mHasSpeedPowerup = true;
						}
						else
						{
							mSpeedTick = 0;
						}
						DestroyUnit(mpUnits[i]);
					}
				}
			}
		}
		if (mCurrentSnakeTick >= mSnakeSpeedTick)
		{
			Unit* tmp;
			tmp = mpSnakeHead;
			if (mAddingSegment)
			{
				Unit* pUnit = new Unit(Game::GetInstance()->GetBuffer(SNAKE_FILENAME));
				pUnit->SetWall();
				mpSnakeHead = pUnit;
				mpUnits.push_back(pUnit);
				mNumUnits++;
				switch (mCurrentDirection)
				{
				case (int)Direction::RIGHT:
					mpSnakeHead->SetPosition(Vector2D(tmp->GetPosition().getX() + SPRITE_WIDTH, tmp->GetPosition().getY()));
					break;
				case (int)Direction::LEFT:
					mpSnakeHead->SetPosition(Vector2D(tmp->GetPosition().getX() - SPRITE_WIDTH, tmp->GetPosition().getY()));
					break;
				case (int)Direction::UP:
					mpSnakeHead->SetPosition(Vector2D(tmp->GetPosition().getX(), tmp->GetPosition().getY() - SPRITE_HEIGHT));
					break;
				case (int)Direction::DOWN:
					mpSnakeHead->SetPosition(Vector2D(tmp->GetPosition().getX(), tmp->GetPosition().getY() + SPRITE_HEIGHT));
					break;
				}				
				SpawnFood();
				Game::GetInstance()->AddScore();
				mpSnakeHead->SetNextSegment(nullptr);
				tmp->SetNextSegment(mpSnakeHead);
				mAddingSegment = false;
			}
			else
			{
				switch (mCurrentDirection)
				{
				case (int)Direction::RIGHT:
					mpSnakeTail->SetPosition(Vector2D(mpSnakeHead->GetPosition().getX() + SPRITE_WIDTH, mpSnakeHead->GetPosition().getY()));
					break;
				case (int)Direction::LEFT:
					mpSnakeTail->SetPosition(Vector2D(mpSnakeHead->GetPosition().getX() - SPRITE_WIDTH, mpSnakeHead->GetPosition().getY()));
					break;
				case (int)Direction::UP:
					mpSnakeTail->SetPosition(Vector2D(mpSnakeHead->GetPosition().getX(), mpSnakeHead->GetPosition().getY() - SPRITE_HEIGHT));
					break;
				case (int)Direction::DOWN:
					mpSnakeTail->SetPosition(Vector2D(mpSnakeHead->GetPosition().getX(), mpSnakeHead->GetPosition().getY() + SPRITE_HEIGHT));
					break;
				}
				mpSnakeHead = mpSnakeTail;
				tmp->SetNextSegment(mpSnakeHead);
				mpSnakeTail = mpSnakeTail->GetLastSegment();
				mpSnakeHead->SetNextSegment(nullptr);
			}
			if (mHasSlowPowerup) 
			{
				mSlowTick++;
				if (mSlowTick >= mPowerupDuration) 
				{
					mHasSlowPowerup = false;
					mSnakeSpeedTick -= 4;
					mSlowTick = 0;
				}
			}
			if (mHasSpeedPowerup)
			{
				mSpeedTick++;
				if (mSpeedTick >= mPowerupDuration)
				{
					mHasSpeedPowerup = false;
					mSnakeSpeedTick += 4;
					mSpeedTick = 0;
				}
			}
			mCurrentSnakeTick = 0;
			mPrevDirection = mCurrentDirection;
		}
	}
}


void UnitManager::SetPowerupFrequency(int frequency)
{
	mPowerupFrequency = frequency;
}