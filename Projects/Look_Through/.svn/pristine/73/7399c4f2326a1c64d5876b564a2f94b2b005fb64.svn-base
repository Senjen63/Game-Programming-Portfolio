#include "Game.h"

// Initialization of static private members
GraphicsSystem* Game::mpGraphicsSystem = nullptr;
InputSystem* Game::mpInputSystem = nullptr;
UnitManager* Game::mpUnitManager = nullptr;
GraphicsBufferManager* Game::mpGraphicsBufferManager = nullptr;

Game::Game(float displayWidth, float displayHeight)
{
	mpGraphicsSystem = new GraphicsSystem(displayWidth, displayHeight);
	mpInputSystem = new InputSystem();
	mpGraphicsBufferManager = new GraphicsBufferManager();
	mpUnitManager = new UnitManager();
}

Game::~Game()
{
	clean();
}

void Game::init()
{
	mpGraphicsSystem->init();
	mpInputSystem->init();
}

void Game::clean()
{
	delete(mpGraphicsSystem);
	delete(mpInputSystem);
	delete(mpGraphicsBufferManager);
	delete(mpUnitManager);
}

void Game::doLoop()
{
	GraphicsSystem* pGraphicsSystem = getGraphicsSystem();
	InputSystem* pInputSystem = getInputSystem();
	UnitManager* pUnitManager = getUnitManager();
	GraphicsBufferManager* pGraphicsBufferManager = getGraphicsBufferManager();
	PerformanceTracker* pPerformanceTracker = new PerformanceTracker;

	float displayWidth = pGraphicsSystem->getDisplayWidth();
	float displayHeight = pGraphicsSystem->getDisplayHeight();

	std::pair<float, float> defaultUnitPosition = std::pair<float, float>(displayWidth / 2, displayHeight / 2);

	bool continueLoop = true;
	double targetFPS = 60;
	double targetTimeMS = 1000 / targetFPS;
	double currentTimeMS = targetTimeMS;

	float framesPerAnimationSprite = 10;
	float timePerAnimationSprite = (float)targetTimeMS * framesPerAnimationSprite;

	const std::string ASSET_PATH = "..\\..\\common\\assets\\";
	const std::string WOODS_FILENAME = "Woods.png";
	const std::string SMURFS_FILENAME = "smurf_sprites.png";
	const std::string DEAN_FILENAME = "dean_sprites.png";

	// Graphics Buffers
	pGraphicsBufferManager->addBuffer(ASSET_PATH + WOODS_FILENAME, "woodsBuffer");
	pGraphicsBufferManager->addBuffer(ASSET_PATH + SMURFS_FILENAME, "smurfsBuffer");
	pGraphicsBufferManager->addBuffer(ASSET_PATH + DEAN_FILENAME, "deanBuffer");

	// Animation
	Animation* smurfsAnimation = new Animation(timePerAnimationSprite, true);
	const float SMURF_SPRITES_PER_ROW = 4;
	const float SMURF_SPRITES_PER_COLUMN = 4;
	const float SMURF_UNIT_SCALE = 60;

	// Loading smurf animation with sprites
	for (int i = 0; i < SMURF_SPRITES_PER_COLUMN; i++)
	{
		for (int j = 0; j < SMURF_SPRITES_PER_ROW; j++)
		{
			Sprite newSmurfSprite = Sprite(pGraphicsBufferManager->getBuffer("smurfsBuffer"), SMURF_UNIT_SCALE * j, SMURF_UNIT_SCALE * i, SMURF_UNIT_SCALE, SMURF_UNIT_SCALE);
			smurfsAnimation->addSprite(newSmurfSprite);
		}
	}

	Animation* deanAnimation = new Animation(timePerAnimationSprite, true);
	const float DEAN_SPRITES_PER_ROW = 4;
	const float DEAN_SPRITES_PER_COLUMN = 4;
	const float DEAN_UNIT_SCALE = 60;

	// Loading Dean animation with sprites
	for (int i = 0; i < DEAN_SPRITES_PER_COLUMN; i++)
	{
		for (int j = 0; j < DEAN_SPRITES_PER_ROW; j++)
		{
			Sprite newDeanSprite = Sprite(pGraphicsBufferManager->getBuffer("deanBuffer"), DEAN_UNIT_SCALE * j, DEAN_UNIT_SCALE * i, DEAN_UNIT_SCALE, DEAN_UNIT_SCALE);
			deanAnimation->addSprite(newDeanSprite);
		}
	}

	bool enterHeldPreviousFrame = false;
	bool spaceHeldPreviousFrame = false;

	while (continueLoop)
	{
		pPerformanceTracker->clearTracker("loop");
		pPerformanceTracker->startTracking("loop");

		Timer timerVar;
		timerVar.start();

		InputSystem::Keys* currentKeys = pInputSystem->getKeyState();
		InputSystem::Mouse* currentMouse = pInputSystem->getMouseState();

		// Input

		// If enter is pressed, have the last unit swap between smurf and Dean animations
		if (currentKeys->mKey_Enter)
		{
			if (pUnitManager->getTotalUnits() != 0 && !enterHeldPreviousFrame)
			{
				int lastIndex = pUnitManager->getTotalUnits() - 1;
				Unit* pLastUnit = pUnitManager->getUnit(lastIndex);

				if (pLastUnit->getAnimation()->getCurrentSprite().getGraphicsBuffer() == smurfsAnimation->getCurrentSprite().getGraphicsBuffer())
				{
					pLastUnit->setAnimation(deanAnimation);
				}
				else
				{
					pLastUnit->setAnimation(smurfsAnimation);
				}

				enterHeldPreviousFrame = true;
			}
		}

		else
		{
			enterHeldPreviousFrame = false;
		}

		// If Escape is pressed, end the game loop
		if (currentKeys->mKey_Escape)
		{
			continueLoop = false;
		}

		// If space is pressed, have animations swap between being paused and active
		if (currentKeys->mKey_Space)
		{
			if (!spaceHeldPreviousFrame)
			{
				if (currentTimeMS == targetTimeMS)
				{
					currentTimeMS = 0;
				}

				else
				{
					currentTimeMS = targetTimeMS;
				}

				spaceHeldPreviousFrame = true;
			}
		}

		else
		{
			spaceHeldPreviousFrame = false;
		}

		// If left mouse is pressed, add a unit to that position
		if (currentMouse->mLeftMouse_Pressed)
		{
			pUnitManager->addUnit(currentMouse->mMousePosition, smurfsAnimation);
		}
		
		// If right mouse is pressed, delete the unit the mouse is hovering over
		if (currentMouse->mRightMouse_Pressed)
		{
			Unit* targetUnit = pUnitManager->getUnit(currentMouse->mMousePosition);
			pUnitManager->removeUnit(targetUnit);
		}

		pUnitManager->updateAll(currentTimeMS);

		pGraphicsSystem->draw(displayWidth / 2, displayHeight / 2, pGraphicsBufferManager->getBuffer("woodsBuffer"), 1, 1);
		pUnitManager->drawAll(pGraphicsSystem);

		pGraphicsSystem->flipBackBuffer();

		timerVar.sleepUntilElapsed(targetTimeMS);

		pPerformanceTracker->stopTracking("loop");
		std::cout << "Frame took " << pPerformanceTracker->getElapsedTime("loop") << " milliseconds." << std::endl;
	}

	delete smurfsAnimation;
	delete deanAnimation;

	delete pPerformanceTracker;
}