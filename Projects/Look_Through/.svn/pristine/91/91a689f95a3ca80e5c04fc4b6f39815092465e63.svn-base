#include "UnitManager.h"

void UnitManager::addUnit(Animation* anim1, Animation* anim2, Vector2D location, string code)
{
	Unit* pUnit = new Unit(anim1, anim2, location, code);

	mpUnits.push_back(pUnit);
}

void UnitManager::cleanUp()
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		delete pUnit;
	}

	mpUnits.clear();
}

void UnitManager::deleteArea(Vector2D mousePos)
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		if (pUnit->getLocationX() > (mousePos.getX() - 30) && pUnit->getLocationX() < (mousePos.getX() + 30) && pUnit->getLocationY() > (mousePos.getY() - 30) && pUnit->getLocationY() < (mousePos.getY() + 30))
		{
			deleteUnit(pUnit);
			break;
		}
	}
}

void UnitManager::deleteUnit(Unit* pUnitDestroy)
{
	for (int i = 0; i < mpUnits.size(); i++)
	{
		Unit* pUnit = mpUnits[i];

		if (pUnit == pUnitDestroy)
		{
			delete pUnit;
			mpUnits.erase(mpUnits.begin() + i);
			break;
		}
	}
}

bool UnitManager::doesCollide(Vector2D pos, bool shouldSkipFirst, string keyCode)
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		if (!shouldSkipFirst)
		{
			if (pos.getX() > pUnit->getLocationX() - 15 && pos.getX() < pUnit->getLocationX() + 15 && pos.getY() < pUnit->getLocationY() + 15 && pos.getY() > pUnit->getLocationY() - 15)
			{
				if (pUnit->getKeyCode() == keyCode)
				{
					deleteUnit(pUnit);
					return true;
				}
			}
		}
		else
		{
			shouldSkipFirst = false;
		}
	}

	return false;
}

void UnitManager::drawAll(GraphicsSystem* display)
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		display->drawPart(pUnit->draw()->getLocation(), pUnit->draw(), pUnit->getLocationX() - 30, pUnit->getLocationY() - 30);
	}
}

Vector2D UnitManager::getFirstLoc()
{
	vector<Unit*>::iterator iter = mpUnits.begin();
	Unit* pUnit = *iter;
	return pUnit->getLocation();
}

Vector2D UnitManager::getLastLoc()
{
	return mpUnits.back()->getLocation();
}

Vector2D UnitManager::getSecondLastLoc()
{
	return mpUnits[mpUnits.size() - 2]->getLocation();
}

Unit* UnitManager::getUnit()
{
	if (mpUnits.size() > 0)
	{
		Unit* pUnit = mpUnits[0];
		for (int i = 0; i < mpUnits.size(); i++)
		{
			pUnit = mpUnits[i];
		}

		return pUnit;
	}
	else
	{
		return nullptr;
	}
}

void UnitManager::moveUnit(string dir, float dist)
{
	Vector2D previous, next;
	int count = 1;

	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		
		if (count == 1)
		{
			next = pUnit->getLocation();

			if (dir == "Up")
			{
				pUnit->setLocation(Vector2D(pUnit->getLocationX(), pUnit->getLocationY() - dist));
			}
			else if (dir == "Down")
			{
				pUnit->setLocation(Vector2D(pUnit->getLocationX(), pUnit->getLocationY() + dist));
			}
			else if (dir == "Left")
			{
				pUnit->setLocation(Vector2D(pUnit->getLocationX() - dist, pUnit->getLocationY()));
			}
			else if (dir == "Right")
			{
				pUnit->setLocation(Vector2D(pUnit->getLocationX() + dist, pUnit->getLocationY()));
			}

			count++;
		}
		else if (count > 1)
		{
			previous = pUnit->getLocation();
			pUnit->setLocation(next);
			next = previous;

			count++;
		}
	}
}

void UnitManager::setShouldUpdate()
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		pUnit->setShouldUpdate();
	}
}

UnitManager::UnitManager()
{

}

UnitManager::~UnitManager()
{
}

void UnitManager::updateAll(double dt)
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		pUnit->Update(dt);
	}
}
