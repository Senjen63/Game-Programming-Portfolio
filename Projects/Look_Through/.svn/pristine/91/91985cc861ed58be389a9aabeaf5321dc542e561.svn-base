#include "..\Pieces\Pawn.h"
#include "../Game.h"

Pawn::Pawn()
{
	//new Sprite(Game::getInstance()->getGraphicsBuffer(GREEN), Vector2D(), Game::getInstance()->getSpriteWidth(), Game::getInstance()->getSpriteHeight())
	createMovePts();

}

Pawn::Pawn(GraphicsBuffer* pBuffer, Vector2D location, bool white, bool firstMove)
{
	mWhite = white;
	mFirstMove = firstMove;

	setPosition(location);
	setSprite(new Sprite(pBuffer, Vector2D(), Game::getInstance()->getSpriteWidth(), Game::getInstance()->getSpriteHeight()));
	
	createMovePts();
}

Pawn::~Pawn()
{
	cleanUp();
}

void Pawn::cleanUp()
{
	for (unsigned int i = 0; i < mpMovePts.size(); i++)
	{
		Unit* pUnit = mpMovePts[i];
		delete pUnit;
	}

	for (unsigned int i = 0; i < mpAttackPts.size(); i++)
	{
		Unit* pUnit = mpAttackPts[i];
		delete pUnit;
	}

	mpMovePts.clear();
	mpAttackPts.clear();
}

void Pawn::createMovePts()
{
	Unit* moveUnit;

	if (mWhite)
	{
		moveUnit = new Unit(Game::getInstance()->getAnimation(Game::getInstance()->getMoveString()), Vector2D(0, -80) + getPosition());
		mpMovePts.push_back(moveUnit);

		if (mFirstMove)
		{
			moveUnit = new Unit(Game::getInstance()->getAnimation(Game::getInstance()->getMoveString()), Vector2D(0, -160) + getPosition());
			mpMovePts.push_back(moveUnit);
		}

		moveUnit = new Unit(Game::getInstance()->getAnimation(Game::getInstance()->getAttackString()), Vector2D(-80, -80) + getPosition());
		mpAttackPts.push_back(moveUnit);
		moveUnit = new Unit(Game::getInstance()->getAnimation(Game::getInstance()->getAttackString()), Vector2D(80, -80) + getPosition());
		mpAttackPts.push_back(moveUnit);
	}
	else
	{
		moveUnit = new Unit(Game::getInstance()->getAnimation(Game::getInstance()->getMoveString()), Vector2D(0, 80) + getPosition());
		mpMovePts.push_back(moveUnit);

		if (mFirstMove)
		{
			moveUnit = new Unit(Game::getInstance()->getAnimation(Game::getInstance()->getMoveString()), Vector2D(0, 160) + getPosition());
			mpMovePts.push_back(moveUnit);
		}

		moveUnit = new Unit(Game::getInstance()->getAnimation(Game::getInstance()->getAttackString()), Vector2D(-80, 80) + getPosition());
		mpAttackPts.push_back(moveUnit);
		moveUnit = new Unit(Game::getInstance()->getAnimation(Game::getInstance()->getAttackString()), Vector2D(80, 80) + getPosition());
		mpAttackPts.push_back(moveUnit);
	}
}

void Pawn::draw(GraphicsSystem* pGraphicsSystem, PieceManager& team, PieceManager& otherTeam)
{
	Unit::draw(pGraphicsSystem);

	if (mSelected)
	{
		for (unsigned int i = 0; i < mpMovePts.size(); i++)
		{
			if (!otherTeam.checkPosition(mpMovePts[i]->getPosition()) && otherTeam.inBounds(mpMovePts[i]->getPosition()) && !team.checkPosition(mpMovePts[i]->getPosition()))
				mpMovePts[i]->draw(pGraphicsSystem);

			if (otherTeam.checkPosition(mpMovePts[i]->getPosition()) || team.checkPosition(mpMovePts[i]->getPosition()))
				break;
		}

		for (int i = 0; i < 2; i++)
		{
			if (otherTeam.checkPosition(mpAttackPts[i]->getPosition()) && otherTeam.inBounds(mpAttackPts[i]->getPosition()))
				mpAttackPts[i]->draw(pGraphicsSystem);
		}
	}
}

void Pawn::checkMovePts(Vector2D mousePos, PieceManager& team, PieceManager& otherTeam)
{
	Vector2D offset, tmp1, tmp2;
	bool inTheWay = false;

	for (unsigned int i = 0; i < mpMovePts.size(); i++)
	{
		if (mpMovePts[i]->checkMouseCollision(mousePos) && !otherTeam.checkPosition(mpMovePts[i]->getPosition()) && !team.checkPosition(mpMovePts[i]->getPosition()) && team.inBounds(mpMovePts[i]->getPosition()))
		{
			for (unsigned int i = 0; i < mpMovePts.size(); i++)
			{
				if (otherTeam.checkPosition(mpMovePts[i]->getPosition()) || team.checkPosition(mpMovePts[i]->getPosition()))
					if (mFirstMove && mpMovePts[1]->checkMouseCollision(mousePos))
						inTheWay = true;
			}

			tmp1 = getPosition();

			setPosition(mpMovePts[i]->getPosition());
			team.checkCheck(team, otherTeam);
			if (!team.inCheck())
			{
				if (!inTheWay)
				{
					//setPosition(mpMovePts[i]->getPosition());
					Game::getInstance()->endCurrentTurn();

					if (mWhite)
						offset = Vector2D(0, -80);
					else
						offset = Vector2D(0, 80);

					//set move pts relative to player
					for (unsigned int i = 0; i < mpMovePts.size(); i++)
					{
						mpMovePts[i]->setPosition(offset + getPosition());
						offset *= 2;
					}

					if (mWhite)
						offset = Vector2D(80, -80);
					else
						offset = Vector2D(80, 80);

					//set attack pts positions
					mpAttackPts[0]->setPosition(offset + getPosition());
					offset.setX(offset.getX() * -1);
					mpAttackPts[1]->setPosition(offset + getPosition());

					if (mFirstMove)
					{
						mFirstMove = false;
						delete mpMovePts[1];
						mpMovePts.erase(mpMovePts.begin() + 1);
					}
				}
			}
			else
			{
				setPosition(tmp1);
			}
		}
	}
	
	for (unsigned int i = 0; i < 2; i++)
	{
		if (otherTeam.checkPosition(mpAttackPts[i]->getPosition()) && mpAttackPts[i]->checkMouseCollision(mousePos) && team.inBounds(mpAttackPts[i]->getPosition()))
		{
			tmp1 = getPosition();
			tmp2 = mpAttackPts[i]->getPosition();

			setPosition(mpAttackPts[i]->getPosition());
			otherTeam.movePiece(mpAttackPts[i]->getPosition(), Vector2D(10000, 10000));
			team.checkCheck(team, otherTeam);
			if (!team.inCheck())
			{
				otherTeam.deletePiece(Vector2D(10000, 10000)/*mpAttackPts[i]->getPosition()*/);

				//setPosition(mpAttackPts[i]->getPosition());
				Game::getInstance()->endCurrentTurn();

				if (mWhite)
					offset = Vector2D(0, -80);
				else
					offset = Vector2D(0, 80);

				//set move pts relative to player
				for (unsigned int i = 0; i < mpMovePts.size(); i++)
				{
					mpMovePts[i]->setPosition(offset + getPosition());
					offset *= 2;
				}

				if (mWhite)
					offset = Vector2D(80, -80);
				else
					offset = Vector2D(80, 80);

				//set attack pts positions
				mpAttackPts[0]->setPosition(offset + getPosition());
				offset.setX(offset.getX() * -1);
				mpAttackPts[1]->setPosition(offset + getPosition());

				if (mFirstMove)
				{
					mFirstMove = false;
					delete mpMovePts[1];
					mpMovePts.erase(mpMovePts.begin() + 1);
				}
			}
			else
			{
				setPosition(tmp1);
				otherTeam.movePiece(Vector2D(10000, 10000), tmp2);
			}
		}
	}

	if (mWhite)
	{
		if (getPosition().getY() == team.getLowerBounds().getY())
			team.promote(getPosition());
	}
	else
	{
		if (getPosition().getY() == team.getUpperBounds().getY())
			team.promote(getPosition());
	}
}

void Pawn::selected(bool selected)
{
	mSelected = selected;
}

bool Pawn::checkAttackPts(Vector2D position, Vector2D& location)
{
	for (unsigned int i = 0; i < mpAttackPts.size(); i++)
	{
		if (mpAttackPts[i]->getPosition() == position)
		{
			location = getPosition();
			return true;
		}
	}
	return false;
}
