#include "LevelManager.h"
#include "Game.h"

// Used in random level picking 
#include <algorithm>
#include <numeric>
#include <time.h>

#include <cassert>

LevelManager::LevelManager(std::string loadFilePath)
{
    // Read in file names and create levels 
    ifstream fin;
    fin.open(loadFilePath);
    assert(fin.good());
    fin >> *this;
    fin.close();
}

LevelManager::~LevelManager()
{
    cleanUp();

    if (mpWallAnimation)
        delete mpWallAnimation;

    if (mpTankAnimation)
        delete mpTankAnimation;
}

void LevelManager::loadLevel(int index)
{
    unloadActiveLevel();

    mLevels[index].load();
    mActiveLevel = mLevels.begin() + index;

    mIsALevelLoaded = true;
}

void LevelManager::loadRandomLevel()
{
    loadLevel(*mCurrentRandomLevelOrder);
    mCurrentRandomLevelOrder++;

    // Rerandomize when done with this order 
    if (mCurrentRandomLevelOrder == mRandomLevelOrder.end())
    {
        randomizeLevelOrder();
        mCurrentRandomLevelOrder = mRandomLevelOrder.begin();
    }
}

void LevelManager::unloadActiveLevel()
{
    if (mIsALevelLoaded)
    {
        mActiveLevel->cleanUp();
        mActiveLevel = mLevels.end();
    }

    mIsALevelLoaded = false;
}

void LevelManager::init()
{
    if (mIsInitted)
        return;

    // Create Wall Animation 
    auto pWallBuffer = Game::getInstance()->getGraphicsBufferManager()->addBuffer(mWallAnimationPath, mWallAnimationPath);
    mpWallAnimation = new Animation(Sprite(pWallBuffer));

    // Create Tank Buffer 
    auto pTankBuffer = Game::getInstance()->getGraphicsBufferManager()->addBuffer(mTankAnimationPath, mTankAnimationPath);
    mpTankAnimation = new Animation(pTankBuffer, mTankFrameRate, mTankSize, mTankSize);

    for (Level& level : mLevels)
    {
        level.init();
    }

    // Set up random level picking 
    mGenerator.seed((unsigned int)time(NULL));
    randomizeLevelOrder();
    mCurrentRandomLevelOrder = mRandomLevelOrder.begin();

    mIsInitted = true;
}

void LevelManager::cleanUp()
{
    if (!mIsInitted)
        return;

    for (Level& level : mLevels)
    {
        level.cleanUp();
    }

    mIsInitted = false;
}

void LevelManager::update(double deltaTime)
{
    if (!mIsALevelLoaded)
        return;

    mActiveLevel->update(deltaTime);
}

void LevelManager::draw(GraphicsSystem* display)
{
    if (!mIsALevelLoaded)
        return;

    mActiveLevel->draw(display);
}

void LevelManager::randomizeLevelOrder()
{
    assert(!mLevels.empty());

    // Fill level order if it hasn't already 
    if (mRandomLevelOrder.empty())
    {
        mRandomLevelOrder = vector<int>(mLevels.size());
        std::iota(mRandomLevelOrder.begin(), mRandomLevelOrder.end(), 0); // Fills the vector with sequential numbers 
    }

    std::shuffle(mRandomLevelOrder.begin(), mRandomLevelOrder.end(), mGenerator); // Randomize this sequential list 
}

void LevelManager::loadSaveData()
{
    ifstream fin;

    fin.open(mSaveDataPath);

    if (fin)
    {
        vector<Vector2D> tankPos;
        vector<float> tankAngle;
        int index;
        fin >> index;

        for(int i = 0; i < MAX_PLAYERS; i++)
        {
            float x;
            float y;
            float angle;

            fin >> x;
            fin >> y;
            fin >> angle;

            tankPos.push_back(Vector2D(x, y));
            tankAngle.push_back(angle); //this is here, but doesent do anything, Yet!!!
        }

        unloadActiveLevel();

        mLevels[index].load(tankPos);
        mActiveLevel = mLevels.begin() + index;

        mIsALevelLoaded = true;
    }
    else 
    {
        cout << "No save found!" << endl;
        return;
    }
    fin.close();
}

void LevelManager::saveGame()
{
    ofstream fout;

    fout.open(mSaveDataPath);

    if (fout.good())
    {
        fout.clear();

        int index = mActiveLevel - mLevels.begin();
        fout << index << endl;

        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            fout << mLevels[index].getEntity(i)->getPosition().getX() << endl;
            fout << mLevels[index].getEntity(i)->getPosition().getY() << endl;
            fout << mLevels[index].getEntity(i)->getAngle() << endl;
        }
    }
    else
    {
        cout << "bzzzt... error... no data saved..." << endl;
    }
    fout.close();
}

std::istream& operator>>(std::istream& is, LevelManager& lm)
{
    std::string line;
    istringstream ss;

    /* === Player Info === */
    float speed;

    // read in tank speeds 
    is.ignore(1000, ':');
    getline(is, line);

    ss = istringstream(line);
    while (!ss.eof())
    {
        ss >> speed;
        lm.mTankSpeeds.push_back(speed);
    }
    assert(lm.mTankSpeeds.size() == MAX_NUM_SPEEDS);

    // read in bullet speeds 
    is.ignore(1000, ':');
    getline(is, line);

    ss = istringstream(line);
    while (!ss.eof())
    {
        ss >> speed;
        lm.mBulletSpeeds.push_back(speed);
    }
    assert(lm.mBulletSpeeds.size() == MAX_NUM_SPEEDS);

    // read in turn speed 
    is.ignore(1000, ':');
    is >> lm.mTurnSpeed;

    /* === Animation Info === */
    // read in wall path 
    is.ignore(1000, ':');
    is.ignore(1, ' '); // there is an extra space 
    getline(is, lm.mWallAnimationPath);

    // read in tank path 
    is.ignore(1000, ':');
    is.ignore(1, ' '); // there is an extra space 
    getline(is, lm.mTankAnimationPath);

    // read in tank animation info 
    is.ignore(1000, ':');
    is >> lm.mTankFrameRate;

    is.ignore(1000, ':');
    is >> lm.mTankSize;

    // read in save data path 
    is.ignore(1000, ':');
    is.ignore(1, ' '); // there is an extra space 
    getline(is, lm.mSaveDataPath);

    /* === Level Names === */
    while (!is.eof())
    {
        is.ignore(1000, ':');
        is.ignore(1, ' '); // there is an extra space 
        getline(is, line);
        lm.mLevels.emplace_back(line);
    }

    return is;
}
