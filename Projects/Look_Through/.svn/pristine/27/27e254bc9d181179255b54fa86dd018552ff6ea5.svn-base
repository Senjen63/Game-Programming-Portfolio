#include "Animation.h"
#include "Game.h"
#include "UnitManager.h"
#include "Unit.h"
#include <stdlib.h>
#include <time.h>

UnitManager::UnitManager()
{
	mNumUnits = 0;
	srand(time(NULL));
	mpEventSystem = EventSystem::getInstance();
}


UnitManager::~UnitManager()
{
	mpEventSystem->cleanup();
	CleanUp();
}


void UnitManager::CleanUp()
{
	mCleaning = true;
	for (int i = 0; i < mNumUnits; i++)
	{
		Unit* pUnit = mpUnits[i];
		delete pUnit;
	}
	mNumUnits = 0;
	mObstaclesSpawned = 0;
	mpUnits.clear();
}
void UnitManager::CreateUnit()
{
	//create unit
	Unit* pUnit = new Unit();
	//manage the unit
	mpUnits.push_back(pUnit);
	mNumUnits++;
}


void UnitManager::CreatePlayer(GraphicsBuffer* pBuffer, int playerPos, float animTime, float playerSpeed, int playerW, int playerH)
{
	Player* pUnit = new Player(new Animation(pBuffer, ROCKET_FRAMES, animTime, true, ROCKET_COLUMNS, ROCKET_ROWS), 
		Vector2D((mDisplayWidth - playerPos) / 2, (mDisplayHeight - Game::GetInstance()->GetSpriteHeight()) / 2));
	mpPlayer = pUnit;
	pUnit->SetPlayer(true);
	pUnit->SetHitboxDimensions(playerW, playerH);
	mpUnits.push_back(pUnit);
	mNumUnits++;
	pUnit->SetSpeed(playerSpeed);
}

void UnitManager::SetValues(int dw, int dh,  int obstacleW, int obstacleH, int gateW, int gateH, string wallBuffer)
{
	mDisplayWidth = dw;
	mDisplayHeight = dh;
	mObstacleWidth = obstacleW;
	mObstacleHeight = obstacleH;
	mGateWidth = gateW;
	mGateHeight = gateH;
	mWallBuffer = wallBuffer;
}


void UnitManager::SetObstacleSpeed(float obsSpeed)
{
	mObstacleSpeed = obsSpeed;
}


//this is a funky function, it basically is creating 4 units.
void UnitManager::SpawnObstacle()
{
	//Make parent unit
	Obstacle* pObstacle = new Obstacle();
	int obstacleOffset = rand() % (Game::GetInstance()->GetSpriteHeight() * 8) + (-Game::GetInstance()->GetSpriteHeight() * 4);
	pObstacle->SetPosition(Vector2D(mDisplayWidth + (256 * mObstaclesSpawned), (mDisplayHeight / 2) + obstacleOffset));
	pObstacle->SetSpeed(mObstacleSpeed);
	mpUnits.push_back(pObstacle);
	mNumUnits++;
	pObstacle->SetObstacle(true);
	pObstacle->SetMaxDistance(0);
	pObstacle->SetInstanceVars(Vector2D(mDisplayWidth + 256, (mDisplayHeight / 2)), Game::GetInstance()->GetSpriteHeight() * 8, -Game::GetInstance()->GetSpriteHeight() * 4);
	mObstaclesSpawned++;

	//make first wall
	Unit* pWall1 = new Unit(Game::GetInstance()->GetBuffer(mWallBuffer), mObstacleWidth, mObstacleHeight);	
	pWall1->SetPosition(pObstacle->GetPosition() - Vector2D(0, mObstacleHeight));
	pWall1->SetParent(pObstacle);
	pWall1->SetWall();
	pWall1->SetHitboxDimensions(mObstacleWidth, mObstacleHeight);
	mpUnits.push_back(pWall1);
	mNumUnits++;

	//make second wall
	Unit* pWall2 = new Unit(Game::GetInstance()->GetBuffer(mWallBuffer), mObstacleWidth, mObstacleHeight);
	pWall2->SetPosition(pObstacle->GetPosition() + Vector2D(0, mGateHeight / 1.5));
	pWall2->SetParent(pObstacle);
	pWall2->SetWall();
	pWall2->SetHitboxDimensions(mObstacleWidth, mObstacleHeight);
	mpUnits.push_back(pWall2);
	mNumUnits++;


	//make the gate
	Unit* pGate = new Unit();
	pGate->SetPosition(pObstacle->GetPosition() + Vector2D(mGateWidth * 3, 0));
	pGate->SetParent(pObstacle);
	pGate->SetGate(true);
	pGate->SetHitboxDimensions(mGateWidth, mGateHeight);
	mpUnits.push_back(pGate);
	mNumUnits++;
}


void UnitManager::CreateUnit(GraphicsBuffer* pBuffer)
{
	//create unit
	Unit* pUnit = new Unit(pBuffer, Game::GetInstance()->GetSpriteWidth(), Game::GetInstance()->GetSpriteHeight());
	//manage the unit
	mpUnits.push_back(pUnit);
	mNumUnits++;
}
//for making buttons
void UnitManager::CreateUnit(GraphicsBuffer* pBuffer, Vector2D position, int w, int h, UIEvent::UIEventType eventType)
{
	Button* pUnit = new Button(pBuffer, w, h);
	pUnit->SetPosition(position);
	pUnit->SetUI(true);
	mpUnits.push_back(pUnit);
	pUnit->SetEventType(eventType);
	pUnit->SetHitboxDimensions(w, h);
	mNumUnits++;
}

//TODO: fix looping so it cancels upon level loading
void UnitManager::UpdateUI(Vector2D mousePosition)
{
	for (int i = 0; i < mNumUnits; i++)
	{

		Unit* pUnit = mpUnits[i];
		if (pUnit->GetUI()) 
		{
			Vector2D topRight = Vector2D(pUnit->GetPosition().getX(), pUnit->GetPosition().getY());
			Vector2D bottomLeft = Vector2D(pUnit->GetPosition().getX() + pUnit->GetHitboxDimensions().getX(), pUnit->GetPosition().getY() + pUnit->GetHitboxDimensions().getY());
			//checking if the mouse position is within UI bounds
			if (mousePosition.getX() < bottomLeft.getX() &&
				mousePosition.getX() > topRight.getX() && 
				mousePosition.getY() < bottomLeft.getY() &&
				mousePosition.getY() > topRight.getY())
			{
				Button* pButton = dynamic_cast<Button*>(pUnit);
				mpEventSystem->fireEvent(UIEvent((int)pButton->GetEventType()));
			}
		}
	}
}

Vector2D UnitManager::GetObstaclePosition(int numObstacle)
{
	int obstaclesFound = 0;
	for (int i = 0; i < mNumUnits; i++)
	{
		if (mpUnits[i]->GetObstacle()) 
		{
			obstaclesFound++;
			if (obstaclesFound == numObstacle) 
			{
				return mpUnits[i]->GetPosition();
			}
		}
	}
	return Vector2D();
}

//basically the same thing as SpawnObstacle with a small twist.
void UnitManager::LoadObstacle(Vector2D obstaclePosition) 
{
	Obstacle* pObstacle = new Obstacle();
	pObstacle->SetPosition(obstaclePosition);
	pObstacle->SetSpeed(mObstacleSpeed);
	mpUnits.push_back(pObstacle);
	mNumUnits++;
	pObstacle->SetObstacle(true);
	pObstacle->SetMaxDistance(0);
	pObstacle->SetInstanceVars(Vector2D(mDisplayWidth + 256, (mDisplayHeight / 2)), Game::GetInstance()->GetSpriteHeight() * 8, -Game::GetInstance()->GetSpriteHeight() * 4);
	mObstaclesSpawned++;

	//make first wall
	Unit* pWall1 = new Unit(Game::GetInstance()->GetBuffer(mWallBuffer), mObstacleWidth, mObstacleHeight);
	pWall1->SetPosition(pObstacle->GetPosition() - Vector2D(0, mObstacleHeight));
	pWall1->SetParent(pObstacle);
	pWall1->SetWall();
	pWall1->SetHitboxDimensions(mObstacleWidth, mObstacleHeight);
	mpUnits.push_back(pWall1);
	mNumUnits++;

	//make second wall
	Unit* pWall2 = new Unit(Game::GetInstance()->GetBuffer(mWallBuffer), mObstacleWidth, mObstacleHeight);
	pWall2->SetPosition(pObstacle->GetPosition() + Vector2D(0, mGateHeight / 1.5));
	pWall2->SetParent(pObstacle);
	pWall2->SetWall();
	pWall2->SetHitboxDimensions(mObstacleWidth, mObstacleHeight);
	mpUnits.push_back(pWall2);
	mNumUnits++;


	//make the gate
	Unit* pGate = new Unit();
	pGate->SetPosition(pObstacle->GetPosition() + Vector2D(mGateWidth * 3, 0));
	pGate->SetParent(pObstacle);
	pGate->SetGate(true);
	pGate->SetHitboxDimensions(mGateWidth, mGateHeight);
	mpUnits.push_back(pGate);
	mNumUnits++;
}

void UnitManager::CreateUnit(bool isWall, GraphicsBuffer* pBuffer)
{
	//create unit
	Unit* pUnit = new Unit(pBuffer, Game::GetInstance()->GetSpriteWidth(), Game::GetInstance()->GetSpriteHeight());
	if (isWall) 
	{
		pUnit->SetWall();
	}
	//manage the unit
	mpUnits.push_back(pUnit);
	mNumUnits++;
}


void UnitManager::SetUnitPos(Vector2D& position)
{
	mpUnits[mNumUnits - 1]->SetPosition(position);
}


void UnitManager::HandleCollisions()
{
	for (int i = 0; i < mNumUnits; i++)
	{
		Unit* pUnit = mpUnits[i];
		if (!pUnit->GetPlayer()) 
		{
			if (pUnit->GetWall()) 
			{
				//wacky collision test "algorithm:
				if (mpPlayer->GetPosition().getX() < pUnit->GetPosition().getX() + pUnit->GetHitboxDimensions().getX() &&
					mpPlayer->GetPosition().getX() + mpPlayer->GetHitboxDimensions().getX() > pUnit->GetPosition().getX() &&
					mpPlayer->GetPosition().getY() < pUnit->GetPosition().getY() + pUnit->GetHitboxDimensions().getY() &&
					mpPlayer->GetPosition().getY() + mpPlayer->GetHitboxDimensions().getY() > pUnit->GetPosition().getY())
				{
					
					Game::GetInstance()->PlayerDeath();
				}
			}
			if (pUnit->GetGate()) 
			{
				if (mpPlayer->GetPosition().getX() < pUnit->GetPosition().getX() + pUnit->GetHitboxDimensions().getX() &&
					mpPlayer->GetPosition().getX() + mpPlayer->GetHitboxDimensions().getX() > pUnit->GetPosition().getX() &&
					mpPlayer->GetPosition().getY() < pUnit->GetPosition().getY() + pUnit->GetHitboxDimensions().getY() &&
					mpPlayer->GetPosition().getY() + mpPlayer->GetHitboxDimensions().getY() > pUnit->GetPosition().getY())
				{
					if (!pUnit->GetParent()->GetCollTriggered()) 
					{
						Game::GetInstance()->AddScore();
						pUnit->GetParent()->SetCollTriggered(true);
					}
				}
			}
		}
	}
}



void UnitManager::DestroyUnit(Unit* pUnitToDestroy)
{
	for (int i = 0; i < mNumUnits; i++)
	{
		Unit* pUnit = mpUnits[i];
		if (pUnit == pUnitToDestroy)
		{
			delete pUnit;
			mpUnits.erase(mpUnits.begin() + i);
			mNumUnits--;
			break;
		}
	}
}


void UnitManager::DestroyUnits(Vector2D mousePos)
{
	Vector2D temp;
	float distance;

	for (int i = 0; i < mNumUnits; i++)
	{
		Unit* pUnit = mpUnits[i];

		distance = temp.getDistanceBetween(pUnit->GetPosition(), mousePos);

		if (distance <= (pUnit->CurrentSprite()->GetWidth() / 2))
		{
			DestroyUnit(pUnit);
		}
	}
}


void UnitManager::Update(float elapsedTime)
{
	HandleCollisions();
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{

		Unit* pUnit = *iter;
		pUnit->Update(elapsedTime);
	}
}


void UnitManager::UpdateTime(float amount)
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		pUnit->SetTime(amount);
	}
}


void UnitManager::DoAnimation()
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		pUnit->TogglePause();
	}
}


void UnitManager::Draw(GraphicsSystem* pGraphicsSystem)
{
	for (vector<Unit*>::iterator iter = mpUnits.begin(); iter != mpUnits.end(); ++iter)
	{
		Unit* pUnit = *iter;
		pUnit->Draw(pGraphicsSystem);
	}
}


int UnitManager::GetNumUnits()
{
	return mNumUnits;
}


Unit* UnitManager::GetUnit()
{
	if (mpUnits.size() > 0)
		return mpUnits[0];
	else
		return nullptr;
}


Unit* UnitManager::GetUnit(int index)
{
	if (index <= mNumUnits)
		return mpUnits[index];
	else
		return NULL;
}

Player* UnitManager::GetPlayer() 
{
	Player& x = dynamic_cast<Player&>(*mpPlayer);
	return &x;
}


Unit* UnitManager::GetLastUnit()
{
	return mpUnits[mNumUnits - 1];
}


Vector2D UnitManager::GetPosition(int index)
{
	return mpUnits[index]->GetPosition();
}


void UnitManager::SetLastUnit()
{
	mpUnits[mNumUnits - 1]->SwitchAnimation();
}
