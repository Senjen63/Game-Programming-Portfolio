#include "Game.h"

Game* Game::mpsGame = nullptr;

Game::Game()
{
	mBuffers = GraphicsBufferManager();
	mUnits = UnitManager();

	mpDisplay = nullptr;
	mpInput = nullptr;

	mTargetTime = TARGET_FRAMETIME;

	mIsActive = false;
}

Game::~Game()
{
	if (mIsActive)
	{
		deinit();
	}
}


bool Game::init(int height, int width)
{
	al_init();

	bool success;

	PerformanceTracker initTracker = PerformanceTracker();

	initTracker.startTracking(INIT_TRACKER_NAME);

	mpDisplay = new GraphicsSystem(height, width);

	mpInput = new InputSystem();

	success = (mpDisplay->init() && mpInput->init());

	if (success)
	{
		mIsActive = true;
	}

	initTracker.stopTracking(INIT_TRACKER_NAME);
	cout << "Initialization took: " << initTracker.getElapsedTime(INIT_TRACKER_NAME) << " ms\n\n";
	initTracker.clearTracker(INIT_TRACKER_NAME);

	return success;
}


void Game::deinit()
{
	mpInput->deinit();
	mpDisplay->deinit();

	delete mpInput;
	mpInput = nullptr;

	delete mpDisplay;
	mpDisplay = nullptr;

	mIsActive = false;
}


GraphicsSystem* Game::getDisplay()
{
	return mpDisplay;
}


Game* Game::getInstance()
{
	assert(mpsGame != nullptr);
	return mpsGame;
}


void Game::createInstance()
{
	mpsGame = new Game();
}


void Game::destroyInstance()
{
	delete mpsGame;
	mpsGame = nullptr;
}


void Game::doLoop()
{
	PerformanceTracker loopTracker = PerformanceTracker();
	
	// Load assets and create units and animations.
	loopTracker.startTracking(ASSET_LOAD_TRACKER_NAME);
	mBuffers[BACKGROUND_PATH] = new GraphicsBuffer(ASSET_PATH + BACKGROUND_PATH);
	mBuffers[SMURF_PATH] = new GraphicsBuffer(ASSET_PATH + SMURF_PATH);
	mBuffers[DEAN_PATH] = new GraphicsBuffer(ASSET_PATH + DEAN_PATH);
	loopTracker.stopTracking(ASSET_LOAD_TRACKER_NAME);
	cout << "Asset loading took " << loopTracker.getElapsedTime(ASSET_LOAD_TRACKER_NAME) << " ms\n";

	Animation* pSmurfAnim = new Animation(mBuffers[SMURF_PATH], Vector2D(SPRITE_WIDTH, SPRITE_HEIGHT), ANIM_SPEED);
	Animation* pDeanAnim = new Animation(mBuffers[DEAN_PATH], Vector2D(SPRITE_WIDTH, SPRITE_HEIGHT), ANIM_SPEED);


	bool proceed = true;

	Timer loopTimer = Timer();
	loopTimer.start();

	double current;
	double last = loopTimer.getElapsedTime();
	double dt;

	Vector2D mousePos = Vector2D(0, 0); // Starting value

	bool leftClick = false;
	bool rightClick = false;

	bool spaceKeyPressed = false;
	bool enterKeyPressed = false;
	// We don't need to track the escape key, we can just flag to exit once it's pressed.

	bool leftClickLifted = true;
	bool rightClickLifted = true;

	bool spaceLifted = true;
	bool enterLifted = true;

	bool smurfSheetActive = true;
	bool animsPaused = false;

	// Calculate background scale once ahead of time.
	double scaleX = double(mpDisplay->getWidth()) / double(mBuffers[BACKGROUND_PATH]->getWidth());
	double scaleY = double(mpDisplay->getHeight()) / double(mBuffers[BACKGROUND_PATH]->getHeight());


	while (proceed)
	{
		loopTracker.clearTracker(LOOP_TRACKER_NAME);
		loopTracker.startTracking(LOOP_TRACKER_NAME);

		current = loopTimer.getElapsedTime();
		dt = current - last;
		last = current;

		// Get input.
		mpInput->update();
		mousePos = mpInput->getMousePosition();

		if (mpInput->getKeyState(KEY_ENTER) && enterKeyPressed)
		{
			enterKeyPressed = true;
			enterLifted = false;
		}
		else if (mpInput->getKeyState(KEY_ENTER))
		{
			enterKeyPressed = true;
		}
		else
		{
			enterKeyPressed = false;
			enterLifted = true;
		}

		if (mpInput->getKeyState(KEY_ESCAPE))
		{
			proceed = false;
		}

		if (mpInput->getKeyState(KEY_SPACE) && spaceKeyPressed)
		{
			spaceKeyPressed = true;
			spaceLifted = false;
		}
		else if (mpInput->getKeyState(KEY_SPACE))
		{
			spaceKeyPressed = true;
		}
		else
		{
			spaceKeyPressed = false;
			spaceLifted = true;
		}

		if (mpInput->getMouseButtonState(MOUSE_LEFT) && leftClick)
		{
			leftClick = true;
			leftClickLifted = false;
		}
		else if (mpInput->getMouseButtonState(MOUSE_LEFT))
		{
			leftClick = true;
		}
		else
		{
			leftClick = false;
			leftClickLifted = true;
		}

		if (mpInput->getMouseButtonState(MOUSE_RIGHT) && rightClick)
		{
			rightClick = true;
			rightClickLifted = false;
		}
		else if (mpInput->getMouseButtonState(MOUSE_RIGHT))
		{
			rightClick = true;
		}
		else
		{
			rightClick = false;
			rightClickLifted = true;
		}


		// Update game state
		// If left click is down create a smurf centered on where the mouse is.

		pSmurfAnim->clearUpdate();
		pDeanAnim->clearUpdate();

		if (leftClick && leftClickLifted) // Don't create an endless trail of smurfs.
		{
			// Set the current last smurf back to the normal sprite.
			if (mUnits.getLength() > 0)
			{
				mUnits.getUnit(mUnits.getLength() - 1)->setAnimation(pSmurfAnim);
				smurfSheetActive = true;
			}

			// Create the new unit
			Vector2D position = Vector2D(mousePos.getX() - (SPRITE_WIDTH / 2), mousePos.getY() - (SPRITE_HEIGHT / 2));
			mUnits.addUnit(pSmurfAnim, position);
		}

		// Handle right clicks
		if (rightClick && rightClickLifted)
		{
			// Check if we need to delete any smurfs.
			for (unsigned int i = 0; i < mUnits.getLength(); i++)
			{
				if ((mousePos.getX() >= mUnits.getUnit(i)->getPosition().getX() && mousePos.getX() <= mUnits.getUnit(i)->getPosition().getX() + SPRITE_WIDTH) &&
					(mousePos.getY() >= mUnits.getUnit(i)->getPosition().getY() && mousePos.getY() <= mUnits.getUnit(i)->getPosition().getY() + SPRITE_HEIGHT))
				{
					mUnits.deleteUnit(i);

					// Reset smurfSheetActive if neccessary
					if (i == mUnits.getLength())
					{
						smurfSheetActive = true;
					}

					break; // Only delete one unit per frame.
				}
			}
		}

		// Swap animations
		if (enterKeyPressed && enterLifted) // Don't swap rapidly if key is held
		{
			if (smurfSheetActive)
			{
				mUnits.getUnit(mUnits.getLength() - 1)->setAnimation(pDeanAnim);
				smurfSheetActive = false;
			}
			else
			{
				mUnits.getUnit(mUnits.getLength() - 1)->setAnimation(pSmurfAnim);
				smurfSheetActive = true;
			}
		}

		// Pause/Unpause animations
		if (spaceKeyPressed && spaceLifted)
		{
			if (!animsPaused)
			{
				animsPaused = true;
				pSmurfAnim->blockUpdate();
				pDeanAnim->blockUpdate();
			}
			else
			{
				animsPaused = false;
				pSmurfAnim->unblockUpdate();
				pSmurfAnim->clearLag();
				pDeanAnim->unblockUpdate();
				pDeanAnim->clearLag();
			}
		}

		mUnits.updateAll(dt);

		if (smurfSheetActive && mUnits.getLength() > 0) // Make sure that the two animations stay in sync even if one isn't active.
		{
			pDeanAnim->update(dt);
		}
		else if (!smurfSheetActive && mUnits.getLength() == 1)
		{
			pSmurfAnim->update(dt);
		}


		// Render
		mpDisplay->draw(Vector2D(0, 0), mBuffers[BACKGROUND_PATH], scaleX, scaleY);
		mUnits.drawAll();
		mpDisplay->flip();

		loopTracker.stopTracking(LOOP_TRACKER_NAME);
		cout << "Frame took " << loopTracker.getElapsedTime(LOOP_TRACKER_NAME) << " ms\n";

		double sleepTime = (current + mTargetTime) - loopTimer.getElapsedTime();
		if (sleepTime > 0)
		{
			cout << "Sleeping for " << sleepTime << " ms\n\n";
			loopTimer.sleep(sleepTime);
		}
	}

	mUnits.deleteAll();

	delete pSmurfAnim;
	pSmurfAnim = nullptr;
	
	delete pDeanAnim;
	pDeanAnim = nullptr;

	mBuffers.deleteAll();
}
