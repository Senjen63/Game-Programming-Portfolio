#include "Level.h"
#include <cassert>
#include <fstream>
#include <sstream>
#include "Game.h"

// Test 
#include "Color.h"

using namespace std;

const int MAX_LOOPS = 30;

Level::Level() : mFilePath(""), mFoodManager(this),
    mLevelGridSize(0), mLevelWidth(0), mLevelHeight(0), mSnakeMoveTime(0), mSnakeStartLength(0), mLengthRequirement(0) // 0 everything out 
{}

Level::Level(const std::string& filePath) :
    mFilePath(filePath), mFoodManager(this),
    mLevelGridSize(0), mLevelWidth(0), mLevelHeight(0), mSnakeMoveTime(0), mSnakeStartLength(0), mLengthRequirement(0) // 0 everything out 
{
    ifstream fin;
    fin.open(filePath);
    assert(fin.good());
    fin >> *this;
    fin.close();
}

void Level::load()
{
    if (mIsLoaded)
        return;

    // Resize display to fit this level 
    Game::getInstance()->getGraphicsSystem()->resizeDisplay(mLevelGridSize * (mLevelWidth - 1), mLevelGridSize * (mLevelHeight - 1));

    // Create Snake 
    mpSnake = new Snake(mSnakeStartLength, mLevelGridSize, getLevelCenter(), mSnakeMoveTime);
    mpSnake->init();

    mFoodManager.init();

    // Create 1 by 1 buffer to store the wall color 
    GraphicsBuffer* temp = Game::getInstance()->getGraphicsBufferManager()->addBuffer(mFilePath, 1, 1, mWallColor);
    Animation wallAnim = Animation(Sprite(temp));

    // Create Walls 
    for (const Vector2D& pos : mWallPositions)
    {
        Entity* temp = Game::getInstance()->getEntityManager()->addEntity(pos, wallAnim, mLevelGridSize);
        temp->addCollider(CollisionType::WALL);
        mWalls.push_back(temp);
    }

    EventSystem::getInstance()->fireEvent(GameLevelLoaded());

    mIsLoaded = true;
}

void Level::cleanUp()
{
    if (!mIsLoaded)
        return;

    mIsLoaded = false;

    // Delete Walls 
    for (Entity* wall : mWalls)
    {
        Game::getInstance()->getEntityManager()->deleteEntity(wall);
    }
    mWalls.clear();

    // Delete wall buffer 
    Game::getInstance()->getGraphicsBufferManager()->deleteBuffer(mFilePath);

    mFoodManager.cleanUp();

    // Delete Snake 
    mpSnake->cleanUp();

    delete mpSnake;
    mpSnake = nullptr;
}

void Level::update(double deltaTime)
{
    mpSnake->update(deltaTime);
    mFoodManager.update(deltaTime);

    if (mpSnake->getLength() >= mLengthRequirement)
        mIsDone = true;
}

Vector2D Level::getGridPos(int x, int y) const
{
    int xPos = (x * mLevelGridSize) + (mLevelGridSize * 0.5f);
    int yPos = (y * mLevelGridSize) + (mLevelGridSize * 0.5f);
    return Vector2D(xPos, yPos);
}

Vector2D Level::getLevelCenter() const
{
    int centerX = mLevelWidth / 2;
    int centerY = mLevelHeight / 2;
    return getGridPos(centerX, centerY);
}

Vector2D Level::getRandEmptyPos() const
{
    Vector2D result;
    int x, y;

    for (int count = 0; count < MAX_LOOPS; count++) // Prevent infinite loops 
    {
        // Get a random position 
        x = rand() % mLevelWidth;
        y = rand() % mLevelHeight;
        result = getGridPos(x, y);

        if (!Collider::checkForCollision(result))
            return result;
    }

    cout << "No empty position found!";
    return Vector2D();
}

void Level::updateFoodManagerRef()
{
    mFoodManager.setParentLevel(this);
}

std::istream& operator>>(std::istream& is, Level& level)
{
    is.ignore(1000, ':');
    is >> level.mLevelGridSize;

    is.ignore(1000, ':');
    is >> level.mSnakeMoveTime;
    is.ignore(1000, ':');
    is >> level.mSnakeStartLength;
    is.ignore(1000, ':');
    is >> level.mLengthRequirement;

    is >> level.mFoodManager;

    // Read in wall color 
    is.ignore(1000, ':');
    float r, g, b;
    is >> r;
    is >> g;
    is >> b;
    level.mWallColor = Color(r, g, b);

    // Read in wall positions 
    is.ignore(1000, ':');
    is.ignore(1000, '\n'); // Get rid of extra '\n'
    string line = "";

    int y = -1;
    while (!is.eof())
    {
        getline(is, line);
        if (line == "=====")
            break;

        // Read each wall 1/0 for each line 
        istringstream ss(line);

        int x = -1;
        while (!ss.eof())
        {
            bool wall = false;
            ss >> wall;

            // Add a wall if needed 
            if (wall)
                level.mWallPositions.emplace_back(level.getGridPos(x, y));

            x++;
        }

        // Set width 
        if (level.mLevelWidth == 0)
        {
            level.mLevelWidth = x;
        }
        else
        {
            // Make sure the widths are consistent 
            assert(level.mLevelWidth == x);
        }

        y++;
    }

    // Set Height 
    level.mLevelHeight = y;

    return is;
}
