#include "Snake.h"
#include "Game.h"

Snake::Snake()
{
    mInitialSpawnLocation = Vector2D(0, 0);
}
Snake::Snake(Vector2D initialSpawnLocation, Vector2D initialDirection, GraphicsBuffer* head, GraphicsBuffer* body, int num)
{
    mpEventSystem = nullptr;
    mInitialSpawnLocation = initialSpawnLocation;
    mInitialDirection = initialDirection;
    mpSnakeHeadBuffer = head;
    mpSnakeBodyBuffer = body;
    mPlayerNum = num;
}
Snake::~Snake()
{
    //Graphics Buffer deletion handled by GraphicsBufferManager, may still be used by another object
    cleanup();
}
void Snake::init() 
{
    mpEventSystem = EventSystem::getInstance();

    mpEventSystem->addListener((EventType)TURN_EVENT, this);
    mpEventSystem->addListener((EventType)COLLISION_EVENT, this);
}
void Snake::cleanup()
{
    mpSnakeHeadBuffer = nullptr;
    mpSnakeBodyBuffer = nullptr;
}
SnakeUnit* Snake::getSnakeHead()
{
    if (mSnakeBodyStorage.size() > 0)
    {
        return mSnakeBodyStorage[0];
    }

    return nullptr;
}
SnakeUnit* Snake::getSnakeTail()
{
    if (mSnakeBodyStorage.size() > 0)
    {
        return mSnakeBodyStorage[mSnakeBodyStorage.size() - 1];
    }

    return nullptr;
}
void Snake::setSnakeSpeed(float snakeSpeed) 
{ 
    if (snakeSpeed < MIN_SNAKE_SPEED)
    {
        snakeSpeed = MIN_SNAKE_SPEED;
    }

    for (unsigned int i = 1; i < mSnakeBodyStorage.size(); i++)
    {
        float framesAcross = (mpSnakeBodyBuffer->getWidth() / snakeSpeed); //how many frames it takes for body to move its length

        if (i == 1)
        {
            framesAcross = (mpSnakeHeadBuffer->getWidth() / snakeSpeed);
        }

        mSnakeBodyStorage[i]->speedChange(mSnakeSpeed, snakeSpeed, framesAcross);
    }

    mSnakeSpeed = snakeSpeed;
}
void Snake::handleEvent(const Event& currentEvent)
{
    if (mSnakeBodyStorage.size() > 0)
    {
        if (currentEvent.getType() == TURN_EVENT)
        {
            const TurnEvent& turnEvent = static_cast<const TurnEvent&>(currentEvent);
            getSnakeHead()->setDirection(turnEvent.getDirection());

            for (unsigned int i = 1; i < mSnakeBodyStorage.size(); i++)
            {
                mSnakeBodyStorage[i]->addTurn(turnEvent.getDirection(), i);
            }
        }
        if (currentEvent.getType() == COLLISION_EVENT)
        {
            const CollisionEvent& collisionEvent = static_cast<const CollisionEvent&>(currentEvent);

            if (collisionEvent.getCollider()->getType() == WALL_UNIT_TYPE)
            {
                mDead = true;
            }
            if (collisionEvent.getCollider()->getType() == SNAKE_BODY_UNIT_TYPE)
            {
                if (mSnakeBodyStorage.size() > 2) //check to make sure there is a first and second body segment
                {
                    SnakeUnit* otherCollider = static_cast<SnakeUnit*>(collisionEvent.getCollider());

                    //snake can't collide with first or second body segment or until spawned segments have started moving
                    if (otherCollider != mSnakeBodyStorage[1] && otherCollider != mSnakeBodyStorage[2] && otherCollider->getStartTimer() <= 0)
                    {
                        mDead = true;
                    }
                }
            }
            if (collisionEvent.getCollider()->getType() == FOOD_UNIT_TYPE)
            {
                addSegments(1, true);
            }
            if (collisionEvent.getCollider()->getType() == BONUS_POINTS_UNIT_TYPE)
            {
                addPoints(mFoodValue);
            }
        }
    }
}
void Snake::updateSnake(float timeElapsed)
{
    for (unsigned int i =  0; i < mSnakeBodyStorage.size(); i++)
    {
        SnakeUnit* currentSegment = mSnakeBodyStorage[i];

        currentSegment->changeLocation(currentSegment->getLocation() + (currentSegment->getDir() * mSnakeSpeed));

        if (i > 0)
        {
            Vector2D thisDirection = mSnakeBodyStorage[i]->getDir();
            Vector2D otherDirection = mSnakeBodyStorage[i - 1]->getDir();

            Vector2D thisPosition = mSnakeBodyStorage[i]->getLocation();
            Vector2D otherPosition = mSnakeBodyStorage[i - 1]->getLocation();

            if (thisDirection == otherDirection && mSnakeBodyStorage[i]->getTurnListSize() == mSnakeBodyStorage[i - 1]->getTurnListSize() && mSnakeBodyStorage[i]->getStartTimer() <= 0) 
            {
                if (abs(thisDirection.getX()) == 1)
                {
                    mSnakeBodyStorage[i]->changeLocation(Vector2D(otherPosition.getX() - (mpSnakeBodyBuffer->getWidth() * thisDirection.getX()), abs(thisDirection.getX()) * otherPosition.getY()));
                }
                else if (abs(thisDirection.getY()) == 1)
                {
                    mSnakeBodyStorage[i]->changeLocation(Vector2D(abs(thisDirection.getY()) * otherPosition.getX(), otherPosition.getY() - (mpSnakeBodyBuffer->getHeight() * thisDirection.getY())));
                }
                
            }
        }
    }
    if (mSnakeBodyStorage.size() >= mEndSegmentNum)
    {
        mpEventSystem->fireEvent(EndLevelEvent(true));
    }
    mpEventSystem->fireEvent(ScoreEvent(mScore));
}
void Snake::addSegments(unsigned int count, bool usePoints)
{
    SnakeUnit* lastUnit = getSnakeTail();

    for (unsigned int i = 0; i < count; i++)
    {
        float framesAcross = (mpSnakeBodyBuffer->getWidth() / mSnakeSpeed);

        if (mSnakeBodyStorage.size() < 2)
        {
            framesAcross = (mpSnakeHeadBuffer->getWidth() / mSnakeSpeed);
        }
        float startTimer = mSnakeBodyStorage[mSnakeBodyStorage.size() - 1]->getStartTimer() + framesAcross; 

        SnakeUnit* newUnit = new SnakeUnit(getSnakeTail()->getDir(), getSnakeTail()->getLocation(), mpSnakeBodyBuffer, DEFAULT_FPS, startTimer, framesAcross, true, SNAKE_BODY_UNIT_TYPE);
        
        if (lastUnit->getDir() != Vector2D(0, 0))
        {
            newUnit->addTurn(lastUnit->getDir(), i);
        }
        newUnit->syncTurnList(lastUnit, i + 1);

        mSnakeBodyStorage.push_back(newUnit);

        mpEventSystem->fireEvent(SpawnSnakeEvent(newUnit));
    }
    if (usePoints)
    {
        addPoints(count * mFoodValue);
    }
}
void Snake::addPoints(unsigned int count)
{
    mScore += count;
}
void Snake::clearSnake()
{
    mSnakeBodyStorage.clear();
}


void Snake::resetSnake()
{
    mDead = false;

    SnakeUnit* snakeHead = new SnakeUnit(mInitialDirection, mInitialSpawnLocation, mpSnakeHeadBuffer, DEFAULT_FPS, 0, 0, true, SNAKE_HEAD_UNIT_TYPE);
    mSnakeBodyStorage.push_back(snakeHead);
    mpEventSystem->fireEvent(SpawnSnakeEvent(snakeHead));

    addSegments(mStartSegmentNum - 1, false);
}
void Snake::startNewLevel(float snakeSpeed, unsigned int startSegments, unsigned int endSegments, int foodValue)
{
    mBaseSpeed = snakeSpeed;
    mSnakeSpeed = snakeSpeed;
    mStartSegmentNum = startSegments;
    mScore = 0;
    mEndSegmentNum = endSegments;
    mFoodValue = foodValue;

    resetSnake();
}
