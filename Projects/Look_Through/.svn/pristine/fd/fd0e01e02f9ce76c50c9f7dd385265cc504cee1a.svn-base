#include "Game.h"
#include <PerformanceTracker.h>
#include <Timer.h>

#include "UnitManager.h"

using namespace std;

Game* Game::mpsInstance = nullptr;

void Game::createGame(int width, int height, double fps)
{
	if (mpsInstance == nullptr)
	{
		mpsInstance = new Game(width, height, fps);
	}
}

void Game::deleteGame()
{
	delete mpsInstance;
	mpsInstance = nullptr;
}

Game* Game::instance()
{
	assert(mpsInstance != nullptr);

	return mpsInstance;
}

Game::Game(int width, int height, double fps)
{
	mGraphics = new GraphicsSystem(width, height);
	mInputs = new InputSystem();
	mBuffers = new GraphicsBufferManager();
	mFPS = fps;
}

Game::~Game()
{
	if (mInitted) 
	{
		cleanup();

		delete mGraphics;
		delete mInputs;
		delete mBuffers;
	}
}

bool Game::init()
{
	if (mGraphics->init() == 1) { return 1; }
	mInputs->init();

	mInitted = true;

	return 0;
}

void Game::cleanup()
{
	mGraphics->cleanup();
	mInputs->cleanup();
	mBuffers->cleanup();
}

void Game::doLoop() 
{

	//setup for main game loop
	const string ASSET_PATH = "..\\..\\common\\assets\\";
	const string BACKGROUND_FILENAME = "woods.png";
	const string SMURF_FILENAME = "smurf_sprites.png";
	const string DEAN_FILENAME = "dean_sprites.png";
	const string FONT_FILENAME = "cour.ttf";
	const float SCALE_FACTOR = 0.67f;

	const int SMURF_ROWS = 4;
	const int SMURF_COLS = 4;
	const int SMURF_SPRITE_COUNT = 16;
	const int SMURF_SIZE = 60;
	const double UNIT_SPEED_VALUE = 0.017;

	mBuffers->createBuffer(ASSET_PATH + BACKGROUND_FILENAME, "background");
	mBuffers->createBuffer(ASSET_PATH + SMURF_FILENAME, "smurfs");
	mBuffers->createBuffer(ASSET_PATH + DEAN_FILENAME, "deans");

	Sprite bgroundSpr = Sprite(mBuffers->getBuffer("background"), 0, 0);
	Sprite smurfSpr[SMURF_SPRITE_COUNT];
	Sprite deanSpr[SMURF_SPRITE_COUNT];

	int spotInSpriteArray = 0;

	for (int i = 0; i < SMURF_ROWS; i++)
	{
		for (int j = 0; j < SMURF_COLS; j++)
		{
			smurfSpr[spotInSpriteArray] = Sprite(mBuffers->getBuffer("smurfs"), j * SMURF_SIZE, i * SMURF_SIZE, SMURF_SIZE, SMURF_SIZE);
			deanSpr[spotInSpriteArray] = Sprite(mBuffers->getBuffer("deans"), j * SMURF_SIZE, i * SMURF_SIZE, SMURF_SIZE, SMURF_SIZE);
			spotInSpriteArray++;
		}
	}

	Animation* unitAnimOne = new Animation(UNIT_SPEED_VALUE, 1);
	Animation* unitAnimTwo = new Animation(UNIT_SPEED_VALUE, 1);

	for (int i = 0; i < SMURF_SPRITE_COUNT; i++) 
	{
		unitAnimOne->addSprite(smurfSpr[i]);
		unitAnimTwo->addSprite(deanSpr[i]);
	}

	UnitManager* units = new UnitManager();
	
	//game loop
	bool looping = true;

	PerformanceTracker* pPerformanceTracker = new PerformanceTracker;

	bool keepRunning = true;
	Timer timer;

	//bools to stop inputs from running each frame
	bool spacePressed = false;
	bool enterPressed = false;

	while (looping) 
	{
		pPerformanceTracker->clearTracker("loop");
		pPerformanceTracker->startTracking("loop");

		Timer loopTimer;
		loopTimer.start();

		//#1 - get user input
		if (mInputs->getKeyState(SPACE_KEY))
		{
			if (!spacePressed)
			{
				for (int i = 0; i < units->getUnitsSize(); i++)
				{
					if (units->getUnit(i)->getAnimationEnabled()) { units->getUnit(i)->disableAnimation(); }
					else { units->getUnit(i)->enableAnimation(); }
				}

				spacePressed = true;
			}
		}
		else { spacePressed = false; }

		if (mInputs->getKeyState(ENTER_KEY))
		{
			if (!enterPressed)
			{
				units->getUnit(units->getUnitsSize() - 1)->swapAnimation();

				enterPressed = true;
			}
		}
		else { enterPressed = false; }

		if (mInputs->getKeyState(ESC_KEY))
		{
			looping = false;
		}

		if (mInputs->getMouseState(LEFT_MOUSE))
		{
			Unit* newUnit = new Unit(mInputs->getMouseX() - (SMURF_SIZE / 2), mInputs->getMouseY() - (SMURF_SIZE / 2), new Animation(*unitAnimOne), new Animation(*unitAnimTwo));
			
			units->addUnit(newUnit);
		}

		if (mInputs->getMouseState(RIGHT_MOUSE))
		{
			for (int i = units->getUnitsSize() - 1; i >= 0; i--)
			{
				if (units->getUnit(i)->collision(mInputs->getMouseX(), mInputs->getMouseY())) 
				{
					units->removeUnit(i);
				}
			}
		}

		//#2 - adjust game state
		units->updateAll(mFPS);
		//units->updateAll(1);

		//#3 - draw current game state
		mGraphics->draw(0, 0, bgroundSpr, (mGraphics->getWidth() / float(mBuffers->getBuffer("background")->getWidth())));
		units->drawAll();

		mGraphics->flip();

		//#4 - wait until target time has elapsed
		loopTimer.sleepUntilElapsed(mFPS);
		pPerformanceTracker->stopTracking("loop");
		cout << "Frame Took:" << pPerformanceTracker->getElapsedTime("loop") << " ms" << endl;
	}

	delete units;
	delete unitAnimOne;
	delete unitAnimTwo;

	delete pPerformanceTracker;
}