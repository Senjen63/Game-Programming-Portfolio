#include "WaveManager.h"
#include "ChasingEnemy.h"
#include "RandomlyMovingEnemy.h"
#include "SceneManager.h"
#include "EventSystem.h"

WaveManager::WaveManager(std::vector<std::pair<float, float>> spawnLocations)
{
	mCurrentTime = mTimeBeforeNextSpawn;

	if (spawnLocations.size() == 0)
	{
		mSpawnLocations.push_back(make_pair(0, 0));
	}

	else
	{
		mSpawnLocations = spawnLocations;
	}

	mpWaveProgressText = new HUDText(make_pair(165, 24), make_pair(20, 2.75f), "Wave Progress: 0 / " + std::to_string(mWaveGoal), "Assets/ButtonAnimationData.txt");
	Game::getGame()->getMenuManager()->addUnit(mpWaveProgressText);

	mpCurrentWaveText = new HUDText(make_pair(525, 24), make_pair(12, 2.75f), "Wave 1 / " + std::to_string(mLastWave), "Assets/ButtonAnimationData.txt");
	Game::getGame()->getMenuManager()->addUnit(mpCurrentWaveText);

	EventSystem::getInstance()->addListener((EventType)ENEMY_DEATH_EVENT, this);
}

WaveManager::~WaveManager()
{
	Game::getGame()->getMenuManager()->removeUnit(mpWaveProgressText);
	Game::getGame()->getMenuManager()->removeUnit(mpCurrentWaveText);
}

void WaveManager::update(float deltaTime)
{
	mCurrentTime += deltaTime;

	if (mCurrentWave > mLastWave)
	{
		Game::getGame()->getSceneManager()->unloadScene();
		Game::getGame()->getMenuManager()->unloadMenu();
		Game::getGame()->getMenuManager()->loadMenu("Main Menu");
		std::ofstream saveData;
		saveData.open("Assets/SaveData.txt");
		saveData << "";
		saveData.close();
		return;
	}

	if (mCurrentTime >= mTimeBeforeNextSpawn)
	{
		createEnemy();
		mCurrentTime = 0;
	}
}

void WaveManager::updateSpawnLocations(std::vector<std::pair<float, float>> spawnLocations)
{
	if (spawnLocations.size() != 0)
	{
		mSpawnLocations = spawnLocations;
	}
}

void WaveManager::createEnemy()
{
	int spawnPosIndex = rand() % mSpawnLocations.size();
	std::pair<float, float> spawnPos = mSpawnLocations[spawnPosIndex];

	float gameDifficulty = Game::getGame()->getDifficulty();

	float enemyDamage = (BASE_ENEMY_DAMAGE + ((mCurrentWave / 100) * BASE_ENEMY_DAMAGE)) * gameDifficulty;
	float enemyHealth = (BASE_ENEMY_HEALTH + (mCurrentWave - 1)) * gameDifficulty ;
	float enemySpeed = (BASE_ENEMY_SPEED + (mCurrentWave - 1) / 2) * gameDifficulty;

	int randEnemyType = rand() % 2;

	Enemy* newEnemy;

	switch (randEnemyType)
	{
		case 0:
			newEnemy = new ChasingEnemy(spawnPos, make_pair(3, 3), enemyHealth, -enemyDamage, enemySpeed, "Assets/ChasingEnemyAnimationData.txt");
			break;

		case 1:
			newEnemy = new RandomlyMovingEnemy(spawnPos, make_pair(3, 3), enemyHealth, -enemyDamage, enemySpeed * 1.5, "Assets/RandomlyMovingEnemyAnimationData.txt", BASE_ENEMY_TIME_BEFORE_UPDATE);
			break;

		default:
			newEnemy = new ChasingEnemy(spawnPos, make_pair(3, 3), enemyHealth, -enemyDamage, enemySpeed, "Assets/TempCollisionAnimationData.txt");
			break;
	}

	Game::getGame()->getSceneManager()->addUnit(newEnemy);
}

void WaveManager::updateUI()
{
	mpWaveProgressText->updateText("Wave Progress: " + std::to_string(mWaveProgress) + " / " + std::to_string(mWaveGoal));
	mpWaveProgressText->updateText("Wave Progress: " + std::to_string(mWaveProgress) + " / " + std::to_string(mWaveGoal));
	mpCurrentWaveText->updateText("Wave " + std::to_string(mCurrentWave) + " / " + std::to_string(mLastWave));
}

void WaveManager::handleEvent(const Event& theEvent)
{
	mWaveProgress++;

	if (mWaveProgress >= mWaveGoal)
	{
		mCurrentWave++;
		mWaveProgress = 0;
		mWaveGoal += 1;
	}

	updateUI();
}