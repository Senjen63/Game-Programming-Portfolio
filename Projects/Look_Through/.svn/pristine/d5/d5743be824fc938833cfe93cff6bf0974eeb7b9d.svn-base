#include "Game.h"

Game* Game::mpsGame = nullptr;

Game::Game()
{
	mWidth = DISP_WIDTH;
	mHeight = DISP_HEIGHT;
    mpSystem = new GraphicsSystem(mWidth, mHeight);
}

Game::~Game()
{
	cleanup();
}


Game* Game::getInstance()
{
	return mpsGame;
}

void Game::destroyInstance()
{
	delete mpsGame;
	mpsGame = NULL;
}

void Game::createInstance()
{
	if (mpsGame == NULL)
	{
		mpsGame = new Game;
	}
}

void Game::init()
{
	mpSystem->init();
	mInput.init();
}

void Game::cleanup()
{
	mpSystem->cleanup();
	delete mpSystem;
}

void Game::doLoop()
{
	PerformanceTracker* pPerformanceTracker = new PerformanceTracker;

	const string INIT_TRACKER_NAME = "init";
	const string DRAW_TRACKER_NAME = "draw";
	const string WAIT_TRACKER_NAME = "wait";

	pPerformanceTracker->clearTracker("loop");

	pPerformanceTracker->startTracking("loop");

	const string ASSET_PATH = "..\\..\\common\\assets\\";
	const string BACKGROUND_FILENAME = "Woods.png";
	const string DEAN_FILENAME = "dean_sprites.png";
	const string SMURF_FILENAME = "smurf_sprites.png";
	const Vector2D vecZero(0, 0);
	const Vector2D vecSize(mWidth, mHeight);
	double animationFps = 16.0;
	double fps = 60.0;
	const int smurfRow = 4;
	const int smurfColumn = 4;
	const int scale = 1;
	float FPS_CHANGE = 20;
	float MAX_FPS = 120;
	float MIN_FPS = 1;

	UnitManager units;

	GraphicsBufferManager buffers;

	GraphicsBuffer* pWoods = new GraphicsBuffer(ASSET_PATH, BACKGROUND_FILENAME);

	GraphicsBuffer* pSmurf = new GraphicsBuffer(ASSET_PATH, SMURF_FILENAME);

	GraphicsBuffer* pDean = new GraphicsBuffer(ASSET_PATH, DEAN_FILENAME);

	buffers.addGraphicsBuffer(BACKGROUND_FILENAME, pWoods);
	buffers.addGraphicsBuffer(SMURF_FILENAME, pSmurf);
	buffers.addGraphicsBuffer(DEAN_FILENAME, pDean);

	Animation smurfAnimation(animationFps);

	Animation deanAnimation(animationFps);

	bool shouldContinue = true;
	double targetMS = 1000.0/fps;
	Timer timer;

	bool enterPressed = false;
	bool spacePressed = false;
	bool fPressed = false;
	bool sPressed = false;
	bool shouldAnimate = true;

	while (shouldContinue)
	{

		timer.start();

		Sprite woodsSprite(pWoods, vecZero, mWidth, mHeight);

		mpSystem->draw(vecZero, vecZero, woodsSprite, scale);

		//drawAll here:

		if (!units.isEmpty())
		{
			units.drawAll(scale);
		}

		if (shouldAnimate == false)
		{
			units.updateAll(targetMS);
		}

		mpSystem->flip();
		timer.sleepUntilElapsed(targetMS);

		pPerformanceTracker->stopTracking("loop");
		cout << pPerformanceTracker->getElapsedTime("loop") << endl;

		//inputs here:

		if (mInput.getMouseState(LEFT))
		{

			Vector2D mouseLoc = mInput.getMouseLoc();

			Unit pUnit(mouseLoc.getX(), mouseLoc.getY());

			for (int i = 0; i < smurfRow; i++)
			{
				for (int k = 0; k < smurfColumn; k++)
				{
					Sprite smurfSprite(pSmurf, Vector2D(pSmurf->getWidth() / smurfRow * k, pSmurf->getHeight() / smurfColumn * i), pSmurf->getWidth() / smurfRow, pSmurf->getHeight() / smurfColumn);
					smurfAnimation.addSprite(smurfSprite);
				}
			}

			for (int i = 0; i < smurfRow; i++)
			{
				for (int k = 0; k < smurfColumn; k++)
				{
					Sprite deanSprite(pDean, Vector2D(pDean->getWidth() / smurfRow * k, pDean->getHeight() / smurfColumn * i), pDean->getWidth() / smurfRow, pDean->getHeight() / smurfColumn);
					deanAnimation.addSprite(deanSprite);
				}
			}

			pUnit.addAnimation(smurfAnimation);
			pUnit.addAnimation(deanAnimation);

			units.addUnit(pUnit);
		}

		if (mInput.getMouseState(RIGHT))
		{
			Vector2D mouseLoc = mInput.getMouseLoc();

			units.removeUnit(mouseLoc);
		}

		if (mInput.getKeyState(ESCAPE))
		{
			shouldContinue = false;
		}

		if (mInput.getKeyState(ENTER))
		{
			if (!enterPressed)
			{
				enterPressed = true;
				units.setAnimation();
			}
		}
		else
		{
			enterPressed = false;
		}

		if (mInput.getKeyState(SPACE))
		{
			if (!spacePressed)
			{
				spacePressed = true;

				if (shouldAnimate)
				{
					shouldAnimate = false;
				}
				else
				{
					shouldAnimate = true;
				}
			}
		}
		else
		{
			spacePressed = false;
		}
	}
	delete pWoods;
	delete pSmurf;
	delete pDean;
	delete pPerformanceTracker;
}