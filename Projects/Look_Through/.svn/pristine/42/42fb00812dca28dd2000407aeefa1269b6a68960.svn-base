#include "Bullet.h"
#include "Vector2D.h"
#include "Game.h"

Bullet::Bullet(Direction dir, Vector2D location, Animation* anim, int speed) : EnemyBase{ dir, location, anim }
{
	mSpeed = speed;
	mMaxHealth = 999;
	mCurrentHealth = mMaxHealth;
	mInvFrames = 999;
}

void Bullet::move()
{
	switch (mDirection)
	{
		case UP:
		{
			Vector2D locationToMove = Vector2D(mLocation.getX(), mLocation.getY() - mSpeed);
			if (!isColliding(locationToMove)) mLocation.setY(locationToMove.getY());
			else { destroy(); return; }

			break;
		}
		case DOWN:
		{
			Vector2D locationToMove = Vector2D(mLocation.getX(), mLocation.getY() + mSpeed);
			if (!isColliding(locationToMove)) mLocation.setY(locationToMove.getY());
			else { destroy(); return; }

			break;
		}
		case LEFT:
		{
			Vector2D locationToMove = Vector2D(mLocation.getX() - mSpeed, mLocation.getY());
			if (!isColliding(locationToMove)) mLocation.setX(locationToMove.getX());
			else { destroy(); return; }

			break;
		}
		case RIGHT:
		{
			Vector2D locationToMove = Vector2D(mLocation.getX() + mSpeed, mLocation.getY());
			if (!isColliding(locationToMove)) mLocation.setX(locationToMove.getX());
			else { destroy(); return; }

			break;
		}
	}
}

bool Bullet::isColliding(Vector2D locationColliding)
{
	Game* pGame = Game::getInstance();

	float currentXPos = locationColliding.getX();
	float currentYPos = locationColliding.getY();

	for (auto wall : pGame->getLevels()->getWalls())
	{
		if (currentXPos < wall->getX() + wall->getSize() &&
			currentXPos + mCurrentSize > wall->getX() &&
			currentYPos < wall->getY() + wall->getSize() &&
			currentYPos + mCurrentSize > wall->getY())
		{
			return true;
		}
	}

	return false;
}