#include "Game.h"
#include <cstdlib> 
#include <ctime> 
#include <fstream>

Game* Game::mpsInstance = nullptr;

Game* Game::getGameInstance()
{
	//assert(mpsInstance);
	return mpsInstance;
}

void Game::destroyGameInstance()
{
	delete mpsInstance;
	mpsInstance = nullptr;
};

Game* Game::createGameInstance()
{
	if (mpsInstance == nullptr)
	{
		mpsInstance = new Game;
	}
	return mpsInstance;
}

Game::Game()
{
	const int DISP_WIDTH = 1536;
	const int DISP_HEIGHT = 768;

	EventSystem* pEventSystem = EventSystem::getInstance();
	pEventSystem->addListener((EventType)INPUT_EVENT, this);
	pEventSystem->addListener((EventType)COLLISION_EVENT, this);
	//pEventSystem->addListener((EventType)LEVEL_CHANGE_EVENT, this);

	mpAudioSystem = new AudioSystem();
	mpAnimationManager = new AnimationManager();
	mpLevelManager = new LevelManager();
	mpGraphicsBuffManager = new GraphicsBufferManager();
	mpUnitManager = new UnitManager();
	mpGraphicsSystem = new GraphicsSystem(DISP_WIDTH, DISP_HEIGHT);
	mpInputSystem = new InputSystem();
	mpSaveData = new SaveData();
}

Game::~Game()
{
	delete mpAudioSystem;
	delete mpSaveData;
	delete mpAnimationManager;
	delete mpLevelManager;
	delete mpGraphicsBuffManager;
	delete mpUnitManager;
	delete mpGraphicsSystem;
	delete mpInputSystem;
	mpAudioSystem = nullptr;
	mpSaveData = nullptr;
	mpAnimationManager = nullptr;
	mpLevelManager = nullptr;
	mpGraphicsBuffManager = nullptr;
	mpUnitManager = nullptr;
	mpGraphicsSystem = nullptr;
	mpInputSystem = nullptr;

	delete mpMusic;
	delete mpCrash;
	delete mpClick;
	mpMusic = nullptr;
	mpCrash = nullptr;
	mpClick = nullptr;
}

bool Game::init()
{
	if (!mpGraphicsSystem->init())
	{
		std::cout << "Issues with Graphics system." << std::endl;
		system("pause");
		return false;
	}
	if (!mpInputSystem->init())
	{
		std::cout << "Issues with Input system." << std::endl;
		system("pause");
		return false;
	}
	if (!mpLevelManager->init())
	{
		std::cout << "Issues with Level system." << std::endl;
		system("pause");
		return false;
	}
	if (!mpAudioSystem->init())
	{
		std::cout << "Issues with Audio system." << std::endl;
		system("pause");
		return false;
	}
	return true;
}

void Game::cleanUp()
{
	mpGraphicsSystem->cleanup();
	mpLevelManager->cleanup();
	mpAudioSystem->cleanUp();
}

void Game::doLoop()
{
	Font* pFont = new Font("cour.ttf", 50);

	mpMusic = new Audio(true, "music.mp3");
	mpClick = new Audio(false, "click.wav");
	mpCrash = new Audio(false, "crash.wav");
	
	int snakeSpeed = 0;
	int snakeSegments = 0;
	int endLength = 0;
	int foodPoints = 0;
	int powerupPower = 0;
	int powerUpFrequency = 0;

	ifstream input;
	input.open("input.txt");
	if (input.good())
	{
		string key;

		while (!input.eof())
		{
			input >> key;

			if (key == "speed")
			{
				input >> snakeSpeed;

			}
			else if (key == "segments")
			{
				input >> snakeSegments;
			}
			else if (key == "length")
			{
				input >> endLength;
			}
			else if (key == "food")
			{
				input >> foodPoints;
			}
			else if (key == "frequency")
			{
				input >> powerUpFrequency;
			}
			else if (key == "powerup")
			{
				input >> powerupPower;
			}
		}

	}
	else
	{
		return;
	}

	//Time in milliseconds.
	double targetTime = 16.7;
	const string LEVEL0_FILENAME = "Level0.txt";
	const string LEVEL1_FILENAME = "Level1.txt";
	const string LEVEL2_FILENAME = "Level2.txt";
	const string CYCLE_FILENAME = "bluelightcycle.png";
	const string TRAIL_FILENAME = "bluelightcycletrail.png";
	const string ORANGE_CYCLE_FILENAME = "orangelightcycle.png";
	const string ORANGE_TRAIL_FILENAME = "orangelightcycletrail.png";
	const string BACKGROUND_FILENAME = "LevelBackground.png";
	const string TITLESCREEN_FILENAME_EN = "TitleScreenEN.png";
	const string TITLESCREEN_FILENAME_ES = "TitleScreenES.png";
	const string TITLESCREEN_FILENAME_FR = "TitleScreenFR.png";
	const string SETTINGS_FILENAME_EN_EASY = "SettingsENEasy.png";
	const string SETTINGS_FILENAME_EN_HARD = "SettingsENHard.png";
	const string SETTINGS_FILENAME_ES_EASY = "SettingsESEasy.png";
	const string SETTINGS_FILENAME_ES_HARD = "SettingsESHard.png";
	const string SETTINGS_FILENAME_FR_EASY = "SettingsFREasy.png";
	const string SETTINGS_FILENAME_FR_HARD = "SettingsFRHard.png";
	const string PLAYER_ONE_WIN_FILENAME_EN = "Player1WinEN.png";
	const string PLAYER_TWO_WIN_FILENAME_EN = "Player2WinEN.png";
	const string PLAYER_ONE_WIN_FILENAME_ES = "Player1WinES.png";
	const string PLAYER_TWO_WIN_FILENAME_ES = "Player2WinES.png";
	const string PLAYER_ONE_WIN_FILENAME_FR = "Player1WinFR.png";
	const string PLAYER_TWO_WIN_FILENAME_FR = "Player2WinFR.png";
	const string WALL_FILENAME = "arenawall.png";
	const string POWERUP_FILENAME = "Bonus.png";
	const string FOOD_FILENAME = "Onion.png";
	string menu = "TRON  |  Press The Spacebar To Begin!  | Settings - P |  Exit - ESC";
	int spriteNum = 4;
	double fps = 30;

	const int BACKGROUND_SIZE_X = 1536;
	const int BACKGROUND_SIZE_Y = 768;
	const int WALL_SIZE = 64;
	const int SNAKE_SIZE = 64;
	Color red = Color(255, 0, 0);
	Color green = Color(0, 255, 0);
	Color blue = Color(0, 0, 255);
	Color black = Color(0, 0, 0);

	mpGraphicsBuffManager->createBuffer("backgroundImg", BACKGROUND_FILENAME, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("titleEN", TITLESCREEN_FILENAME_EN, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("titleES", TITLESCREEN_FILENAME_ES, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("titleFR", TITLESCREEN_FILENAME_FR, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("settingsEasyEN", SETTINGS_FILENAME_EN_EASY, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("settingsHardEN", SETTINGS_FILENAME_EN_HARD, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("settingsEasyES", SETTINGS_FILENAME_ES_EASY, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("settingsHardES", SETTINGS_FILENAME_ES_HARD, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("settingsEasyFR", SETTINGS_FILENAME_FR_EASY, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("settingsHardFR", SETTINGS_FILENAME_FR_HARD, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("playerOneWinEN", PLAYER_ONE_WIN_FILENAME_EN, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("playerTwoWinEN", PLAYER_TWO_WIN_FILENAME_EN, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("playerOneWinES", PLAYER_ONE_WIN_FILENAME_ES, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("playerTwoWinES", PLAYER_TWO_WIN_FILENAME_ES, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("playerOneWinFR", PLAYER_ONE_WIN_FILENAME_FR, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("playerTwoWinFR", PLAYER_TWO_WIN_FILENAME_FR, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("wallImg", WALL_FILENAME, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("player1HeadImg", CYCLE_FILENAME, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("player1BodyImg", TRAIL_FILENAME, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("player2HeadImg", ORANGE_CYCLE_FILENAME, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("player2BodyImg", ORANGE_TRAIL_FILENAME, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("foodImg", FOOD_FILENAME, mpGraphicsSystem);
	mpGraphicsBuffManager->createBuffer("powerupImg", POWERUP_FILENAME, mpGraphicsSystem);

	mpAnimationManager->createAnim("snakeHead", mpGraphicsBuffManager->getBuffer("player1HeadImg"), 1, 1, fps, false);
	mpAnimationManager->createAnim("snakeBody", mpGraphicsBuffManager->getBuffer("player1BodyImg"), 1, 1, fps, false);
	mpAnimationManager->createAnim("snakeHead2", mpGraphicsBuffManager->getBuffer("player2HeadImg"), 1, 1, fps, false);
	mpAnimationManager->createAnim("snakeBody2", mpGraphicsBuffManager->getBuffer("player2BodyImg"), 1, 1, fps, false);
	mpAnimationManager->createAnim("wall", mpGraphicsBuffManager->getBuffer("wallImg"), 1, 1, fps, false);
	mpAnimationManager->createAnim("food", mpGraphicsBuffManager->getBuffer("foodImg"), 2, 2, fps - 10, true);
	mpAnimationManager->createAnim("powerup", mpGraphicsBuffManager->getBuffer("powerupImg"), 2, 2, fps - 10, true);

	mpLevelManager->loadLevel(LEVEL0_FILENAME, mpGraphicsBuffManager->getBuffer("wallImg"));
	mpLevelManager->loadLevel(LEVEL1_FILENAME, mpGraphicsBuffManager->getBuffer("wallImg"));
	mpLevelManager->loadLevel(LEVEL2_FILENAME, mpGraphicsBuffManager->getBuffer("wallImg"));

	mpLevelManager->instantiateLevel(0, mpUnitManager, mpAnimationManager, mpGraphicsBuffManager->getBuffer("wallImg"));


	//Create snake
	Snake* snake = new Snake(true, 256, 256, mpUnitManager, mpAnimationManager, mpGraphicsBuffManager, snakeSegments);
	Snake* snake2 = new Snake(false, BACKGROUND_SIZE_X - 256, BACKGROUND_SIZE_Y - 256, mpUnitManager, mpAnimationManager, mpGraphicsBuffManager, snakeSegments);

	//Level data
	Level* currentLevel = mpLevelManager->getCurrentLevel();

	//Plays music
	mpAudioSystem->playLoopingMusic(mpMusic);

	bool didWin = false;

	while (mShouldContinue)
	{

		while (mShouldContinue && !mStartLevel && !mEnterSettings)
		{
			//TRON  |  Press The Spacebar To Begin!  | Settings - P |  Exit - ESC
			mpInputSystem->update();
			if (mLangSetEN)
			{
				mpGraphicsSystem->draw(mpGraphicsBuffManager->getBuffer("titleEN"), 0, 0, 1, 1);
				mpGraphicsSystem->displayMessage(mpGraphicsSystem->
					getWidth() / 2, mpGraphicsSystem->getHeight() / 2,
					"Toast",
					Color(255, 255, 255),
					pFont);
			}
			else if (mLangSetES)
			{
				mpGraphicsSystem->draw(mpGraphicsBuffManager->getBuffer("titleES"), 0, 0, 1, 1);
			}
			else if (mLangSetFR)
			{
				mpGraphicsSystem->draw(mpGraphicsBuffManager->getBuffer("titleFR"), 0, 0, 1, 1);
			}
			mpGraphicsSystem->flip();
		}

		while (mShouldContinue && !mStartLevel && mEnterSettings)
		{
			mpInputSystem->update();
			//std::cout << "TEST" << std::endl;
			if (mLangSetEN && !mLangSetES && !mLangSetFR)
			{
				mpGraphicsSystem->draw(mpGraphicsBuffManager->getBuffer("settingsEasyEN"), 0, 0, 1, 1);
				mpGraphicsSystem->displayMessage(mpGraphicsSystem->
					getWidth() / 2, mpGraphicsSystem->getHeight() / 2,
					"Cnut",
					Color(255, 255, 255),
					pFont);
			}
			else if (!mLangSetEN && mLangSetES && !mLangSetFR)
			{
				mpGraphicsSystem->draw(mpGraphicsBuffManager->getBuffer("settingsEasyES"), 0, 0, 1, 1);
				mpGraphicsSystem->displayMessage(mpGraphicsSystem->
					getWidth() / 2, mpGraphicsSystem->getHeight() / 2,
					"Fcuk",
					Color(255, 255, 255),
					pFont);
			}
			else if (!mLangSetEN && !mLangSetES && mLangSetFR)
			{
				mpGraphicsSystem->draw(mpGraphicsBuffManager->getBuffer("settingsEasyFR"), 0, 0, 1, 1);
				mpGraphicsSystem->displayMessage(mpGraphicsSystem->
					getWidth() / 2, mpGraphicsSystem->getHeight() / 2,
					"Shit",
					Color(255, 255, 255),
					pFont);
			}
			mpGraphicsSystem->flip();
		}

		int numLoops = 0;
		while (mShouldContinue && mStartLevel)
		{
			Timer theTimer;
			theTimer.start();

			//Moves the snake.
			if (numLoops % snakeSpeed == 0 && mDirection != 0)
			{
				vector<Unit*> snakePieces = snake->getSnakePieces();
				Unit* head = snakePieces[0];
				vector<Vector2D> snakeLocations;

				for (int i = 0; i < snakePieces.size(); i++)
				{
					snakeLocations.push_back(snakePieces[i]->getLocation());
				}

				Vector2D headLocation = head->getLocation();

				switch (mDirection)
				{
				case 1:
					head->setLocation(Vector2D(headLocation.getX(), headLocation.getY() - SNAKE_SIZE));
					break;
				case 2:
					head->setLocation(Vector2D(headLocation.getX(), headLocation.getY() + SNAKE_SIZE));
					break;
				case 3:
					head->setLocation(Vector2D(headLocation.getX() - SNAKE_SIZE, headLocation.getY()));
					break;
				case 4:
					head->setLocation(Vector2D(headLocation.getX() + SNAKE_SIZE, headLocation.getY()));
					break;
				default:
					//Do nothing
					break;
				}

				for (int i = 1; i < snakePieces.size(); i++)
				{
					snakePieces[i]->setLocation(snakeLocations[i - 1]);
				}
				snake->addSnakePiece(snakeLocations[snakeLocations.size() - 1]);

				snakeLocations.clear();
			}

			//Move snake 2
			if (numLoops % snakeSpeed == 0 && mDirection2 != 0)
			{
				vector<Unit*> snakePieces2 = snake2->getSnakePieces();
				Unit* head2 = snakePieces2[0];
				vector<Vector2D> snakeLocations2;

				for (int i = 0; i < snakePieces2.size(); i++)
				{
					snakeLocations2.push_back(snakePieces2[i]->getLocation());
				}

				Vector2D headLocation2 = head2->getLocation();

				switch (mDirection2)
				{
				case 5:
					head2->setLocation(Vector2D(headLocation2.getX(), headLocation2.getY() - SNAKE_SIZE));
					break;
				case 6:
					head2->setLocation(Vector2D(headLocation2.getX(), headLocation2.getY() + SNAKE_SIZE));
					break;
				case 7:
					head2->setLocation(Vector2D(headLocation2.getX() - SNAKE_SIZE, headLocation2.getY()));
					break;
				case 8:
					head2->setLocation(Vector2D(headLocation2.getX() + SNAKE_SIZE, headLocation2.getY()));
					break;
				default:
					//Do nothing
					break;
				}

				for (int i = 1; i < snakePieces2.size(); i++)
				{
					snakePieces2[i]->setLocation(snakeLocations2[i - 1]);
				}

				snake2->addSnakePiece(snakeLocations2[snakeLocations2.size() - 1]);

				snakeLocations2.clear();
			}

			if (numLoops % powerUpFrequency == 0)
			{
				//createConsumable(currentLevel, snake, false);
			}
			if (mIsPoweredUp)
			{
				snakeSpeed += powerupPower;
				mIsPoweredUp = false;
			}

			mpInputSystem->update();

			mpGraphicsSystem->draw(mpGraphicsBuffManager->getBuffer("backgroundImg"), 0, 0, 1, 1);

			mpUnitManager->updateAll(targetTime);
			mpUnitManager->collisionCheck();
			mpUnitManager->drawAll();

			mpGraphicsSystem->flip();

			theTimer.sleepUntilElapsed(targetTime);
			numLoops++;
		}
		if (mScored && !mStartLevel) //Could be used for score???
		{
			//mpHUD->addScore(foodPoints);

			if (mSnakeOne)
			{
				snake->addScore();
				mSnake1Score++;
				//add score to hud
				//Reset pos and units
				mScored = false;
			}
			else if (!mSnakeOne)
			{
				snake2->addScore();
				mSnake2Score++;
				//add score to hud
				//Reset pos and units
				mScored = false;
			}

			mScored = false;
			//mStartLevel = true;
		}
		//Score here?
	}
	mpSaveData->SaveTheData(mSnake1Score, mSnake2Score, mDifficulty);
	//Add Save Here

	mpGraphicsBuffManager->removeAllBuffers();
	mpAnimationManager->removeAllAnims();
	delete snake;
	delete snake2;
	snake2 = nullptr;
	snake = nullptr;
	delete pFont;
	pFont = nullptr;
}

void Game::handleEvent(const Event& theEvent)
{

	if (theEvent.getType() == COLLISION_EVENT)
	{
		const CollisionEvent& collisionEvent = static_cast<const CollisionEvent&>(theEvent);
		Unit* firstUnit = collisionEvent.getThisUnit();
		Unit* secondUnit = collisionEvent.getCollidingUnit();
		string firstTag = firstUnit->getTag();
		string secondTag = secondUnit->getTag();

		if (firstTag == "Wall" && secondTag == "Snake" || firstTag == "Snake" && secondTag == "Wall")
		{
			mScored = true;
			mSnakeOne = false;
			mStartLevel = true;
		}
		if (firstTag == "Wall" && secondTag == "Snake2" || firstTag == "Snake2" && secondTag == "Wall")
		{
			mScored = true;
			mSnakeOne = true;
			mStartLevel = false;
		}

		//Need one way to reset score when pressing menu?
		if (firstTag == "Snake2" && secondTag == "Snake")
		{
			//increase snake 2 score?
			mScored = true;
			mSnakeOne = false;
			mStartLevel = true;
			//mShouldContinue = false;
		}
		if (firstTag == "Snake" && secondTag == "Snake2")
		{
			//increase snake 1 score?
			//mShouldContinue = false; //Change should continue to a restart bool
			mScored = true;
			mSnakeOne = true;
			mStartLevel = false;
		}
		if (firstTag == "Snake2" && secondTag == "Snake2Body")
		{
			mScored = true;
			mSnakeOne = true;
			mStartLevel = false;
		}
		if (firstTag == "Snake" && secondTag == "SnakeBody")
		{
			mScored = true;
			mSnakeOne = false;
			mStartLevel = false;
		}
		if (firstTag == "Snake" && secondTag == "Snake2Body")
		{
			mScored = true;
			mSnakeOne = false;
			mStartLevel = false;
		}
		if (firstTag == "Snake2" && secondTag == "SnakeBody")
		{
			mScored = true;
			mSnakeOne = true;
			mStartLevel = false;
		}

		Level* level = mpLevelManager->getCurrentLevel();

		if (firstTag == "Food" && secondTag == "Snake")
		{
			Vector2D vec = firstUnit->getLocation();
			level->addEmptyLocation(vec);

			mpUnitManager->delUnit(firstUnit);
			mIsThereFood = false;
		}
		if (firstTag == "Snake" && secondTag == "Food")
		{
			Vector2D vec = secondUnit->getLocation();
			level->addEmptyLocation(vec);

			mpUnitManager->delUnit(secondUnit);
			mScored = true;
			mIsThereFood = false;
		}

		if (firstTag == "Powerup" && secondTag == "Snake")
		{
			Vector2D vec = firstUnit->getLocation();
			level->addEmptyLocation(vec);

			mpUnitManager->delUnit(firstUnit);
			mIsPoweredUp = true;
		}
		if (firstTag == "Snake" && secondTag == "Powerup")
		{
			Vector2D vec = secondUnit->getLocation();
			level->addEmptyLocation(vec);

			mpUnitManager->delUnit(secondUnit);
			mIsPoweredUp = true;
		}
	}
	else if (theEvent.getType() == INPUT_EVENT)
	{
		const InputEvent& inputEvent = static_cast<const InputEvent&>(theEvent);
		int key = inputEvent.getInput();

		switch (key)
		{
		case 1:
			//W
			if (mDirection != 2)
				mDirection = key;
			break;
		case 2:
			//S
			if (mDirection != 1)
				mDirection = key;
			break;
		case 3:
			//A
			if (mDirection != 4)
				mDirection = key;
			break;
		case 4:
			//D
			if (mDirection != 3)
				mDirection = key;
			break;
		case 5:
			//W
			if (mDirection2 != 2)
				mDirection2 = key;
			break;
		case 6:
			//S
			if (mDirection2 != 1)
				mDirection2 = key;
			break;
		case 7:
			//A
			if (mDirection2 != 4)
				mDirection2 = key;
			break;
		case 8:
			//D
			if (mDirection2 != 3)
				mDirection2 = key;
			break;
		case 9:
			mShouldContinue = false;
			break;
		case 10:
			if (mShouldContinue && !mStartLevel)
			{
				mpAudioSystem->playSound(mpClick);
				bool isPPressed = false;
				if (!mEnterSettings && !isPPressed)
				{
					//std::cout << "P" << std::endl;
					mEnterSettings = true;
					isPPressed = true;
				}
				if (mEnterSettings && !isPPressed)
				{
					//std::cout << "P - 2" << std::endl;
					mEnterSettings = false;
					isPPressed = true;
				}
			}
			break;
		case 11:
			if (mShouldContinue && !mStartLevel && !mEnterSettings)
			{
				mpAudioSystem->playSound(mpClick);
				mSnake1Score = 0;
				mSnake2Score = 0;
				mStartLevel = true;
			}
			break;
		case 12:
			if (mShouldContinue && !mStartLevel && mEnterSettings)
			{
				mpAudioSystem->playSound(mpClick);
				bool isMPressed = false;
				if (mLangSetEN && !mLangSetES && !mLangSetFR && !isMPressed)
				{
					mLangSetEN = false;
					mLangSetES = true;
					mLangSetFR = false;
					isMPressed = true;
				}
				if (!mLangSetEN && mLangSetES && !mLangSetFR && !isMPressed)
				{
					mLangSetEN = false;
					mLangSetES = false;
					mLangSetFR = true;
					isMPressed = true;
				}
				if (!mLangSetEN && !mLangSetES && mLangSetFR && !isMPressed)
				{
					mLangSetEN = true;
					mLangSetES = false;
					mLangSetFR = false;
					isMPressed = true;
				}
			}
			break;
		case 13:
			if (mShouldContinue && !mStartLevel && mEnterSettings)
			{
				mpAudioSystem->playSound(mpClick);
				bool isNPressed = false;
				if (mSetEasy && !isNPressed)
				{
					//std::cout << "P" << std::endl;
					mSetEasy = false;
					mSetHard = true;
					isNPressed = true;
				}
				if (mSetHard && !isNPressed)
				{
					//std::cout << "P - 2" << std::endl;
					mSetEasy = true;
					mSetHard = false;
					isNPressed = true;
				}
			}
			break;
		case 14:
			if (mShouldContinue && !mStartLevel && !mEnterSettings)
			{
				mpSaveData->LoadData();
				mSnake1Score = mpSaveData->GetPlayerOneScore();
				mSnake2Score = mpSaveData->GetPlayerTwoScore();
				mDifficulty = mpSaveData->GetDiff();
				mStartLevel = true;
			}
			break;
		default:
			break;
		}
	}
}

void Game::createConsumable(Level* level, Snake* snake, bool food)
{
	std::srand(static_cast<unsigned int>(std::time(0)));

	vector<Vector2D> levelSpaces = level->getEmptyLocations();
	vector<Unit*> snakeSpaces = snake->getSnakePieces();
	vector<Vector2D> snakeLocations;

	for (int i = 0; i < snakeSpaces.size(); i++)
	{
		snakeLocations.push_back(snakeSpaces[i]->getLocation());
	}

	for (int i = 0; i < levelSpaces.size(); i++)
	{
		for (int j = 0; j < snakeLocations.size(); j++)
		{
			if (snakeLocations[j] == levelSpaces[i])
			{
				levelSpaces.erase(levelSpaces.begin() + i);
				break;
			}
		}
	}

	int spawnIter = rand() % levelSpaces.size() + 0;
	Vector2D spawnLoc = levelSpaces[spawnIter];
	level->removeEmptyLocation(spawnLoc);
	int fps = 10;

	if (food)
	{
		mpUnitManager->addUnit(spawnLoc.getX(), spawnLoc.getY(), 1, 1, "Food");
		Unit* head = mpUnitManager->getLastUnit();
		Animation* anim = mpAnimationManager->getAnim("food");
		head->setAnimation(anim);
		mIsThereFood = true;
	}
	else
	{
		mpUnitManager->addUnit(spawnLoc.getX(), spawnLoc.getY(), 1, 1, "Powerup");
		Unit* head = mpUnitManager->getLastUnit();
		Animation* anim = mpAnimationManager->getAnim("powerup");
		head->setAnimation(anim);
	}
}