#include "Game.h"

Game* Game::mpsInstance = nullptr;

void Game::createInstance(int width, int height)
{
	if (mpsInstance == nullptr)
	{
		mpsInstance = new Game;
		mpsInstance->init(width, height);
	}
}

void Game::destroyInstance()
{
	delete mpsInstance;
	mpsInstance = nullptr;
}

Game*Game::getGame()
{
	return mpsInstance;
}

Game::Game()
{
	mpDisplay = nullptr;
	mInputSystem.init();
	mpEventSystem = nullptr;
}

Game::~Game()
{
	cleanUp();
}

void Game::init(int width, int height)
{
	mpEventSystem = EventSystem::getInstance();
	mpEventSystem->init();

	mpEventSystem->getInstance()->addListener((EventType)INPUT_EVENT, this);

	mpDisplay = new GraphicsSystem(width, height);

	mBufferManager.addBuffer(WALL_KEY, SPRITE_PATH + WALL_SPRITE);
	mBufferManager.addBuffer(SNAKE_KEY, SPRITE_PATH + SNAKE_SPRITE);
	mBufferManager.addBuffer(POWERUP_KEY, SPRITE_PATH + GROW_SPRITE);
	mBufferManager.addBuffer(POINTS_KEY, SPRITE_PATH + POINTS_SPRITE);
	mBufferManager.addBuffer(SPEEDUP_KEY, SPRITE_PATH + SPEED_UP_SPRITE);
	mBufferManager.addBuffer(SPEEDDOWN_KEY, SPRITE_PATH + SPEED_DOWN_SPRITE);

	mpFont = new Font((COMMON_PATH + FONT_FILENAME), FONT_SIZE);
	mHUD.init(mpFont);

	getData();
}

void Game::cleanUp()
{
	mLevelManager.clear();
	mSnake.clear();

	mBufferManager.clear();
	mHUD.cleanUp();
	delete mpFont;

	mpDisplay->cleanUp();
	delete mpDisplay;

	mpEventSystem->cleanup();
}

void Game::getData()
{
	Unit* newUnit = new Unit(SNAKE_KEY, Vector2D(STARTING_X, STARTING_Y));
	mSnake.addUnit(newUnit);

	newUnit = new Unit(SNAKE_KEY, Vector2D(STARTING_X - 50, STARTING_Y));
	mSnake.addUnit(newUnit);

	ifstream fin("level" + to_string(mCurrentLevel) + ".txt");
	if (fin.good())
	{
		string dataType;
		int temp;

		while (!fin.eof())
		{
			fin >> dataType;
			if (dataType == "WallPlacement")
			{
				for (int height = 0; height < WALL_ROW_NUM; height++)
				{
					for (int width = 0; width < WALL_COLUMN_NUM; width++)
					{
						fin >> temp;
						if (temp == 1)
						{							
							Unit* newWall = new Unit(WALL_KEY, Vector2D((width * 50) + (WALL_WIDTH / 2), (height * 50) + (WALL_HEIGHT / 2)));
							mLevelManager.addWall(newWall);
						}
					}
				}
			}
			
			if (dataType == "NormalSpeed")
			{
				fin >> temp;
				mSnake.setNormalSpeed(temp);
				mSnake.changeSpeed(temp);
			}
			
			if (dataType == "SlowSpeed")
			{
				fin >> temp;
				mSnake.setSlowSpeed(temp);
			}
			if (dataType == "FastSpeed")
			{
				fin >> temp;
				mSnake.setFastSpeed(temp);
			}
			if (dataType == "SpeedUpChance")
			{
				fin >> temp;
				mLevelManager.setSpeedUpChance(temp);
			}

			if (dataType == "SlowDownChance")
			{
				fin >> temp;
				mLevelManager.setSlowDownChance(temp);
			}

			if (dataType == "PointChance")
			{
				fin >> temp;
				mLevelManager.setPointChance(temp);
			}
			if (dataType == "StartLength")
			{
				fin >> temp;
				for (int i = 0; i < temp; i++)
				{
					Unit* newUnit = new Unit(SNAKE_KEY, mSnake.getUnit(mSnake.getSize() - 1)->getPos() - Vector2D(50,0));
					mSnake.addUnit(newUnit);
				}
			}
			if (dataType == "PowerUpTime")
			{
				fin >> temp;
				mSnake.setPowerUpTIme(temp);
			}
			if (dataType == "WinLength")
			{
				fin >> mWinLength;
			}
			if (dataType == "PointIncrease")
			{
				fin >> mPointIncrease;
			}
		}
	}
	fin.close();

	mLevelManager.spawnItem(POWERUP_KEY, mSnake);
}

void Game::checkCollision()
{
	int i;
	Vector2D temp;

	for (i = 0; i < mLevelManager.getObjectSize(UnitTypes::POWERUP); i++)
	{
		if (temp.getDistanceBetween(mSnake.getHead()->getPos(), mLevelManager.getObject(i, UnitTypes::POWERUP)->getPos()) <= HIT_DISTANCE)
		{
			mPoints += mPointIncrease / 2;
			Unit* newSnake = new Unit(SNAKE_KEY, mSnake.getUnit(mSnake.getSize() - 1)->getPos());
			mSnake.addUnit(newSnake);
			mLevelManager.removeObject(mLevelManager.getObject(i, UnitTypes::POWERUP), UnitTypes::POWERUP);
			mLevelManager.spawnItem(POWERUP_KEY, mSnake);
		}
	}


	for (i = 0; i < mLevelManager.getObjectSize(UnitTypes::WALL); i++)
	{
		if (temp.getDistanceBetween(mSnake.getHead()->getPos(), mLevelManager.getObject(i, UnitTypes::WALL)->getPos()) <= HIT_DISTANCE)
		{
			resetGame();
		}
	}


	for (i = 0; i < mLevelManager.getObjectSize(UnitTypes::SPEEDUP); i++)
	{
		if (temp.getDistanceBetween(mSnake.getHead()->getPos(), mLevelManager.getObject(i, UnitTypes::SPEEDUP)->getPos()) <= HIT_DISTANCE)
		{
			mLevelManager.removeObject(mLevelManager.getObject(i, UnitTypes::SPEEDUP), UnitTypes::SPEEDUP);
			mSnake.changeSpeed(mSnake.getFastSpeed());
		}
	}


	for (i = 0; i < mLevelManager.getObjectSize(UnitTypes::SLOWDOWN); i++)
	{
		if (temp.getDistanceBetween(mSnake.getHead()->getPos(), mLevelManager.getObject(i, UnitTypes::SLOWDOWN)->getPos()) <= HIT_DISTANCE)
		{
			mLevelManager.removeObject(mLevelManager.getObject(i, UnitTypes::SLOWDOWN), UnitTypes::SLOWDOWN);
			mSnake.changeSpeed(mSnake.getSlowSpeed());
		}
	}


	for (i = 0; i < mLevelManager.getObjectSize(UnitTypes::POINTOBJECT); i++)
	{
		if (temp.getDistanceBetween(mSnake.getHead()->getPos(), mLevelManager.getObject(i, UnitTypes::POINTOBJECT)->getPos()) <= HIT_DISTANCE)
		{
			mLevelManager.removeObject(mLevelManager.getObject(i, UnitTypes::POINTOBJECT), UnitTypes::POINTOBJECT);
			mPoints += mPointIncrease;
		}
	}


	for (i = 1; i < mSnake.getSize(); i++)
	{
		if (temp.getDistanceBetween(mSnake.getHead()->getPos(), mSnake.getUnit(i)->getPos()) <= HIT_DISTANCE)
		{
			resetGame();
		}
	}
}

void Game::showMenu()
{
	mpDisplay->clearToBlack();
	if (mGameFail)
	{
		mpDisplay->WriteText(DISP_WIDTH / 2, DISP_HEIGHT / 2 - 25, mpFont, Color(255, 255, 255), "You ran into something!");
		mpDisplay->WriteText(DISP_WIDTH / 2, DISP_HEIGHT / 2 + 25, mpFont, Color(255, 255, 255), "Press Space to play again, or ESC to exit");
	}
	else if (mCurrentLevel != 1)
	{
		mpDisplay->WriteText(DISP_WIDTH / 2, DISP_HEIGHT / 2, mpFont, Color(255, 255, 255), "Press Space to proceed to Level " + mCurrentLevel); //no idea why it gets cut off
	}
	else
	{
		mpDisplay->WriteText(DISP_WIDTH / 2, DISP_HEIGHT / 2 - 25, mpFont, Color(255, 255, 255), "Level 1");
		mpDisplay->WriteText(DISP_WIDTH / 2, DISP_HEIGHT / 2 + 25, mpFont, Color(255, 255, 255), "Press Space to begin, press Escape to quit");
	}
}

void Game::checkWin()
{
	if (mSnake.getSize() == mWinLength)
	{
		int temp = mPoints;
		mGameStart = false;
		mCurrentLevel++;
		if (mCurrentLevel > 3)
		{
			mCurrentLevel = 1;
		}
		resetData();
		mPoints = temp;
	}
}

void Game::resetGame()
{
	mGameFail = true;
	mGameStart = false;
	mCurrentLevel = 1;
	resetData();
}

void Game::resetData()
{
	
	mSnake.clear();
	mLevelManager.clear();
	mDir = Direction::RIGHT;
	mPoints = 0;
	mFPS = 0;
	mTime = 0;
	mSnake.setDirection(mDir);
	getData();
}

void Game::updateHUDData(float time)
{
	mTime += time / 1000.0;
	mFPS = 1000.0 / time;
}

void Game::handleEvent(const Event& event)
{
	if (event.getType() == INPUT_EVENT)
	{
		const InputEvent& inputEvent = static_cast<const InputEvent&>(event);
		if (inputEvent.getKeyCode() == (int)KeyCode::DOWN)
		{
			mDir = Direction::DOWN;
		}
		if (inputEvent.getKeyCode() == (int)KeyCode::UP)
		{
			mDir = Direction::UP;
		}
		if (inputEvent.getKeyCode() == (int)KeyCode::LEFT)
		{
			mDir = Direction::LEFT;
		}
		if (inputEvent.getKeyCode() == (int)KeyCode::RIGHT)
		{
			mDir = Direction::RIGHT;
		}
		if (inputEvent.getKeyCode() == (int)KeyCode::ESCAPE)
		{
			keepGoing = false;
		}
		if (inputEvent.getKeyCode() == (int)KeyCode::SPACE)
		{
			mGameStart = true;
			mGameFail = false;
		}
	}
}

void Game::doLoop()
{
	PerformanceTracker* pPerformanceTracker = new PerformanceTracker;

	Timer loopTimer;

	Vector2D mousePos = Vector2D((DISP_WIDTH / 2) + (SPRITE_WIDTH / 2), (DISP_HEIGHT / 2) + (SPRITE_HEIGHT / 2));

	while (keepGoing)
	{
		pPerformanceTracker->clearTracker("loop");
		pPerformanceTracker->startTracking("loop");
		loopTimer.start();	

		mInputSystem.getKeyEvent();

		if (!mGameStart && keepGoing)
		{
			showMenu();
		}
		else if (keepGoing)
		{
			mSnake.updateSnake(mDir, SLEEP_MS);
			mLevelManager.UpdateAll(SLEEP_MS,mSnake);
		
			checkCollision();

			
			mpDisplay->clearToBlack();
			mSnake.drawAll(mpDisplay);
			mLevelManager.DrawAll(mpDisplay);
			mHUD.drawHUD(mpDisplay);		
		}
		mpDisplay->flip();

		checkWin();
		
		loopTimer.sleepUntilElapsed(SLEEP_MS);
		updateHUDData(loopTimer.getElapsedTime());

		pPerformanceTracker->stopTracking("loop");
		
	}

	delete pPerformanceTracker;
}
