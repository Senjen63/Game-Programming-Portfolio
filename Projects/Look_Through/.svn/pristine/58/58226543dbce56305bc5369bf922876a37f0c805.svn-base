
#include "Game.h"
#include <windows.h>

Game* Game::mpsGameSystem = NULL;

Game::Game()
{
	srand(time(NULL));
	
	mpSystem = new GraphicsSystem();
	mInputSystem.init();

	mpEventSystem = nullptr;
	mMovePt = Vector2D();
}

Game::~Game()
{
	cleanup();
}

void Game::createInstance()
{
	if (mpsGameSystem == NULL)
	{
		mpsGameSystem = new Game;
	}
}

void Game::destroyInstance()
{
	delete mpsGameSystem;
	mpsGameSystem = nullptr;
}

Game* Game::getInstance()
{
	return mpsGameSystem;
}

void Game::init()
{
	loadAssets();

	mBufferManager.createAndManageBuffer(BACKGROUND, mBackgroundCol);
	mBufferManager.createAndManageBuffer(mWallFile, mAssetPath + mWallFile);
	mBufferManager.createAndManageBuffer(mSnakeFile, mAssetPath + mSnakeFile);
	mBufferManager.createAndManageBuffer(mFoodFile, mAssetPath + mFoodFile);
	mBufferManager.createAndManageBuffer(mSpeedUpFile, mAssetPath + mSpeedUpFile);
	mBufferManager.createAndManageBuffer(mSlowDownFile, mAssetPath + mSlowDownFile);
	mBufferManager.createAndManageBuffer(mScoreFile, mAssetPath + mScoreFile);

	mpFont = new Font(mFontPath, mFontSize);
	mpHud = new Hud(mpSystem, mpFont);

	mpEventSystem = EventSystem::getInstance();
	mpEventSystem->init();

	mpHud->init();

	mpEventSystem->getInstance()->addListener((EventType)INPUT_EVENT, this);
	mpEventSystem->getInstance()->addListener((EventType)GAMEPLAY_EVENT, this);
}

void Game::cleanup()
{
	mpSystem->cleanUp();

	mBufferManager.cleanup();
	mSnakeManager.cleanup();
	mLevelManager.cleanUp();

	mSpeedUps.cleanup();
	mSlowDowns.cleanup();
	mFood.cleanup();
	mScoreUnit.cleanup();

	delete mpSystem;

	delete mpFont;
	delete mpHud;

	mpEventSystem->cleanup();
}

void Game::doLoop()
{
	mMovePt = Vector2D(0, 0);

	PerformanceTracker* pTracker = new PerformanceTracker();

	Timer time;
	float elapsedTime = 0.0;
	int spawn = 500;

	loadLevels();

	while (!mExit)
	{
		//start timers
		pTracker->clearTracker("loop");
		pTracker->startTracking("loop");
		time.start();

		if (!mContinueGame)
		{
			mInputSystem.getKeyEvent();
			mpSystem->writeText(Vector2D(DISP_WIDTH / 2, DISP_HEIGHT / 2), mpFont, Color(255, 255, 255), "Press Space to Start Game, or Escape to Exit");
			mpSystem->flip();
		}
		else if (mFinishGame)
		{
			mInputSystem.getKeyEvent();
			mpSystem->writeText(Vector2D(DISP_WIDTH / 2, DISP_HEIGHT / 2), mpFont, Color(255, 255, 255), "Press Space to Play Again, or Escape to Exit");
			mpSystem->flip();
		}
		else
		{
			mHidLevel = false;

			if (mMovePt != Vector2D())
				mSnakeManager.update(SLEEP_MS, mMovePt);

			collisions();

			mInputSystem.getKeyEvent();

			mScoreUnit.update(SLEEP_MS);
			mFood.update(SLEEP_MS);
			mSpeedUps.update(SLEEP_MS);
			mSlowDowns.update(SLEEP_MS);

			if (mSnakeManager.getNumUnits() == mLevelManager.getLevelLength(mCurrentLevel))
			{
				if (mCurrentLevel != mLevelManager.getNumLevels() - 1)
					nextLevel();
				else
				{
					mFinishGame = true;
					unloadLevel();
				}
			}

			if (elapsedTime >= spawn)
			{
				elapsedTime = 0;
				createItem();
			}

			draw();

			mpSystem->flip();

			//sleep for desired time
			time.sleepUntilElapsed(SLEEP_MS);

			hudEvents(time.getElapsedTime());
			elapsedTime += time.getElapsedTime();

			pTracker->stopTracking("loop");
			cout << pTracker->getElapsedTime("loop") << endl;
		}
	}

	delete pTracker;
}

void Game::loadAssets()
{
	ifstream fin;
	fin.open(ASSET_DATA, ios::in);

	string tmp;
	int r, g, b;

	if (!fin.fail())
	{
		while (!fin.eof())
		{
			fin >> tmp;
			
			if (tmp == "BackgroundColor=")
			{
				fin >> r >> g >> b;
				mBackgroundCol = Color(r, g, b);
			}

			if (tmp == "AssetPath=")
				fin >> mAssetPath;

			if (tmp == "Wall=")
				fin >> mWallFile;

			if (tmp == "Snake=")
				fin >> mSnakeFile;

			if (tmp == "Food=")
				fin >> mFoodFile;

			if (tmp == "SpeedUp=")
				fin >> mSpeedUpFile;

			if (tmp == "SlowDown=")
				fin >> mSlowDownFile;

			if (tmp == "Score=")
				fin >> mScoreFile;

			if (tmp == "SpriteWidth=")
				fin >> mSpriteWidth;

			if (tmp == "SpriteHeight=")
				fin >> mSpriteHeight;

			if (tmp == "NumFrames=")
				fin >> mNumFrames;

			if (tmp == "FontPath=")
				fin >> mFontPath;

			if (tmp == "FontSize=")
				fin >> mFontSize;
		}
	}
	else
	{
		cout << "Asset File failed to open." << endl;
	}

	fin.close();
}

void Game::loadLevels()
{
	ifstream fin;
	int tmp, numLevels = 0, currentLevel = 0, numWalls = 0, posX, posY, length, speedSpawn, slowSpawn, scoreSpawn, scorePoints, startingLength;
	string text;

	fin.open(LEVEL_DATA, ios::in);
	
	if (!fin.fail())
	{
		while (!fin.eof())
		{
			fin >> text;

			if (text == "Levels=")
			{
				fin >> numLevels;
				mLevelManager.init(numLevels);
			}

			if (text == "DefaultSpeed=")
			{
				fin >> tmp;
				mDefaultSpeed = tmp;
			}

			if (text == "FastSpeed=")
			{
				fin >> tmp;
				mFastSpeed = tmp;
			}

			if (text == "SlowSpeed=")
			{
				fin >> tmp;
				mSlowSpeed = tmp;
			}

			if (text == "{")
			{
				fin >> numWalls;

				mLevelManager.createSideWalls(currentLevel);

				for (int i = 0; i < numWalls; i++)
				{
					fin >> posX >> posY;
					mLevelManager.createInnerWall(currentLevel, Vector2D(posX, posY));
				}

				fin >> text >> length
					>> text >> speedSpawn
					>> text >> slowSpawn
					>> text >> scoreSpawn
					>> text >> scorePoints
					>> text >> startingLength;

				mLevelManager.loadLevelData(currentLevel, length, speedSpawn, slowSpawn, scoreSpawn, scorePoints, startingLength);

				fin >> text;
				currentLevel++;
			}
			
		}
	}
	else
	{
		cout << "Level File failed to open." << endl;

		mLevelManager.init(numLevels);
		mLevelManager.createSideWalls(numLevels);
	}

	fin.close();
}

void Game::unloadLevel()
{
	mHidLevel = true;
	mSnakeManager.cleanup();
	mFood.cleanup();
	mSpeedUps.cleanup();
	mSlowDowns.cleanup();
	mScoreUnit.cleanup();

	mScore = 0;
	mCurrentLevel = 0;

	mpEventSystem->fireEvent(ScoreEvent(mScore));
}

void Game::nextLevel()
{
	mSnakeManager.cleanup();
	mFood.cleanup();
	mSpeedUps.cleanup();
	mSlowDowns.cleanup();
	mScoreUnit.cleanup();

	mScore = 0;
	mElapsedTime = 0;
	mCurrentLevel++;

	mMovePt = Vector2D();
	mSnakeManager.createAndAddUnit(mBufferManager.getBuffer(mSnakeFile));
	mSnakeManager.setUnitPos(0, Vector2D((DISP_WIDTH / 2), (DISP_HEIGHT / 2)));

	mpEventSystem->fireEvent(ScoreEvent(mScore));
}

void Game::createItem()
{
	int choice = rand() % 101;
	int locationX = (rand() % (DISP_WIDTH / mSpriteWidth)) * mSpriteWidth;
	int locationY = (rand() % (DISP_HEIGHT / mSpriteHeight)) * mSpriteHeight;

	while (mSnakeManager.detectUnits(Vector2D(locationX, locationY)) || mLevelManager.detectUnits(mCurrentLevel, Vector2D(locationX, locationY)) ||
		mFood.detectUnits(Vector2D(locationX, locationY)) || mSpeedUps.detectUnits(Vector2D(locationX, locationY)) || mSlowDowns.detectUnits(Vector2D(locationX, locationY)) ||
		mScoreUnit.detectUnits(Vector2D(locationX, locationY)) || locationX == 0 || locationY == 0)
	{
		locationX = (rand() % (DISP_WIDTH / mSpriteWidth)) * mSpriteWidth;
		locationY = (rand() % (DISP_HEIGHT / mSpriteHeight)) * mSpriteHeight;
	}

	if (choice >= 0 && choice < mLevelManager.getScoreSpawn(mCurrentLevel) && mScoreUnit.getNumUnits() < 1)
	{
		mScoreUnit.createAndAddUnit(mBufferManager.getBuffer(mScoreFile), mNumFrames);
		mScoreUnit.setUnitPos(mScoreUnit.getNumUnits() - 1, Vector2D(locationX, locationY));
	}

	else if (choice >= mLevelManager.getScoreSpawn(mCurrentLevel) && choice < mLevelManager.getScoreSpawn(mCurrentLevel) + mLevelManager.getSpeedSpawn(mCurrentLevel) && mSlowDowns.getNumUnits() <= 2)
	{
		mSlowDowns.createAndAddUnit(mBufferManager.getBuffer(mSlowDownFile), mNumFrames);
		mSlowDowns.setUnitPos(mSlowDowns.getNumUnits() - 1, Vector2D(locationX, locationY));
	}

	else if (choice >= mLevelManager.getScoreSpawn(mCurrentLevel) + mLevelManager.getSlowSpawn(mCurrentLevel) && choice < mLevelManager.getScoreSpawn(mCurrentLevel) + mLevelManager.getSpeedSpawn(mCurrentLevel) + mLevelManager.getSlowSpawn(mCurrentLevel) && mSpeedUps.getNumUnits() <= 2)
	{
		mSpeedUps.createAndAddUnit(mBufferManager.getBuffer(mSpeedUpFile), mNumFrames);
		mSpeedUps.setUnitPos(mSpeedUps.getNumUnits() - 1, Vector2D(locationX, locationY));
	}
	
	else if (choice >= mLevelManager.getScoreSpawn(mCurrentLevel) + mLevelManager.getSpeedSpawn(mCurrentLevel) + mLevelManager.getSlowSpawn(mCurrentLevel) && choice < 100 && mFood.getNumUnits() <= 2)
	{
		mFood.createAndAddUnit(mBufferManager.getBuffer(mFoodFile), mNumFrames);
		mFood.setUnitPos(mFood.getNumUnits() - 1, Vector2D(locationX, locationY));
	}
}

void Game::growSnake()
{
	mSnakeManager.createAndAddUnit(mBufferManager.getBuffer(mSnakeFile));
	mSnakeManager.setUnitPos(mSnakeManager.getNumUnits() - 1, mSnakeManager.getPosition(mSnakeManager.getNumUnits() - 1));
}

void Game::collisions()
{
	if (mSnakeManager.getNumUnits() != 0 && (mLevelManager.detectUnits(mCurrentLevel, mSnakeManager.getPosition(0)) || mSnakeManager.detectUnits()))
		mpEventSystem->fireEvent(GameplayEvent((int)GamePlayEventTypes::LOSE));

	if (mSnakeManager.getNumUnits() != 0 && mScoreUnit.detectUnits(mSnakeManager.getPosition(0)))
	{
		mScore += mLevelManager.getScorePoints(mCurrentLevel);
		mpEventSystem->fireEvent(ScoreEvent(mScore));
		mScoreUnit.deleteUnits(mSnakeManager.getPosition(0));
	}
	
	if (mSnakeManager.getNumUnits() != 0 && mFood.detectUnits(mSnakeManager.getPosition(0)))
	{
		mScore++;
		mpEventSystem->fireEvent(ScoreEvent(mScore));
		mFood.deleteUnits(mSnakeManager.getPosition(0));
		growSnake();

		if (mSnakeManager.getTiming() == mDefaultSpeed)
			mSnakeManager.updateTiming(mDefaultSpeed);
		else if (mSnakeManager.getTiming() == mSlowSpeed)
			mSnakeManager.updateTiming(mSlowSpeed);
		else if (mSnakeManager.getTiming() == mFastSpeed)
			mSnakeManager.updateTiming(mFastSpeed);
	}

	if (mSnakeManager.getNumUnits() != 0 && mSpeedUps.detectUnits(mSnakeManager.getPosition(0)))
	{
		if (mSnakeManager.getTiming() == mDefaultSpeed)
			mSnakeManager.updateTiming(mFastSpeed);
		else if (mSnakeManager.getTiming() == mSlowSpeed)
			mSnakeManager.updateTiming(mDefaultSpeed);

		mSpeedUps.deleteUnits(mSnakeManager.getPosition(0));
	}

	if (mSnakeManager.getNumUnits() != 0 && mSlowDowns.detectUnits(mSnakeManager.getPosition(0)))
	{
		if (mSnakeManager.getTiming() == mDefaultSpeed)
			mSnakeManager.updateTiming(mSlowSpeed);
		else if (mSnakeManager.getTiming() == mFastSpeed)
			mSnakeManager.updateTiming(mDefaultSpeed);

		mSlowDowns.deleteUnits(mSnakeManager.getPosition(0));
	}
}

void Game::draw()
{
	mpSystem->draw(mBufferManager.getBuffer(BACKGROUND), Vector2D(), 1);
	
	if (!mHidLevel)
	{
		mSnakeManager.draw(mpSystem);
		mLevelManager.draw(mpSystem, mCurrentLevel);

		mScoreUnit.draw(mpSystem);
		mFood.draw(mpSystem);
		mSpeedUps.draw(mpSystem);
		mSlowDowns.draw(mpSystem);

		mpHud->display();
	}
}

GraphicsBuffer* Game::getGraphicsBuffer(string index)
{
	return mBufferManager.getBuffer(index);
}

int Game::getDefaultTiming()
{
	return mDefaultSpeed;
}

int Game::getFastTiming()
{
	return mFastSpeed;
}

int Game::getSlowTiming()
{
	return mSlowSpeed;
}

string Game::getWallFile()
{
	return mWallFile;
}

string Game::getSnakeFile()
{
	return mSnakeFile;
}

int Game::getSpriteWidth()
{
	return mSpriteWidth;
}

int Game::getSpriteHeight()
{
	return mSpriteHeight;
}

void Game::hudEvents(float elapsedTime)
{
	mElapsedTime += elapsedTime / mTimeScale;
	mpEventSystem->fireEvent(TimeEvent(mElapsedTime));

	mFps = mTimeScale / elapsedTime;
	mpEventSystem->fireEvent(FpsEvent(mFps));
}

void Game::handleEvent(const Event& event)
{
	if (event.getType() == GAMEPLAY_EVENT)
	{
		const GameplayEvent& gameplayEvent = static_cast<const GameplayEvent&>(event);

		if (gameplayEvent.getAction() == (int)GamePlayEventTypes::LOSE)
		{
			mContinueGame = false;
			mSnakeManager.updateTiming(mDefaultSpeed);
			unloadLevel();
		}
	}
	
	if (event.getType() == INPUT_EVENT)
	{
		const InputEvent& inputEvent = static_cast<const InputEvent&>(event);

		if ((inputEvent.getKeyCode() == (int)KeyCode::A || inputEvent.getKeyCode() == (int)KeyCode::LEFT_ARROW) && mContinueGame)
		{
			if (mMovePt == Vector2D())
			{
				for (int i = 1; i < mLevelManager.getStartingLength(mCurrentLevel); i++)
				{
					mSnakeManager.createAndAddUnit(mBufferManager.getBuffer(mSnakeFile), mSnakeManager.getPosition(i - 1) + Vector2D(mSpriteWidth, 0));
				}
			}
			
			if (mSnakeManager.detectUnits(Vector2D(mSpriteWidth, 0)) || mMovePt != Vector2D(mSpriteWidth, 0))
				mMovePt = Vector2D(-mSpriteWidth, 0);
		}

		if ((inputEvent.getKeyCode() == (int)KeyCode::D || inputEvent.getKeyCode() == (int)KeyCode::RIGHT_ARROW) && mContinueGame)
		{
			if (mMovePt == Vector2D())
			{
				for (int i = 1; i < mLevelManager.getStartingLength(mCurrentLevel); i++)
				{
					mSnakeManager.createAndAddUnit(mBufferManager.getBuffer(mSnakeFile), mSnakeManager.getPosition(i - 1) + Vector2D(-mSpriteWidth, 0));
				}
			}
			
			if (mSnakeManager.detectUnits(Vector2D(-mSpriteWidth, 0)) || mMovePt != Vector2D(-mSpriteWidth, 0))
				mMovePt = Vector2D(mSpriteWidth, 0);
		}

		if ((inputEvent.getKeyCode() == (int)KeyCode::S || inputEvent.getKeyCode() == (int)KeyCode::DOWN_ARROW) && mContinueGame)
		{
			if (mMovePt == Vector2D())
			{
				for (int i = 1; i < mLevelManager.getStartingLength(mCurrentLevel); i++)
				{
					mSnakeManager.createAndAddUnit(mBufferManager.getBuffer(mSnakeFile), mSnakeManager.getPosition(i - 1) + Vector2D(0, -mSpriteHeight));
				}
			}

			if (mSnakeManager.detectUnits(Vector2D(0, -mSpriteHeight)) || mMovePt != Vector2D(0, -mSpriteHeight))
				mMovePt = Vector2D(0, mSpriteHeight);
		}

		if ((inputEvent.getKeyCode() == (int)KeyCode::W || inputEvent.getKeyCode() == (int)KeyCode::UP_ARROW) && mContinueGame)
		{
			if (mMovePt == Vector2D())
			{
				for (int i = 1; i < mLevelManager.getStartingLength(mCurrentLevel); i++)
				{
					mSnakeManager.createAndAddUnit(mBufferManager.getBuffer(mSnakeFile), mSnakeManager.getPosition(i - 1) + Vector2D(0, mSpriteHeight));
				}
			}

			if (mSnakeManager.detectUnits(Vector2D(0, mSpriteHeight)) || mMovePt != Vector2D(0, mSpriteHeight))
				mMovePt = Vector2D(0, -mSpriteHeight);
		}

		if (inputEvent.getKeyCode() == (int)KeyCode::SPACE)
		{
			if (!mContinueGame)
			{
				mSnakeManager.createAndAddUnit(mBufferManager.getBuffer(mSnakeFile));
				mSnakeManager.setUnitPos(0, Vector2D((DISP_WIDTH / 2), (DISP_HEIGHT / 2)));

				mMovePt = Vector2D();
			}

			if (mFinishGame)
			{
				mSnakeManager.createAndAddUnit(mBufferManager.getBuffer(mSnakeFile));
				mSnakeManager.setUnitPos(0, Vector2D((DISP_WIDTH / 2), (DISP_HEIGHT / 2)));

				mMovePt = Vector2D();
				
				mFinishGame = false;
				mScore = 0;
				mCurrentLevel = 0;
			}

			mContinueGame = true;
		}

		if (inputEvent.getKeyCode() == (int)KeyCode::ESCAPE)
		{
			mExit = true;
		}
	}
}