#include "SnakeUnitManager.h"

SnakeUnitManager::SnakeUnitManager()
{
	mTimePerFrame = 1000.0 / NORMAL_SPEED;
	mTimeLeft = 0;
}

void SnakeUnitManager::cleanup()
{
	for (int i = 0; i < mpSnakeUnit.size(); i++)
	{
		SnakeUnit* pUnit = mpSnakeUnit[i];
		delete pUnit;
	}

	mpSnakeUnit.clear();
}

//add unit
void SnakeUnitManager::createAndAddSnakeUnit(Animation snake)
{
	SnakeUnit* pUnit = new SnakeUnit(snake, PrevPos);//send animations to unit to create animation 

	mpSnakeUnit.push_back(pUnit);//store unit in Unit Manager
}

//draw each individual unit on the screen
void SnakeUnitManager::draw(GraphicsSystem* graphicsSystem) //call Unit draw
{
	//loop through all units 
	for (vector<SnakeUnit*>::iterator iter = mpSnakeUnit.begin(); iter != mpSnakeUnit.end(); ++iter)
	{
		SnakeUnit* pUnit = *iter;
		pUnit->draw(graphicsSystem);
	}
}

//UpdateAll: call update on all units
void SnakeUnitManager::update(double dt, Vector2D dir)//call Unit update(dt)
{
	mTimeLeft -= dt;
	if (mTimeLeft <= 0)
	{
		SnakeUnit* pUnit;
		SnakeUnit* oneBefore;

		PrevPos = mpSnakeUnit[mpSnakeUnit.size() - 1]->getLocation();

		//Is there one segment
		if (mpSnakeUnit.size() != 1)
		{
			//Change Body Location
			for (int i = mpSnakeUnit.size() - 1; i > 0; --i)
			{
				pUnit = mpSnakeUnit[i];//last 
				oneBefore = mpSnakeUnit[i - 1];//before last

				pUnit->update(dt, oneBefore->getLocation());
			}
		}

		pUnit = mpSnakeUnit[0];
		pUnit->update(dt, (pUnit->getLocation() + dir)); //Change Head Location
		

		mTimeLeft = mTimePerFrame + mTimeLeft;
	}

	
}

void SnakeUnitManager::speedUp()
{
	mTimePerFrame = 1000.0 / SPEED_UP;
}

void SnakeUnitManager::normalSpeed()
{
	mTimePerFrame = 1000.0 / NORMAL_SPEED;
}

Vector2D SnakeUnitManager::getLocation()
{
	Vector2D headLoc = mpSnakeUnit[0]->getLocation();

	return headLoc;
}

int SnakeUnitManager::getSize()
{
	return mpSnakeUnit.size();
};

//get a particular unit
SnakeUnit* SnakeUnitManager::getUnit(int index)//take in key name
{
	if (SnakeUnitManager::mpSnakeUnit.size() > 0)
	{
		return mpSnakeUnit[index];
	}
	else
	{
		return nullptr;
	}
}

bool SnakeUnitManager::snakeCollisionWithSelf()
{
	Vector2D bodyPos;
	Vector2D headPos;

	SnakeUnit* pHead = mpSnakeUnit[0];

	for (int i = 1; i < mpSnakeUnit.size(); i++)
	{
		SnakeUnit* pUnit = mpSnakeUnit[i];

		//body location
		bodyPos = pUnit->getLocation();

		// get location of the snake head
		headPos = pHead->getLocation();

		// if the head is within the bounds, send event
		if (bodyPos == headPos)
		{
			return true;
		}
	}
	return false;
}

bool SnakeUnitManager::snakeCoolideWithWall(UnitManager& mLevelUnitManager)
{
	//Collision with wall
	Vector2D headLoc = mpSnakeUnit[0]->getLocation();

	for (int i = 0; i < mLevelUnitManager.getSize(); i++)
	{
		Vector2D wall = mLevelUnitManager.getUnit(i)->getLocation();
		float dist = headLoc.getDistanceBetween(headLoc, wall);

		if (dist < 32)
		{
			cout << "Locations Match\n";
			return true;
		}
	}

	/*Vector2D headLoc = mSnakeUnitManager.getUnit(0)->getLocation();

	for (int i = 0; i < mLevelUnitManager.getSize(); i++)
	{
		Vector2D wall = mLevelUnitManager.getUnit(i)->getLocation();
		float dist = headLoc.getDistanceBetween(headLoc, wall);

		if (dist < 32)
		{
			cout << "Locations Match\n";
			return true;
		}
	}*/
}