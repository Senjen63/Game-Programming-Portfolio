#include "GraphicsSystem.h"
#include <Vector2D.h>
#include <allegro5/allegro_image.h>
#include <allegro5/allegro_primitives.h>
#include <allegro5/allegro_ttf.h>

/// <summary>
/// Creates a GraphicsSystem instance.
/// </summary>
GraphicsSystem::GraphicsSystem()
{
    mpDisplay = nullptr;
    mpBackBuffer = nullptr;
}

/// <summary>
/// Clears the display from memory.
/// </summary>
GraphicsSystem::~GraphicsSystem()
{
    if ( mpDisplay )
    {
        cleanup();
    }
}


// Public Methods

/// <summary>
/// Required call at end of program to clear display from memory.
/// </summary>
void GraphicsSystem::cleanup()
{
    al_destroy_display( mpDisplay );
    mpDisplay = nullptr;
    delete mpBackBuffer;
    mpBackBuffer = nullptr;
}

/// <summary>
/// Clears the backbuffer to a color.
/// </summary>
/// <param name="color">: Color to set buffer to.</param>
void GraphicsSystem::clear( const Color & color )
{
    al_clear_to_color( al_map_rgba( color.r, color.g, color.b, color.a ) );
}

/// <summary>
/// Clears a target buffer to a color.
/// </summary>
/// <param name="targetBuffer">: Buffer to be cleared.</param>
/// <param name="color">: Color to set buffer to.</param>
void GraphicsSystem::clear( const GraphicsBuffer & targetBuffer, const Color & color ) const
{
    const GraphicsBuffer * pOldBack = getBackBuffer();
    al_set_target_bitmap( static_cast< ALLEGRO_BITMAP * >(targetBuffer) );
    al_clear_to_color( al_map_rgba( color.r, color.g, color.b, color.a ) );
    al_set_target_bitmap( pOldBack->mpBitmap );
}

/// <summary>
/// 
/// </summary>
/// <param name="width"></param>
/// <param name="height"></param>
void GraphicsSystem::createDisplay( const int width, const int height )
{
    mpDisplay = al_create_display( width, height );
    assert( mpDisplay );
    mpBackBuffer = new GraphicsBuffer( width, height );
    mpBackBuffer->mpBitmap = al_get_backbuffer( mpDisplay );
}

/// <summary>
/// Draws a sprite onto the backbuffer at a position with a scale.
/// </summary>
/// <param name="locX">: X position of sprite.</param>
/// <param name="locY">: Y position of sprite.</param>
/// <param name="sprite">: Sprite to be drawn.</param>
/// <param name="scale">(optional, default = 1.0f): Scale of sprite.</param>
void GraphicsSystem::draw( const int locX, const int locY, const Sprite & sprite, const float scale )
{
    // draw to current bitmap
    al_draw_scaled_bitmap( sprite.getGraphicsBuffer().mpBitmap, static_cast< float >(sprite.getLOCX()), static_cast< float >(sprite.getLOCY()), static_cast< float >(sprite.getWidth()), static_cast< float >(sprite.getHeight()), static_cast< float >(locX), static_cast< float >(locY), static_cast< float >(sprite.getWidth()) * scale, static_cast< float >(sprite.getHeight()) * scale, 0 );
}

void GraphicsSystem::draw( const int locX, const int locY, const GraphicsBuffer & toDrawBuffer, const float scale )
{
    // draw to current bitmap
    al_draw_scaled_bitmap( toDrawBuffer.mpBitmap, 0, 0, static_cast< float >(toDrawBuffer.getWidth()), static_cast< float >(toDrawBuffer.getHeight()), static_cast< float >(locX), static_cast< float >(locY), static_cast< float >(toDrawBuffer.getWidth()) * scale, static_cast< float >(toDrawBuffer.getHeight()) * scale, 0 );
}

/// <summary>
/// Draws a sprite onto a buffer at a position with a scale.
/// </summary>
/// <param name="targetBuffer">: Buffer to be drawn to.</param>
/// <param name="locX">: X position of sprite.</param>
/// <param name="locY">: Y position of sprite.</param>
/// <param name="sprite">: Sprite to be drawn.</param>
/// <param name="scale">(optional, default = 1.0f): Scale of sprite.</param>
void GraphicsSystem::draw( const GraphicsBuffer & targetBuffer, const int locX, const int locY, const Sprite & sprite, const float scale ) const
{
    // draw to target buffer
    const GraphicsBuffer * pOldBack = getBackBuffer();
    al_set_target_bitmap( static_cast< ALLEGRO_BITMAP * >(targetBuffer) );
    al_draw_scaled_bitmap( sprite.getGraphicsBuffer().mpBitmap, static_cast< float >(sprite.getLOCX()), static_cast< float >(sprite.getLOCY()), static_cast< float >(sprite.getWidth()), static_cast< float >(sprite.getHeight()), static_cast< float >(locX), static_cast< float >(locY), static_cast< float >(sprite.getWidth()) * scale, static_cast< float >(sprite.getHeight()) * scale, 0 );
    al_set_target_bitmap( pOldBack->mpBitmap );
}

void GraphicsSystem::draw( const GraphicsBuffer & targetBuffer, const int locX, const int locY, const GraphicsBuffer & toDrawBuffer, const float scale ) const
{
    // draw to target buffer
    const GraphicsBuffer * pOldBack = getBackBuffer();
    al_set_target_bitmap( static_cast< ALLEGRO_BITMAP * >(targetBuffer) );
    al_draw_scaled_bitmap( toDrawBuffer.mpBitmap, 0, 0, static_cast< float >(toDrawBuffer.getWidth()), static_cast< float >(toDrawBuffer.getHeight()), static_cast< float >(locX), static_cast< float >(locY), static_cast< float >(toDrawBuffer.getWidth()) * scale, static_cast< float >(toDrawBuffer.getHeight()) * scale, 0 );
    al_set_target_bitmap( pOldBack->mpBitmap );
}

void GraphicsSystem::draw( const Vector2D & tlStart, const Vector2D & brEnd, const Color & color )
{
    al_draw_filled_rectangle( tlStart.getX(), tlStart.getY(), brEnd.getX(), brEnd.getY(), al_map_rgba( color.r, color.g, color.b, color.a ) );
}

void GraphicsSystem::draw( const Vector2D & tlStart, const Vector2D & brEnd, const Color & color, const float thickness )
{
    al_draw_rectangle( tlStart.getX(), tlStart.getY(), brEnd.getX(), brEnd.getY(), al_map_rgba( color.r, color.g, color.b, color.a ), thickness );
}

void GraphicsSystem::drawEllipse( const Vector2D & point, const Vector2D & size, const Color & color )
{
    al_draw_filled_ellipse( point.getX(), point.getY(), size.getX(), size.getY(), al_map_rgba( color.r, color.g, color.b, color.a ) );
}

void GraphicsSystem::drawEllipse( const Vector2D & point, const Vector2D & size, const Color & color, const float thickness )
{
    al_draw_ellipse( point.getX(), point.getY(), size.getX(), size.getY(), al_map_rgba( color.r, color.g, color.b, color.a ), thickness );
}

void GraphicsSystem::draw( const GraphicsBuffer & targetBuffer, const Vector2D & tlStart, const Vector2D & brEnd, const Color & color ) const
{
    const GraphicsBuffer * pOldBack = getBackBuffer();
    al_set_target_bitmap( static_cast< ALLEGRO_BITMAP * >(targetBuffer) );
    al_draw_filled_rectangle( tlStart.getX(), tlStart.getY(), brEnd.getX(), brEnd.getY(), al_map_rgba( color.r, color.g, color.b, color.a ) );
    al_set_target_bitmap( pOldBack->mpBitmap );
}



/// <summary>
/// Flips the backbuffer to the front.
/// </summary>
void GraphicsSystem::flip()
{
    al_flip_display();
}

/// <returns>
/// ALLEGRO_BITMAP pointer of the display's backbuffer promising no changes.
/// </returns>
GraphicsBuffer * GraphicsSystem::getBackBuffer() const
{
    mpBackBuffer->mpBitmap = al_get_backbuffer( mpDisplay );
    return mpBackBuffer;
}

/// <returns>
/// int of height of the display promising no changes.
/// </returns>
int GraphicsSystem::getHeight() const
{
    return al_get_display_height( mpDisplay );
}

/// <returns>
/// int of width of the display promising no changes.
/// </returns>
int GraphicsSystem::getWidth() const
{
    return al_get_display_width( mpDisplay );
}

/// <summary>
///	Initializes all graphical Allegro requirements.
/// </summary>
/// <exception cref="AllegroInitFail"></exception>
void GraphicsSystem::init()
{
    assert( al_init() );
    assert( al_init_image_addon() );
    assert( al_init_primitives_addon() );
    assert( al_init_font_addon() );
    assert( al_init_ttf_addon() );
}

/// <summary>
/// Saves a buffer bitmap to a file.
/// </summary>
/// <param name="graphicsBuffer">: Buffer to be saved.</param>
/// <param name="pFilename">: Path of file to be made.</param>
void GraphicsSystem::saveBuffer( const GraphicsBuffer & graphicsBuffer, const char * pFilename )
{
    al_save_bitmap( pFilename, graphicsBuffer.mpBitmap );
}

/**
 * \brief Writes text to the backbuffer at a position using a font, color, and text.
 * \param locX X position of text.
 * \param locY Y position of text.
 * \param font Font of text.
 * \param color Color of text.
 * \param pText Text to write.
 */
void GraphicsSystem::writeText( const int locX, const int locY, const Font & font, const Color & color, const char * pText )
{
    al_draw_text( font.mpFont, al_map_rgba( color.r, color.g, color.b, color.a ), static_cast< float >(locX), static_cast< float >(locY), ALLEGRO_ALIGN_CENTER, pText );
}

/**
 * \brief Writes text to a graphics buffer.
 * \param targetBuffer Buffer to be written on. 
 * \param locX X position of text.
 * \param locY Y position of text.
 * \param font Font of text.
 * \param color Color of text.
 * \param pText Text to write.
 */
void GraphicsSystem::writeText( const GraphicsBuffer & targetBuffer, const int locX, const int locY, const Font & font, const Color & color, const char * pText ) const
{
    const GraphicsBuffer * pOldBack = getBackBuffer();
    al_set_target_bitmap( static_cast< ALLEGRO_BITMAP * >(targetBuffer) );
    al_draw_text( font.mpFont, al_map_rgba( color.r, color.g, color.b, color.a ), static_cast< float >(locX), static_cast< float >(locY), ALLEGRO_ALIGN_CENTER, pText );
    al_set_target_bitmap( pOldBack->mpBitmap );
}

GraphicsSystem::operator GraphicsBuffer *() const
{
    return mpBackBuffer;
}
