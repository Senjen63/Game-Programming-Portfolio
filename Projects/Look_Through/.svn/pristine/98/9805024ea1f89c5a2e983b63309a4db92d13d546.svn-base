#include "UnitManager.h"
#include "Game.h"

UnitManager::UnitManager()
{

}


UnitManager::~UnitManager()
{
    cleanup();
}


void UnitManager::init()
{
    mpEventSystem = EventSystem::getInstance();
}


void UnitManager::cleanup()
{
    clearAll();
}


Unit* UnitManager::getLastUnit()
{
    if (mUnits.size() > 0)
    {
        return mUnits.back();
    }
    
    return nullptr;
}


vector<Unit*> UnitManager::getUnitsOfType(UnitTypes type)
{
    vector<Unit*> typeUnits;

    for (auto unit : mUnits)
    {
        if (unit && !unit->getDelete() && unit->getType() == type)
        {
            typeUnits.push_back(unit);
        }
    }

    return typeUnits;
}


int UnitManager::getUnitCount()
{
    return mUnits.size();
}


void UnitManager::handleEvent(const Event& currentEvent)
{

}


void UnitManager::addUnit(Unit* unit)
{
    mUnits.push_back(unit);
}


Unit* UnitManager::addUnit(Vector2D pos, int fps, bool physicsActive, bool gravityActive, bool physicsColliderActive)
{
    Unit* newUnit = new Unit(pos, fps, physicsActive, gravityActive, physicsColliderActive);

    mUnits.push_back(newUnit);

    return getLastUnit();
}


Unit* UnitManager::addUnit(Vector2D pos, AnimationFrames* anim, int fps, bool loopAnimation, int type, bool physicsActive, bool gravityActive, bool physicsColliderActive)
{
    Unit* newUnit = new Unit(pos, anim, fps, loopAnimation, type, physicsActive, gravityActive, physicsColliderActive);

    mUnits.push_back(newUnit);

    return getLastUnit();
}


void UnitManager::deleteUnit(Unit* unit)
{
    delete unit;

    vector<Unit*>::iterator target = find(mUnits.begin(), mUnits.end(), unit);
    mUnits.erase(target);
}


void UnitManager::deleteUnits(vector<Unit*>* units)
{
    for (unsigned int i = 0; i < units->size(); i++)
    {
        deleteUnit((*units)[i]);
    }
}


void UnitManager::deleteUnitsOfType(int type)
{
    for (unsigned int i = 0; i < mUnits.size(); i++)
    {
        if (mUnits[i]->getType() == type)
        {
            deleteUnit(mUnits[i]);
            i--;
        }
    }
}


void UnitManager::deleteUnitsAtPosition(Vector2D mousePosition)
{
    for (int i = mUnits.size() - 1; i >= 0; i--) //delete last unit first
    {
        if (mUnits[i]->isMouseOver(mousePosition))
        {
            delete mUnits[i];

            mUnits.erase(mUnits.begin() + i);
        }
    }
}


void UnitManager::clearAll()
{
    for (unsigned int i = 0; i < mUnits.size(); i++)
    {
        if (mUnits[i]->getType() != UnitTypes::BUTTON_UNIT_TYPE)
        {
            delete mUnits[i];
        }
    }

    mUnits.clear();
}


void UnitManager::nextAnimationForLastUnit()
{
    int nextIndex = getLastUnit()->getCurrentIndex() + 1;

    if (nextIndex >= getLastUnit()->getAnimCount())
    {
        nextIndex = 0;
    }

    getLastUnit()->setAnimation(nextIndex);
}


void UnitManager::setAllPlay(bool play)
{
    for (unsigned int i = 0; i < mUnits.size(); i++)
    {
        Unit* current = mUnits[i];
        current->togglePlay(play);
    }
}


void UnitManager::switchAllPlay()
{
    for (unsigned int i = 0; i < mUnits.size(); i++)
    {
        Unit* current = mUnits[i];
        current->togglePlay(!current->getIsPlaying());
    }
}


vector<Unit*> UnitManager::checkAnyCollisions(Unit* checkUnit, bool onlyPhysicsColliders)
{
    vector<Unit*> collided;

    if (checkUnit != nullptr)
    {
        for (unsigned int i = 0; i < mUnits.size(); i++)
        {
            if (mUnits[i] != nullptr)
            {
                if (mUnits[i] != checkUnit && !mUnits[i]->getDelete())
                {
                    //if doing physics collider check and this physics collider is deactivated, move on, otherwise execute code
                    if ((onlyPhysicsColliders && mUnits[i]->getPhysicsColliderActive()) || !onlyPhysicsColliders)
                    {
                        float xDist = abs(mUnits[i]->getPosition().getX() - checkUnit->getPosition().getX());
                        float yDist = abs(mUnits[i]->getPosition().getY() - checkUnit->getPosition().getY());

                        float otherXRadius = mUnits[i]->getDimensions().getX() / 2;
                        float otherYRadius = mUnits[i]->getDimensions().getY() / 2;
                        float thisXRadius = checkUnit->getDimensions().getX() / 2;
                        float thisYRadius = checkUnit->getDimensions().getY() / 2;

                        if ((xDist <= otherXRadius + thisXRadius) && (yDist <= otherYRadius + thisYRadius))
                        {
                            collided.push_back(mUnits[i]);

                            mpEventSystem->fireEvent(CollisionEvent(checkUnit, mUnits[i]));
                        }
                    }
                }
            }
            else //error, other must never be nullptr
            {

            }
        }
    }
    
    return collided;
}


vector<Unit*> UnitManager::checkCollisionOfType(Unit* checkUnit, int type, bool onlyPhysicsColliders)
{
    vector<Unit*> collided;

    if (checkUnit != nullptr)
    {
        for (auto other : mUnits)
        {
            if (other != nullptr)
            {
                if (other != checkUnit && other->getType() == type && !other->getDelete())
                {
                    //if doing physics collider check and this physics collider is deactivated, move on, otherwise execute code
                    if ((onlyPhysicsColliders && other->getPhysicsColliderActive()) || !onlyPhysicsColliders)
                    {
                        float xDist = abs(other->getPosition().getX() - checkUnit->getPosition().getX());
                        float yDist = abs(other->getPosition().getY() - checkUnit->getPosition().getY());

                        float otherXRadius = other->getDimensions().getX() / 2;
                        float otherYRadius = other->getDimensions().getY() / 2;
                        float thisXRadius = checkUnit->getDimensions().getX() / 2;
                        float thisYRadius = checkUnit->getDimensions().getY() / 2;

                        if ((xDist <= otherXRadius + thisXRadius) && (yDist <= otherYRadius + thisYRadius))
                        {
                            collided.push_back(other);
                        }
                    }
                }
            }
            else //error, other must never be nullptr
            {

            }
        }
    }

    return collided;
}


/*
============================================

returning a vector allows for programmer to 
iterate through it and check for types in 
case collisions with some types does not matter

pos - position to start at
xDiameter, yDiameter - dimensions of area
ignoreUnit - allows user to specify a Unit
to ignore (such as the player)

============================================
*/
vector<Unit*> UnitManager:: checkCollisionInArea(Vector2D pos, float xDiameter, float yDiameter, Unit* ignoreUnit, bool onlyPhysicsColliders)
{
    vector<Unit*> collided;

    float areaXRadius = xDiameter / 2;
    float areaYRadius = yDiameter / 2;

    for (auto other : mUnits)
    {
        if (other != nullptr)
        {
            if (ignoreUnit) //check if ignoreUnit is nullptr, execute as normal otherwise
            {
                if (!other->getDelete() && other != ignoreUnit) //if other is ignoreUnit or flagged as deleted, don't execute
                {
                    //if doing physics collider check and this physics collider is deactivated, move on, otherwise execute code
                    if ((onlyPhysicsColliders && other->getPhysicsColliderActive()) || !onlyPhysicsColliders)
                    {
                        float xDist = abs(other->getPosition().getX() - pos.getX());
                        float yDist = abs(other->getPosition().getY() - pos.getY());

                        float otherXRadius = other->getDimensions().getX() / 2;
                        float otherYRadius = other->getDimensions().getY() / 2;

                        if ((xDist < otherXRadius + areaXRadius) && (yDist < otherYRadius + areaYRadius))
                        {
                            collided.push_back(other);
                        }
                    }
                }
            }
            else
            {
                if (!other->getDelete())
                {
                    float xDist = abs(other->getPosition().getX() - pos.getX());
                    float yDist = abs(other->getPosition().getY() - pos.getY());

                    float otherXRadius = other->getDimensions().getX() / 2;
                    float otherYRadius = other->getDimensions().getY() / 2;

                    if ((xDist < otherXRadius + areaXRadius) && (yDist < otherYRadius + areaYRadius))
                    {
                        collided.push_back(other);
                    }
                }
            }
        }
        else //error, other must never be nullptr
        {

        }
        
    }

    return collided;
}


void UnitManager::updateAll(float elapsedTime)
{
    for (int i = mUnits.size() - 1; i >= 0; i--)
    {
        if (mUnits[i]->getDelete()) //store delete flagged units
        {
            deleteUnit(mUnits[i]);
        }
        else
        {
            mUnits[i]->update(elapsedTime);
        }
    }

    //debugging animation FPS for powerups
    /*for (auto i : mUnits)
    {
        if (i->getType() == UnitTypes::BONUS_POINTS_UNIT_TYPE || i->getType() == UnitTypes::SPEED_UP_UNIT_TYPE || i->getType() == UnitTypes::SLOW_DOWN_UNIT_TYPE)
        {
            cout << i->getCurrentFrameIndex() << endl;
            break;
        }
    }*/
}


void UnitManager::drawAll()
{
    for (int i = mUnits.size() - 1; i >= 0; i--) //draw last item first, appears lower in rendering order
    {
        mUnits[i]->draw();
    }
}


Unit* UnitManager::clickedUnit(Vector2D mousePos)
{
    for (int i = mUnits.size() - 1; i >= 0; i--) //delete last unit first
    {
        if (mUnits[i]->isMouseOver(mousePos))
        {
            return mUnits[i];
        }
    }

    return nullptr;
}


vector<Unit*>* UnitManager::clickedUnits(Vector2D mousePos)
{
    vector<Unit*>* units = new vector<Unit*>;

    for (unsigned int i = 0; i < mUnits.size(); i++)
    {
        if (mUnits[i]->isMouseOver(mousePos))
        {
            units->push_back(mUnits[i]);
        }
    }

    return units;
}